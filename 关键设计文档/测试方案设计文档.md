# pigeon_web 测试方案设计文档

## 文档信息

- **创建时间**: 2025-10-11
- **作者**: yukun.xing
- **状态**: Draft - 待团队Review
- **版本**: v1.0

---

## 一、背景与目标

### 1.1 当前测试现状

**后端测试**：
- 存在一定量的单元测试和API测试
- 使用 pytest + unittest.mock
- SQLite内存数据库
- 覆盖认证、SMS、通道等核心模块

**前端测试**：
- 几乎没有测试（仅1个工具函数测试）
- 已配置vitest但未充分使用

**缺失**：
- 缺少端到端(E2E)测试
- 缺少真实的前后端集成测试
- 单元测试维护成本高（AI频繁重构代码导致测试失效）

### 1.2 设计目标

1. **适应AI辅助开发** - 减少脆弱的单元测试，增加行为验证测试
2. **提升测试ROI** - 重点投入API测试和关键E2E测试
3. **保证代码质量** - 通过API+E2E测试覆盖实现高质量保证
4. **不干扰开发流程** - 本地开发环境与测试环境完全隔离
5. **CI友好** - 测试可在CI环境自动运行

### 1.3 核心策略

```
测试金字塔（传统）              测试金字塔（我们的策略）
     /\                              /\
    /  \  E2E (5%)                  /  \  E2E (25%)
   /----\                          /----\
  / API  \ (15%)                  / Integ \ (20%) ← HTTP + 所有真实服务
 /--------\                      /--------\
/   Unit   \ (80%)              /   API   \ (50%) ← Flask + SQLite
-------------                  /----------\
     X 不适合AI开发            /    Unit    \ (5%)
                              --------------
                                  ✓ 适合AI开发
```

**策略说明**：
- **保留少量单元测试(5%)** - 仅测试核心算法和纯函数
- **重点投入API测试(50%)** - 使用Flask test client + SQLite，快速验证业务逻辑
- **新增集成测试(20%)** - 使用HTTP请求 + 所有真实服务（PostgreSQL/Redis/Gateway等），测试复杂业务流程和服务集成
- **关键E2E测试(25%)** - 覆盖核心用户路径，保证端到端质量
- **完全隔离** - 集成测试和E2E测试都使用独立Docker环境，不影响开发

---

## 二、测试分层设计

### 2.1 四层测试架构

| 测试层级 | 测试对象 | 运行环境 | 速度 | 日常使用频率 | 覆盖目标 |
|---------|---------|---------|------|------------|---------|
| **Unit** | 纯函数、算法 | 无依赖/全Mock | 极快(毫秒) | 中 | 5% |
| **API** | 后端业务逻辑 | Flask test client + SQLite | 快(秒) | 高 | 50% |
| **Integration** | 后端服务集成 | HTTP + 所有真实服务 | 中速(分钟) | 中 | 20% |
| **E2E** | 完整用户流程 | Docker全栈环境 + Playwright | 慢(分钟) | 低 | 25% |

### 2.2 每层测试的职责

#### Unit Tests（单元测试）- 最小化保留

**测试什么**：
- ✅ 核心计算逻辑（如计费算法、短信拆分逻辑）
- ✅ 稳定的工具函数（如日期格式化、数据转换）
- ✅ 纯函数（无副作用，输入确定则输出确定）

**不测试什么**：
- ❌ 业务逻辑（交给API测试）
- ❌ 数据库交互（交给API测试）
- ❌ HTTP路由（交给API测试）
- ❌ React组件（维护成本高，价值低）

**示例**：
```python
# tests/unit/backend/test_billing_calculator.py
def test_calculate_sms_cost():
    """测试短信计费算法"""
    cost = calculate_sms_cost(
        content_length=160,
        country_code='GB',
        rate_per_message=0.05
    )
    assert cost == 0.05
```

#### API Tests（API测试）- 核心重点

**测试什么**：
- ✅ 所有HTTP API端点的业务逻辑
- ✅ 请求参数验证
- ✅ 业务逻辑正确性
- ✅ 数据库CRUD操作
- ✅ 权限控制
- ✅ 错误处理和边界条件

**特点**：
- 使用SQLite内存数据库（快速，隔离）
- 使用factory_boy生成测试数据
- 不启动完整服务，直接调用Flask test client
- 每个测试用例独立，互不影响

**示例**：
```python
# tests/api/sms/test_outbox_filter.py
def test_filter_by_country_code(client, auth_headers):
    """测试按国家筛选发件箱"""
    response = client.get(
        '/api/v1/sms/outbox?country_codes=GB&start_time=2025-01-01&end_time=2025-12-31',
        headers=auth_headers
    )

    assert response.status_code == 200
    data = response.json
    assert data['success'] is True

    # 验证所有记录都是GB
    for record in data['data']['records']:
        assert record['countryCode'] == 'GB'
```

**覆盖目标**：
- 核心API端点：100%覆盖
- 边界条件：每个API至少3-5个测试用例
- 错误场景：400/401/403/404/500 等

#### Integration Tests（集成测试）- 真实环境验证

**测试什么**：
- ✅ 复杂的多步骤业务流程（涉及多个服务协作）
- ✅ 数据库特定功能（PostgreSQL的JSONB、数组、触发器等）
- ✅ 真实数据约束（外键、唯一索引、级联操作）
- ✅ 并发场景（多请求同时操作）
- ✅ 跨服务集成（pigeon_web与pigeon服务的交互）
- ✅ 缓存一致性（Redis与数据库的数据一致性）
- ✅ 性能问题（慢查询、N+1问题等）

**特点**：
- 使用真实的PostgreSQL数据库
- 使用真实的Redis、Gateway等所有后端服务
- 通过HTTP请求调用（而非Flask test client）
- 运行在独立的Docker环境中
- 测试接近生产环境的真实场景

**示例**：
```python
# tests/integration/complex_workflows/test_account_channel_sms_workflow.py
import requests

def test_complete_account_setup_and_sms_workflow(integration_base_url, admin_token):
    """
    测试完整业务流程：
    1. 创建企业账号
    2. 配置通道
    3. 关联账号和通道
    4. 发送短信
    5. 查询发件箱
    6. 验证数据库约束
    """
    headers = {"Authorization": f"Bearer {admin_token}"}

    # Step 1: 创建企业账号
    account_resp = requests.post(
        f"{integration_base_url}/accounts/customers",
        json={"name": "集成测试账号", "accountId": "INTTEST001"},
        headers=headers
    )
    assert account_resp.status_code == 201

    # Step 2: 创建通道
    channel_resp = requests.post(
        f"{integration_base_url}/channels",
        json={"channelId": "INTTEST_CH001", "channelName": "测试通道"},
        headers=headers
    )
    assert channel_resp.status_code == 201

    # Step 3: 关联账号和通道
    binding_resp = requests.post(
        f"{integration_base_url}/accounts/INTTEST001/channels",
        json={"channelId": "INTTEST_CH001"},
        headers=headers
    )
    assert binding_resp.status_code == 200

    # Step 4-6: 发送短信、查询、验证...
```

**覆盖目标**：
- 核心业务流程：5-10个关键场景
- 数据库特定功能：PostgreSQL独有特性
- 并发场景：2-3个典型并发测试

#### E2E Tests（端到端测试）- 关键流程保障

**测试什么**：
- ✅ 核心用户旅程（登录→操作→查看结果）
- ✅ 跨模块协作流程
- ✅ 真实浏览器交互
- ✅ 前后端完整集成

**不测试什么**：
- ❌ 所有细节（交给API测试）
- ❌ 边界条件（交给API测试）
- ❌ 错误处理细节（交给API测试）

**关键E2E场景**（5-10个）：
1. 用户登录 → 查看发件箱 → 按国家筛选 → 查看详情
2. 用户登录 → 查看收件箱 → 导出数据
3. 管理员登录 → 创建账号 → 配置通道 → 查看账号列表
4. 管理员登录 → 创建通道 → 配置告警 → 查看通道状态
5. 用户登录 → 查看统计报表 → 切换时间范围

**特点**：
- 使用Playwright进行浏览器自动化
- 使用独立的Docker环境（完全隔离开发环境）
- 使用真实的PostgreSQL测试数据库
- 使用Page Object Model模式组织测试代码

**示例**：
```typescript
// tests/e2e/tests/features/outbox/filter.spec.ts
test('用户可以按国家筛选发件箱', async ({ page }) => {
  const outbox = new OutboxPage(page);

  await login(page, 'e2e_user', 'password');
  await outbox.goto();
  await outbox.selectCountry('GB');
  await outbox.clickQuery();

  const count = await outbox.getRecordCount();
  expect(count).toBeGreaterThan(0);
  await outbox.verifyAllRecordsHaveCountry('GB');
});
```

---

## 三、目录结构设计

```
pigeon/
├── pigeon_web/                         # 主项目代码
│   ├── app/                            # 后端应用代码
│   ├── frontend/                       # 前端应用代码
│   └── ...
│
└── tests/                              # 测试根目录
    ├── README.md                       # 测试文档：如何运行、如何编写
    ├── pytest.ini                      # pytest配置
    ├── .env.test                       # 测试环境变量
    ├── Makefile                        # 测试命令封装
    │
    ├── fixtures/                       # 共享的pytest fixtures
    │   ├── __init__.py
    │   ├── database.py                 # 数据库相关fixtures
    │   ├── auth.py                     # 认证相关fixtures
    │   └── test_data.py                # 测试数据生成器
    │
    ├── shared/                         # 跨测试类型的共享资源
    │   ├── factories/                  # 数据工厂（factory_boy）
    │   │   ├── __init__.py
    │   │   ├── user_factory.py
    │   │   ├── message_factory.py
    │   │   ├── account_factory.py
    │   │   └── channel_factory.py
    │   ├── helpers/                    # 测试辅助函数
    │   │   ├── __init__.py
    │   │   ├── api_client.py           # API调用封装
    │   │   ├── assertions.py           # 自定义断言
    │   │   └── data_generators.py      # 数据生成工具
    │   └── mock_data/                  # 静态测试数据
    │       ├── messages.json
    │       ├── accounts.json
    │       └── channels.json
    │
    ├── unit/                           # 单元测试（保留少量）
    │   ├── conftest.py                 # unit测试专用fixtures
    │   ├── backend/                    # 后端单元测试
    │   │   ├── __init__.py
    │   │   ├── test_query_builder.py   # SQL查询构建器逻辑
    │   │   ├── test_validators.py      # 数据验证器
    │   │   ├── test_formatters.py      # 数据格式化工具
    │   │   └── test_billing.py         # 计费算法（核心逻辑）
    │   └── frontend/                   # 前端单元测试
    │       ├── utils/
    │       │   └── formatters.test.ts  # 工具函数测试
    │       └── hooks/
    │           └── useAuth.test.ts     # 自定义hooks测试
    │
    ├── api/                            # API测试（重点，快速验证业务逻辑）
    │   ├── conftest.py                 # API测试专用fixtures
    │   ├── test_app.py                 # Flask测试应用配置
    │   ├── init_test_db.sql            # 测试数据库schema初始化
    │   │
    │   ├── auth/                       # 认证模块API测试
    │   │   ├── __init__.py
    │   │   ├── test_login.py           # 登录功能
    │   │   ├── test_logout.py          # 登出功能
    │   │   ├── test_token_refresh.py   # Token刷新
    │   │   ├── test_permissions.py     # 权限验证
    │   │   └── test_password_reset.py  # 密码重置
    │   │
    │   ├── sms/                        # 短信模块API测试
    │   │   ├── __init__.py
    │   │   ├── outbox/
    │   │   │   ├── test_outbox_query.py      # 发件箱查询
    │   │   │   ├── test_outbox_filter.py     # 发件箱筛选（重点）
    │   │   │   ├── test_outbox_pagination.py # 分页功能
    │   │   │   ├── test_outbox_sort.py       # 排序功能
    │   │   │   ├── test_outbox_detail.py     # 消息详情
    │   │   │   └── test_outbox_export.py     # 导出功能
    │   │   └── inbox/
    │   │       ├── test_inbox_query.py       # 收件箱查询
    │   │       ├── test_inbox_filter.py      # 收件箱筛选
    │   │       └── test_inbox_detail.py      # 消息详情
    │   │
    │   ├── accounts/                   # 账号管理API测试
    │   │   ├── __init__.py
    │   │   ├── test_account_crud.py    # 账号增删改查
    │   │   ├── test_account_list.py    # 账号列表查询
    │   │   └── test_account_settings.py # 账号配置
    │   │
    │   ├── channels/                   # 通道管理API测试
    │   │   ├── __init__.py
    │   │   ├── test_channel_crud.py    # 通道增删改查
    │   │   ├── test_channel_alert.py   # 通道告警配置
    │   │   └── test_channel_status.py  # 通道状态查询
    │   │
    │   └── management/                 # 其他管理功能API测试
    │       ├── __init__.py
    │       ├── test_country_regions.py # 国家区域管理
    │       ├── test_blacklist.py       # 黑名单管理
    │       ├── test_whitelist.py       # 白名单管理
    │       ├── test_sender_mgmt.py     # Sender管理
    │       └── test_pricing.py         # 价格管理
    │
    ├── integration/                    # 集成测试（真实环境）
    │   ├── README.md                   # 集成测试文档
    │   ├── conftest.py                 # 集成测试专用fixtures
    │   ├── docker/                     # Docker环境配置
    │   │   ├── docker-compose.integration.yml  # Docker编排文件
    │   │   ├── backend.Dockerfile      # 后端测试镜像
    │   │   └── init-db.sql             # 测试数据初始化
    │   │
    │   ├── complex_workflows/          # 复杂业务流程测试
    │   │   ├── test_account_channel_sms_workflow.py  # 账号-通道-短信完整流程
    │   │   ├── test_concurrent_operations.py         # 并发操作测试
    │   │   └── test_data_consistency.py              # 数据一致性测试
    │   │
    │   ├── database_specific/          # 数据库特定功能测试
    │   │   ├── test_postgresql_constraints.py  # PostgreSQL约束测试
    │   │   ├── test_transaction_isolation.py   # 事务隔离测试
    │   │   ├── test_jsonb_operations.py        # JSONB字段操作
    │   │   └── test_cascade_operations.py      # 级联操作测试
    │   │
    │   ├── cross_service/              # 跨服务集成测试
    │   │   ├── test_pigeon_integration.py      # 与pigeon服务集成
    │   │   └── test_cache_consistency.py       # 缓存一致性测试
    │   │
    │   └── performance/                # 性能测试
    │       ├── test_slow_queries.py            # 慢查询检测
    │       └── test_large_dataset.py           # 大数据量场景
    │
    └── e2e/                            # 端到端测试
        ├── README.md                   # E2E测试文档
        ├── package.json                # Playwright及相关依赖
        ├── package-lock.json
        ├── playwright.config.ts        # Playwright配置
        ├── tsconfig.json               # TypeScript配置
        │
        ├── docker/                     # Docker环境配置
        │   ├── docker-compose.e2e.yml  # Docker编排文件
        │   ├── backend.Dockerfile      # 后端测试镜像
        │   ├── frontend.Dockerfile     # 前端测试镜像
        │   ├── nginx.conf              # Nginx配置
        │   └── init-db.sql             # E2E测试数据初始化
        │
        ├── fixtures/                   # E2E测试fixtures
        │   ├── auth.ts                 # 认证相关（登录状态管理）
        │   ├── test-data.ts            # 测试数据helpers
        │   └── cleanup.ts              # 测试清理工具
        │
        ├── pages/                      # Page Object Model
        │   ├── BasePage.ts             # 基础页面类
        │   ├── LoginPage.ts            # 登录页
        │   ├── DashboardPage.ts        # 首页
        │   ├── OutboxPage.ts           # 发件箱页
        │   ├── InboxPage.ts            # 收件箱页
        │   ├── AccountManagementPage.ts # 账号管理页
        │   └── ChannelManagementPage.ts # 通道管理页
        │
        └── tests/                      # E2E测试用例
            ├── smoke/                  # 冒烟测试（最关键的流程）
            │   ├── login.spec.ts       # 登录流程
            │   └── critical-path.spec.ts # 核心业务路径
            │
            ├── features/               # 功能测试
            │   ├── outbox/
            │   │   ├── filter.spec.ts  # 发件箱筛选
            │   │   ├── export.spec.ts  # 发件箱导出
            │   │   ├── detail.spec.ts  # 消息详情查看
            │   │   └── pagination.spec.ts # 分页
            │   ├── inbox/
            │   │   ├── query.spec.ts   # 收件箱查询
            │   │   └── filter.spec.ts  # 收件箱筛选
            │   └── management/
            │       ├── accounts.spec.ts # 账号管理
            │       └── channels.spec.ts # 通道管理
            │
            └── regression/             # 回归测试（记录历史bug）
                ├── issue-001-outbox-filter-bug.spec.ts
                └── issue-002-export-timeout.spec.ts
```

---

## 四、测试环境隔离方案（重点）

### 4.1 问题：与开发环境的冲突

**开发环境**（日常启动，用于手工测试）：
```
前端: http://localhost:5173
后端: http://localhost:5000
数据库: localhost:8668/pigeon_sms
Redis: localhost:6379
Pigeon服务: Gateway/Workers等
```

**集成测试环境**（运行集成测试时启动）：
```
后端: http://localhost:5002  ← 不同端口
数据库: localhost:5434/pigeon_sms_integration  ← 不同端口和数据库
Redis: localhost:6380  ← 不同端口
Pigeon服务: 独立的测试实例
```

**E2E测试环境**（运行E2E测试时启动）：
```
前端: http://localhost:5174  ← 不同端口
后端: http://localhost:5001  ← 不同端口
数据库: localhost:5433/pigeon_sms_e2e  ← 不同端口和数据库
Redis: localhost:6381  ← 不同端口
Pigeon服务: 独立的测试实例
```

### 4.2 解决方案：独立Docker环境

**核心思想**：集成测试和E2E测试都使用完全独立的Docker容器，与本地开发环境零冲突。

#### 4.2.1 集成测试环境配置

```yaml
# tests/integration/docker/docker-compose.integration.yml
version: '3.8'

services:
  # PostgreSQL测试数据库
  postgres-integration:
    image: postgres:16
    container_name: pigeon-integration-postgres
    environment:
      POSTGRES_USER: yuexin
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: pigeon_sms_integration
    ports:
      - "5434:5432"  # 映射到不同的端口，避免冲突
    volumes:
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U yuexin"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - integration-network

  # Redis测试实例
  redis-integration:
    image: redis:8
    container_name: pigeon-integration-redis
    ports:
      - "6380:6379"
    networks:
      - integration-network

  # 后端服务
  backend-integration:
    build:
      context: ../../../pigeon_web
      dockerfile: ../tests/integration/docker/backend.Dockerfile
    container_name: pigeon-integration-backend
    environment:
      FLASK_ENV: integration_testing
      DATABASE_URL: postgresql://yuexin:test_password@postgres-integration:5432/pigeon_sms_integration
      REDIS_URL: redis://redis-integration:6379
      SECRET_KEY: integration-test-secret-key
      JWT_SECRET_KEY: integration-jwt-secret
    ports:
      - "5002:5000"
    depends_on:
      postgres-integration:
        condition: service_healthy
      redis-integration:
        condition: service_started
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/api/v1/health"]
      interval: 5s
      timeout: 5s
      retries: 10
    networks:
      - integration-network

  # Pigeon Gateway（如果需要测试短信发送流程）
  # gateway-integration:
  #   build:
  #     context: ../../../pigeon
  #     dockerfile: src/main/gateway/Dockerfile
  #   environment:
  #     CONFIG_PATH: /config/gateway.test.toml
  #   ports:
  #     - "2776:2775"  # SMPP端口
  #   networks:
  #     - integration-network

networks:
  integration-network:
    name: pigeon-integration-network
    driver: bridge
```

#### 4.2.2 E2E测试环境配置

```yaml
# tests/e2e/docker/docker-compose.e2e.yml
version: '3.8'

services:
  # PostgreSQL测试数据库
  postgres-e2e:
    image: postgres:16
    container_name: pigeon-e2e-postgres
    environment:
      POSTGRES_USER: yuexin
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: pigeon_sms_e2e
    ports:
      - "5433:5432"  # 映射到不同的端口，避免冲突
    volumes:
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U yuexin"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - e2e-network

  # Redis测试实例
  redis-e2e:
    image: redis:8
    container_name: pigeon-e2e-redis
    ports:
      - "6381:6379"
    networks:
      - e2e-network

  # 后端API服务
  backend-e2e:
    build:
      context: ../../../pigeon_web
      dockerfile: ../tests/e2e/docker/backend.Dockerfile
    container_name: pigeon-e2e-backend
    environment:
      FLASK_ENV: e2e_testing
      DATABASE_URL: postgresql://yuexin:test_password@postgres-e2e:5432/pigeon_sms_e2e
      REDIS_URL: redis://redis-e2e:6379
      SECRET_KEY: e2e-test-secret-key
      JWT_SECRET_KEY: e2e-jwt-secret
    ports:
      - "5001:5000"
    depends_on:
      postgres-e2e:
        condition: service_healthy
      redis-e2e:
        condition: service_started
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/api/v1/health"]
      interval: 5s
      timeout: 5s
      retries: 10
    networks:
      - e2e-network

  # 前端服务（生产构建+Nginx）
  frontend-e2e:
    build:
      context: ../../../pigeon_web/frontend
      dockerfile: ../../../tests/e2e/docker/frontend.Dockerfile
    container_name: pigeon-e2e-frontend
    environment:
      VITE_API_BASE_URL: http://localhost:5001
    ports:
      - "5174:80"
    depends_on:
      backend-e2e:
        condition: service_healthy
    networks:
      - e2e-network

networks:
  e2e-network:
    name: pigeon-e2e-network
    driver: bridge
```

### 4.3 Dockerfile配置

```dockerfile
# tests/e2e/docker/backend.Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 复制并安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 添加健康检查端点（如果没有的话）
# HEALTHCHECK CMD curl -f http://localhost:5000/api/v1/health || exit 1

EXPOSE 5000

# 启动应用
CMD ["python", "run.py"]
```

```dockerfile
# tests/e2e/docker/frontend.Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# 复制package文件并安装依赖
COPY package*.json ./
RUN npm ci

# 复制源代码并构建
COPY . .
RUN npm run build

# 生产环境：使用Nginx提供静态文件
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制Nginx配置
COPY ../../../tests/e2e/docker/nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

```nginx
# tests/e2e/docker/nginx.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # 前端路由
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API代理（可选，如果前端直接调用backend-e2e容器）
    # location /api {
    #     proxy_pass http://backend-e2e:5000;
    #     proxy_set_header Host $host;
    #     proxy_set_header X-Real-IP $remote_addr;
    #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # }
}
```

### 4.4 测试数据初始化

```sql
-- tests/e2e/docker/init-db.sql
-- 1. 使用主数据库schema
\i /docker-entrypoint-initdb.d/../../pigeon_web/sql/pigeon_web.sql

-- 2. 插入E2E测试专用数据

-- 测试管理员账号
INSERT INTO admin_users (username, password_hash, email, is_active, created_at)
VALUES
  ('e2e_admin', '$2b$12$...', 'e2e_admin@test.com', true, NOW()),
  ('e2e_user', '$2b$12$...', 'e2e_user@test.com', true, NOW());

-- 测试客户账号
INSERT INTO customers_accounts (account_id, name, enabled, created_at)
VALUES
  ('E2E_ACC_001', 'E2E测试账号1', true, NOW()),
  ('E2E_ACC_002', 'E2E测试账号2', true, NOW());

-- 测试通道
INSERT INTO customers_channels (channel_id, channel_name, channel_type, enabled, created_at)
VALUES
  ('E2E_CH_001', 'E2E测试通道1', 'SMPP', true, NOW()),
  ('E2E_CH_002', 'E2E测试通道2', 'HTTP', true, NOW());

-- 测试短信数据（发件箱）
INSERT INTO short_messages (
  message_id, account_id, status, country_code, phone_number,
  content, sender, channel_id, send_time, created_at
)
VALUES
  ('E2E_MSG_GB_001', 'E2E_ACC_001', 'ChannelSendSuccess', 'GB', '447700900001',
   'Test message to UK 1', 'TestSender', 'E2E_CH_001', NOW(), NOW()),
  ('E2E_MSG_GB_002', 'E2E_ACC_001', 'ChannelSendSuccess', 'GB', '447700900002',
   'Test message to UK 2', 'TestSender', 'E2E_CH_001', NOW(), NOW()),
  ('E2E_MSG_US_001', 'E2E_ACC_001', 'ChannelSendSuccess', 'US', '12025550123',
   'Test message to US 1', 'TestSender', 'E2E_CH_002', NOW(), NOW()),
  ('E2E_MSG_US_002', 'E2E_ACC_001', 'ChannelSendFailed', 'US', '12025550124',
   'Test message to US 2 failed', 'TestSender', 'E2E_CH_002', NOW(), NOW());

-- 测试短信数据（收件箱）
INSERT INTO delivers (
  message_id, account_id, deliver_type, status, country_code,
  phone_number, content, receive_time, created_at
)
VALUES
  ('E2E_DELIVER_001', 'E2E_ACC_001', 'UplinkSMS', 'Processed', 'GB',
   '447700900001', 'Reply from UK user', NOW(), NOW()),
  ('E2E_DELIVER_002', 'E2E_ACC_001', 'Receipt', 'Processed', 'US',
   '12025550123', '', NOW(), NOW());
```

---

## 五、运行方式

### 5.1 日常开发工作流

```bash
# 1. 本地开发环境（一直运行）
# 启动数据库
cd pigeon/deployment/docker/middleware/postgresql
docker-compose up -d

# 启动后端
cd pigeon_web
source /Users/yukun-admin/projects/pigeon/venv/bin/activate
python run.py

# 启动前端
cd pigeon_web/frontend
npm run dev

# 浏览器访问 http://localhost:5173 进行手工测试
```

```bash
# 2. 快速验证后端逻辑（推荐，日常开发）
cd pigeon/tests
pytest api/sms/test_outbox_filter.py -v

# 运行所有API测试
pytest api/ -v --cov

# 运行特定模块的API测试
pytest api/auth/ -v
pytest api/sms/ -v
```

```bash
# 3. 真实环境验证（重要功能完成后）
cd pigeon/tests
make test-integration

# 或者分步执行
make integration-up      # 启动集成测试环境
pytest integration/ -v   # 运行集成测试
make integration-down    # 清理环境
```

```bash
# 4. 重大功能上线前，运行E2E测试（完全独立）
cd pigeon/tests
make test-e2e

# 或者分步执行
make e2e-up      # 启动E2E环境
# 浏览器访问 http://localhost:5174 手动验证
make e2e-test    # 运行测试
make e2e-down    # 清理环境
```

### 5.2 Makefile命令封装

```makefile
# tests/Makefile
.PHONY: help test-all test-unit test-api test-integration test-smoke test-e2e
.PHONY: integration-up integration-down integration-logs e2e-up e2e-down e2e-logs clean

# 默认显示帮助
help:
	@echo "pigeon_web 测试命令"
	@echo ""
	@echo "快速测试（日常开发，秒级）："
	@echo "  make test-api          - 运行API测试（推荐）"
	@echo "  make test-unit         - 运行单元测试"
	@echo ""
	@echo "集成测试（真实环境，分钟级）："
	@echo "  make test-integration  - 运行集成测试"
	@echo "  make integration-up    - 启动集成测试环境（调试用）"
	@echo "  make integration-down  - 停止集成测试环境"
	@echo "  make integration-logs  - 查看集成测试日志"
	@echo ""
	@echo "E2E测试（全栈环境，分钟级）："
	@echo "  make test-smoke        - 运行冒烟测试（5-10分钟）"
	@echo "  make test-e2e          - 运行完整E2E测试（10-20分钟）"
	@echo "  make e2e-up            - 启动E2E环境（调试用）"
	@echo "  make e2e-down          - 停止E2E环境"
	@echo "  make e2e-logs          - 查看E2E日志"
	@echo ""
	@echo "完整测试："
	@echo "  make test-all          - 运行所有测试（CI用）"
	@echo "  make clean             - 清理测试产物"

# 运行所有测试（CI用）
test-all: test-unit test-api test-integration test-e2e
	@echo "✅ 所有测试通过"

# 单元测试
test-unit:
	@echo "🧪 运行单元测试..."
	pytest unit/ -v

# API测试（日常开发推荐）
test-api:
	@echo "🧪 运行API测试..."
	pytest api/ -v --cov=../pigeon_web/app --cov-report=html --cov-report=term-missing
	@echo "📊 覆盖率报告: tests/htmlcov/index.html"

# 集成测试（真实环境）
test-integration: integration-up
	@echo "🧪 运行集成测试..."
	pytest integration/ -v --tb=short
	$(MAKE) integration-down

# 冒烟测试（最快的E2E）
test-smoke: e2e-up
	@echo "🧪 运行冒烟测试..."
	cd e2e && npx playwright test --project=smoke
	@echo "📊 测试报告: tests/e2e/playwright-report/index.html"

# 完整E2E测试
test-e2e: e2e-up
	@echo "🧪 运行E2E测试..."
	cd e2e && npx playwright test
	@echo "📊 测试报告: tests/e2e/playwright-report/index.html"
	$(MAKE) e2e-down

# 启动集成测试环境
integration-up:
	@echo "🚀 启动集成测试环境..."
	cd integration/docker && docker-compose -f docker-compose.integration.yml up -d --build
	@echo "⏳ 等待服务就绪（约20秒）..."
	@sleep 20
	@echo "✅ 集成测试环境已启动"
	@echo "   后端: http://localhost:5002/api/v1/health"
	@echo "   数据库: localhost:5434/pigeon_sms_integration"
	@echo "   Redis: localhost:6380"

# 停止集成测试环境
integration-down:
	@echo "🛑 停止集成测试环境..."
	cd integration/docker && docker-compose -f docker-compose.integration.yml down -v
	@echo "✅ 集成测试环境已清理"

# 查看集成测试日志
integration-logs:
	@echo "📋 集成测试环境日志："
	cd integration/docker && docker-compose -f docker-compose.integration.yml logs -f

# 启动E2E环境
e2e-up:
	@echo "🚀 启动E2E测试环境..."
	cd e2e/docker && docker-compose -f docker-compose.e2e.yml up -d --build
	@echo "⏳ 等待服务就绪（约30秒）..."
	@sleep 30
	@echo "✅ E2E环境已启动"
	@echo "   前端: http://localhost:5174"
	@echo "   后端: http://localhost:5001/api/v1/health"
	@echo "   数据库: localhost:5433/pigeon_sms_e2e"

# 停止E2E环境
e2e-down:
	@echo "🛑 停止E2E环境..."
	cd e2e/docker && docker-compose -f docker-compose.e2e.yml down -v
	@echo "✅ E2E环境已清理"

# 查看E2E日志
e2e-logs:
	@echo "📋 E2E环境日志："
	cd e2e/docker && docker-compose -f docker-compose.e2e.yml logs -f

# 清理测试产物
clean:
	@echo "🧹 清理测试产物..."
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	find . -type d -name "*.pyc" -delete 2>/dev/null || true
	find . -type d -name ".pytest_cache" -exec rm -rf {} + 2>/dev/null || true
	rm -rf htmlcov/ .coverage 2>/dev/null || true
	rm -rf e2e/playwright-report/ e2e/test-results/ 2>/dev/null || true
	@echo "✅ 清理完成"
```

### 5.3 常用测试命令

```bash
# ============ 日常开发（快速验证） ============

# 快速验证某个功能
pytest tests/api/sms/test_outbox_filter.py::test_filter_by_country -v

# 运行某个模块的所有API测试
pytest tests/api/sms/ -v

# 运行API测试并生成覆盖率报告
pytest tests/api/ --cov --cov-report=html

# ============ 集成测试（真实环境验证） ============

# 启动集成测试环境
cd tests
make integration-up

# 运行特定的集成测试
pytest integration/complex_workflows/test_account_channel_sms_workflow.py -v

# 运行所有集成测试
pytest integration/ -v

# 停止集成测试环境
make integration-down

# ============ E2E测试 ============

# 运行某个E2E测试文件
cd tests/e2e
make e2e-up
npx playwright test tests/features/outbox/filter.spec.ts

# 调试E2E测试（带浏览器界面）
npx playwright test --debug

# 查看E2E测试报告
npx playwright show-report

# ============ CI ============

# CI环境运行所有测试
cd tests
make test-all
```

---

## 六、CI集成方案

### 6.1 GitHub Actions配置

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  # Job 1: API测试（快速反馈）
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: 安装依赖
        run: |
          cd pigeon_web
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: 运行API测试
        run: |
          cd tests
          pytest api/ -v --cov=../pigeon_web/app --cov-report=xml

      - name: 上传覆盖率报告
        uses: codecov/codecov-action@v3
        with:
          files: ./tests/coverage.xml
          flags: api-tests

  # Job 2: 集成测试（真实环境）
  integration-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: 安装依赖
        run: |
          cd pigeon_web
          pip install -r requirements.txt
          pip install pytest

      - name: 启动集成测试环境
        run: |
          cd tests/integration/docker
          docker-compose -f docker-compose.integration.yml up -d --build
          sleep 20

      - name: 运行集成测试
        run: |
          cd tests
          pytest integration/ -v --tb=short

      - name: 清理集成测试环境
        if: always()
        run: |
          cd tests/integration/docker
          docker-compose -f docker-compose.integration.yml down -v

  # Job 3: E2E测试（较慢，但保证质量）
  e2e-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Node.js环境
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: 安装Playwright
        run: |
          cd tests/e2e
          npm ci
          npx playwright install --with-deps chromium

      - name: 启动E2E环境
        run: |
          cd tests/e2e/docker
          docker-compose -f docker-compose.e2e.yml up -d --build
          sleep 30

      - name: 运行E2E测试
        run: |
          cd tests/e2e
          npx playwright test

      - name: 上传测试报告
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: tests/e2e/playwright-report/
          retention-days: 7

      - name: 清理E2E环境
        if: always()
        run: |
          cd tests/e2e/docker
          docker-compose -f docker-compose.e2e.yml down -v

  # Job 4: 单元测试（可选）
  unit-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: 安装依赖
        run: |
          cd pigeon_web
          pip install -r requirements.txt
          pip install pytest

      - name: 运行单元测试
        run: |
          cd tests
          pytest unit/ -v
```

### 6.2 测试策略

```yaml
# 不同分支的测试策略
main分支（生产）:
  - 运行所有测试（unit + api + integration + e2e）
  - 要求100%通过
  - 生成覆盖率报告

develop分支（开发）:
  - 运行API测试 + 集成测试 + 冒烟E2E测试
  - 允许部分测试失败（标记为flaky）

feature分支（特性）:
  - 仅运行API测试
  - 快速反馈

PR（Pull Request）:
  - 运行API测试 + 集成测试（如果涉及关键流程）
  - 要求通过才能合并
```

---

## 七、最佳实践

### 7.1 编写测试的原则

1. **测试要独立**：每个测试用例应该能够独立运行，不依赖其他测试的执行顺序
2. **测试要快速**：API测试应在秒级完成，E2E测试应控制在分钟级
3. **测试要稳定**：避免flaky tests（不稳定的测试），特别是E2E测试
4. **测试要清晰**：测试名称应清楚描述测试内容，遵循 `test_<功能>_<场景>_<预期结果>` 格式
5. **测试要聚焦**：每个测试只验证一个功能点，不要贪多

### 7.2 API测试最佳实践

```python
# ✅ 好的API测试示例
def test_filter_outbox_by_country_returns_only_specified_country_records(
    client, auth_headers, db_session
):
    """测试按国家筛选发件箱，应只返回指定国家的记录"""
    # Arrange: 准备测试数据
    MessageFactory.create(country_code='GB', account_id='TEST_001')
    MessageFactory.create(country_code='US', account_id='TEST_001')
    MessageFactory.create(country_code='GB', account_id='TEST_001')

    # Act: 执行操作
    response = client.get(
        '/api/v1/sms/outbox?country_codes=GB&start_time=2025-01-01&end_time=2025-12-31',
        headers=auth_headers
    )

    # Assert: 验证结果
    assert response.status_code == 200
    data = response.json
    assert data['success'] is True
    assert data['data']['pagination']['totalCount'] == 2

    for record in data['data']['records']:
        assert record['countryCode'] == 'GB'

# ❌ 不好的测试示例（测试内容不清晰，验证不充分）
def test_outbox(client, auth_headers):
    response = client.get('/api/v1/sms/outbox?country_codes=GB', headers=auth_headers)
    assert response.status_code == 200
```

**命名规范**：
- `test_<功能模块>_<操作>_<场景>_<预期结果>`
- 示例：`test_outbox_filter_by_invalid_country_returns_400`

**Arrange-Act-Assert模式**：
```python
def test_example(client, auth_headers):
    # Arrange: 准备测试数据和环境
    user = UserFactory.create()

    # Act: 执行被测试的操作
    response = client.post('/api/v1/users', json={...}, headers=auth_headers)

    # Assert: 验证结果
    assert response.status_code == 201
    assert response.json['data']['username'] == user.username
```

### 7.3 集成测试最佳实践

```python
# ✅ 好的集成测试示例（真实环境，复杂流程）
import requests

def test_complete_account_and_channel_setup_workflow(integration_base_url, admin_token):
    """
    测试完整的账号-通道配置流程
    验证：
    1. 账号创建成功
    2. 通道创建成功
    3. 账号与通道关联成功
    4. 数据库约束正确
    5. 级联操作正确
    """
    headers = {"Authorization": f"Bearer {admin_token}"}

    # Step 1: 创建企业账号
    account_resp = requests.post(
        f"{integration_base_url}/accounts/customers",
        json={
            "name": "集成测试企业",
            "accountId": "INT_TEST_001",
            "enabled": True
        },
        headers=headers
    )
    assert account_resp.status_code == 201
    account_data = account_resp.json()
    assert account_data['success'] is True

    # Step 2: 创建通道
    channel_resp = requests.post(
        f"{integration_base_url}/channels",
        json={
            "channelId": "INT_TEST_CH_001",
            "channelName": "集成测试通道",
            "channelType": "SMPP",
            "enabled": True
        },
        headers=headers
    )
    assert channel_resp.status_code == 201

    # Step 3: 关联账号和通道
    binding_resp = requests.post(
        f"{integration_base_url}/accounts/INT_TEST_001/channels",
        json={"channelId": "INT_TEST_CH_001"},
        headers=headers
    )
    assert binding_resp.status_code == 200

    # Step 4: 验证关联成功
    account_detail_resp = requests.get(
        f"{integration_base_url}/accounts/INT_TEST_001",
        headers=headers
    )
    assert account_detail_resp.status_code == 200
    account_detail = account_detail_resp.json()
    assert len(account_detail['data']['channels']) == 1
    assert account_detail['data']['channels'][0]['channelId'] == 'INT_TEST_CH_001'

    # Step 5: 测试级联删除
    delete_resp = requests.delete(
        f"{integration_base_url}/accounts/INT_TEST_001",
        headers=headers
    )
    assert delete_resp.status_code == 200

    # 验证账号已删除
    get_deleted_resp = requests.get(
        f"{integration_base_url}/accounts/INT_TEST_001",
        headers=headers
    )
    assert get_deleted_resp.status_code == 404

# ✅ 测试并发场景
import concurrent.futures

def test_concurrent_outbox_queries(integration_base_url, admin_token):
    """测试并发查询发件箱，验证数据库连接池和事务隔离"""
    headers = {"Authorization": f"Bearer {admin_token}"}

    def query_outbox(country_code):
        response = requests.get(
            f"{integration_base_url}/sms/outbox",
            params={
                "country_codes": country_code,
                "start_time": "2025-01-01",
                "end_time": "2025-12-31"
            },
            headers=headers
        )
        return response.status_code == 200, response.json()

    countries = ["GB", "US", "FR", "DE", "JP", "CN", "IN", "BR", "AU", "CA"]

    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(query_outbox, country) for country in countries]
        results = [f.result() for f in concurrent.futures.as_completed(futures)]

    # 所有请求都应该成功
    for success, data in results:
        assert success is True
        assert data['success'] is True

# ✅ 测试PostgreSQL特定功能
def test_jsonb_query_in_channel_config(integration_base_url, admin_token):
    """测试PostgreSQL JSONB字段查询"""
    headers = {"Authorization": f"Bearer {admin_token}"}

    # 创建通道，config字段是JSONB
    channel_resp = requests.post(
        f"{integration_base_url}/channels",
        json={
            "channelId": "JSONB_TEST_CH",
            "channelName": "JSONB测试通道",
            "config": {
                "provider": "TwilioProvider",
                "region": "US",
                "max_rate": 1000
            }
        },
        headers=headers
    )
    assert channel_resp.status_code == 201

    # 查询 JSONB 字段
    query_resp = requests.get(
        f"{integration_base_url}/channels",
        params={"config.provider": "TwilioProvider"},
        headers=headers
    )
    assert query_resp.status_code == 200
    channels = query_resp.json()['data']
    assert any(ch['channelId'] == 'JSONB_TEST_CH' for ch in channels)
```

**集成测试命名规范**：
- `test_<完整业务流程描述>`
- 示例：`test_complete_account_channel_sms_workflow`
- 示例：`test_concurrent_sms_sending_with_different_accounts`

**何时写集成测试**：
- ✅ 复杂的多步骤业务流程
- ✅ 跨服务交互场景
- ✅ 并发场景
- ✅ 数据库特定功能（PostgreSQL的JSONB、数组等）
- ✅ 真实数据约束验证（外键、触发器等）

### 7.4 E2E测试最佳实践

**使用Page Object Model**：
```typescript
// ✅ 好的E2E测试示例（使用POM）
test('用户可以按国家筛选发件箱', async ({ page }) => {
  // Arrange
  const loginPage = new LoginPage(page);
  const outboxPage = new OutboxPage(page);

  // Act
  await loginPage.login('e2e_user', 'password');
  await outboxPage.goto();
  await outboxPage.selectCountry('GB');
  await outboxPage.clickQuery();

  // Assert
  await expect(outboxPage.recordCount).toBeGreaterThan(0);
  await outboxPage.verifyAllRecordsHaveCountry('GB');
});

// ❌ 不好的E2E测试示例（直接操作DOM）
test('filter test', async ({ page }) => {
  await page.goto('/login');
  await page.fill('#username', 'user');
  await page.fill('#password', 'pass');
  await page.click('button');
  await page.goto('/messages/outbox');
  await page.click('.country-select');
  // ... 测试代码难以维护
});
```

**等待策略**：
```typescript
// ✅ 显式等待加载完成
await page.waitForSelector('.ant-spin-spinning', { state: 'hidden' });

// ✅ 等待网络请求完成
await page.waitForResponse(resp => resp.url().includes('/api/v1/sms/outbox'));

// ❌ 避免使用固定延迟
await page.waitForTimeout(3000); // 不好
```

**测试数据隔离**：
```typescript
// 每个测试使用独立的测试数据
test.beforeEach(async () => {
  // 使用唯一标识创建测试数据
  testAccountId = `E2E_${Date.now()}`;
});

test.afterEach(async () => {
  // 清理测试数据（如果需要）
  await cleanupTestData(testAccountId);
});
```

### 7.5 测试数据管理

**使用Factory模式生成测试数据**：
```python
# tests/shared/factories/message_factory.py
import factory
from app.models.sms.short_message import ShortMessage
from app.extensions import db

class MessageFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        model = ShortMessage
        sqlalchemy_session = db.session

    message_id = factory.Sequence(lambda n: f'TEST_MSG_{n:06d}')
    account_id = 'TEST_ACCOUNT_001'
    status = 'ChannelSendSuccess'
    country_code = 'GB'
    phone_number = factory.Sequence(lambda n: f'4477009{n:05d}')
    content = factory.Faker('text', max_nb_chars=160)
    sender = 'TestSender'
    channel_id = 'TEST_CHANNEL_001'
    send_time = factory.Faker('date_time_this_year')

# 使用
MessageFactory.create()  # 创建单个
MessageFactory.create_batch(10)  # 批量创建
MessageFactory.create(country_code='US')  # 覆盖默认值
```

### 7.6 避免的常见陷阱

**❌ 不要在测试中使用sleep**：
```python
# 不好
def test_something(client):
    client.post('/api/v1/start-job')
    time.sleep(5)  # 等待任务完成
    response = client.get('/api/v1/job-status')
    assert response.json['status'] == 'completed'

# 好
def test_something(client):
    client.post('/api/v1/start-job')
    # 使用轮询或事件机制
    wait_for_condition(lambda: client.get('/api/v1/job-status').json['status'] == 'completed')
```

**❌ 不要在测试间共享可变状态**：
```python
# 不好
global_test_data = {'user': None}

def test_create_user():
    global_test_data['user'] = create_user()

def test_update_user():  # 依赖上一个测试
    update_user(global_test_data['user'])

# 好
@pytest.fixture
def test_user(db_session):
    user = create_user()
    yield user
    # 清理由fixture自动处理

def test_update_user(test_user):
    update_user(test_user)
```

**❌ 不要过度mock**：
```python
# 不好（mock太多，测试失去意义）
@patch('app.services.sms_service.get_account')
@patch('app.services.sms_service.get_channel')
@patch('app.services.sms_service.query_database')
@patch('app.services.sms_service.format_response')
def test_outbox_query(mock1, mock2, mock3, mock4):
    # 这个测试几乎什么都没测

# 好（仅mock外部依赖）
def test_outbox_query(client, db_session):
    # 使用真实数据库（测试数据库），真实查询
    response = client.get('/api/v1/sms/outbox?...')
    # 验证真实的业务逻辑
```

---

## 八、团队协作规范

### 8.1 开发流程中的测试要求

**功能开发流程**：
1. 开发新功能时，先写API测试（TDD可选）
2. 实现功能代码
3. 本地运行API测试验证（`make test-api`）
4. 手工测试验证UI和用户体验
5. 如果涉及复杂业务流程或跨服务交互，编写集成测试
6. 提交代码前运行相应的测试套件
7. 提交PR，CI自动运行测试

**Bug修复流程**：
1. 先写一个失败的测试，复现bug
   - 简单bug：写API测试
   - 复杂业务流程bug：写集成测试
   - UI相关bug：写E2E测试
2. 修复代码，使测试通过
3. 将E2E测试放入 `tests/e2e/tests/regression/` 目录
4. 测试文件命名：`issue-<编号>-<简短描述>.spec.ts`

### 8.2 代码提交检查清单

**提交前必须（日常开发）**：
- [ ] 本地运行 `make test-api` 通过
- [ ] 相关API测试已更新或新增
- [ ] 手工测试验证功能正常

**提交前可选（复杂功能）**：
- [ ] 涉及复杂业务流程：运行 `make test-integration` 通过
- [ ] 新增集成测试覆盖复杂场景

**提交前可选（重大功能）**：
- [ ] 运行 `make test-smoke` 通过
- [ ] 新增E2E测试覆盖关键用户路径

**不要求**：
- ❌ 不要求每次提交都运行集成测试和E2E测试（较慢）
- ❌ 不要求100%测试覆盖率（务实即可）

### 8.3 测试失败的处理

**API测试失败**：
- 立即修复（不允许提交失败的测试）
- 如果测试本身有问题，修复测试
- API测试失败通常说明业务逻辑有问题

**集成测试失败**：
- 优先检查是否是真实bug还是环境问题
- 真实bug：修复并更新测试
- 环境问题：检查Docker容器、数据库连接等
- 数据库约束问题：检查schema和测试数据
- 并发问题：检查事务隔离级别和锁机制

**E2E测试失败**：
- 区分是真bug还是flaky test
- 如果是flaky test，标记 `test.fixme()` 或增加重试
- 如果是真bug，修复并更新测试

**处理flaky E2E测试**：
```typescript
// 临时跳过不稳定的测试
test.fixme('这个测试不稳定，需要优化', async ({ page }) => {
  // test code
});

// 或者增加重试次数
test.describe.configure({ retries: 2 });
```

### 8.4 测试代码的Code Review要求

**API测试Review要点**：
- [ ] 测试名称清晰描述测试内容
- [ ] 测试独立，不依赖其他测试
- [ ] 使用Factory创建测试数据，不hardcode
- [ ] 验证充分（不仅是200状态码，还要验证数据正确性）
- [ ] 遵循AAA模式（Arrange-Act-Assert）

**集成测试Review要点**：
- [ ] 测试完整的业务流程，不测试细节（细节交给API测试）
- [ ] 使用HTTP请求，不使用Flask test client
- [ ] 验证跨服务交互正确性
- [ ] 验证数据库约束和级联操作
- [ ] 并发测试使用合理的并发数
- [ ] 测试数据清理完整，避免污染环境

**E2E测试Review要点**：
- [ ] 使用Page Object Model
- [ ] 避免使用sleep，使用显式等待
- [ ] 测试聚焦关键路径，不追求细节
- [ ] 失败时截图和trace清晰

---

## 九、迁移计划

### 9.1 第一阶段：基础搭建（1周）

**目标**：搭建测试框架，迁移现有测试

**任务**：
1. 创建 `tests/` 目录结构
2. 配置pytest和Playwright
3. 迁移现有的后端测试到新目录
4. 编写1-2个API测试示例
5. 编写1个E2E测试示例
6. 配置Makefile命令

**验收标准**：
- `make test-api` 可以运行
- `make test-e2e` 可以运行E2E环境

### 9.2 第二阶段：API测试覆盖（2-3周）

**目标**：覆盖核心API端点的业务逻辑

**任务**：
1. 发件箱API测试（查询、筛选、分页、导出、详情）
2. 收件箱API测试（查询、筛选、详情）
3. 账号管理API测试（CRUD、列表）
4. 通道管理API测试（CRUD、告警、状态）
5. 认证API测试（登录、权限、Token）

**目标覆盖率**：70%+ API端点

### 9.3 第三阶段：集成测试补充（1-2周）

**目标**：测试复杂业务流程和真实环境

**任务**：
1. 配置集成测试Docker环境
2. 编写5-10个复杂业务流程测试
   - 账号-通道-短信完整流程
   - 并发场景测试
   - 数据一致性测试
3. 编写数据库特定功能测试
   - PostgreSQL约束测试
   - JSONB字段操作测试
   - 级联操作测试
4. 编写跨服务集成测试（如果需要）
   - pigeon_web与pigeon服务集成
   - 缓存一致性测试

**关键场景**：
- 完整的账号配置流程
- 并发操作验证
- 数据库约束和级联操作

### 9.4 第四阶段：E2E测试补充（1-2周）

**目标**：覆盖关键用户路径

**任务**：
1. 编写5-10个关键E2E测试
2. 配置Docker环境
3. 优化E2E测试稳定性
4. 配置CI集成

**关键场景**：
- 登录 → 查看发件箱 → 筛选 → 详情
- 登录 → 查看收件箱 → 导出
- 管理员 → 创建账号 → 配置通道
- 管理员 → 查看统计报表

### 9.5 第五阶段：持续优化（长期）

**目标**：维护和优化测试套件

**任务**：
1. 定期Review测试覆盖率
2. 清理过时的单元测试
3. 优化集成测试和API测试速度
4. 优化E2E测试稳定性
5. 处理flaky tests
6. 更新测试文档
7. 根据实际情况调整各层测试的比例

---

## 十、附录

### 10.1 技术栈

**后端测试**：
- pytest 7.4+
- pytest-cov（覆盖率）
- factory_boy（测试数据工厂）
- SQLAlchemy（ORM）

**前端测试**：
- Playwright（E2E测试）
- vitest（单元测试，可选）

**基础设施**：
- Docker & Docker Compose
- PostgreSQL 16
- GitHub Actions

### 10.2 参考资料

- [Playwright官方文档](https://playwright.dev/)
- [pytest官方文档](https://docs.pytest.org/)
- [Testing Best Practices](https://martinfowler.com/testing/)
- [Page Object Model](https://playwright.dev/docs/pom)

### 10.3 常见问题FAQ

**Q1: 为什么要放弃大部分单元测试？**
A: 在AI辅助开发场景下，代码重构频繁，单元测试维护成本高。API测试、集成测试和E2E测试验证行为而非实现，更稳定。

**Q2: API测试和集成测试有什么区别？**
A:
- API测试：使用Flask test client + SQLite，快速验证业务逻辑，秒级完成
- 集成测试：使用HTTP请求 + 真实PostgreSQL/Redis等服务，测试复杂流程和真实环境，分钟级完成

**Q3: 日常开发时应该运行哪些测试？**
A: 日常开发主要运行API测试（秒级），够快且覆盖大部分业务逻辑。重要功能完成后再运行集成测试。

**Q4: 集成测试和E2E测试会不会很慢？**
A:
- 集成测试：1-3分钟，测试复杂业务流程
- E2E测试：10-20分钟，只运行5-10个关键场景
- 日常开发不需要每次都运行，重要功能或发布前运行

**Q5: 测试环境会不会和开发环境冲突？**
A: 不会。集成测试和E2E测试都使用完全独立的Docker环境，不同的端口和数据库。

**Q6: API测试需要手动准备数据吗？**
A: 不需要。使用factory_boy自动生成测试数据，每个测试独立创建和清理。

**Q7: 如何处理flaky E2E测试？**
A:
1. 优化等待策略（避免sleep）
2. 增加重试次数
3. 如果仍不稳定，标记为 `test.fixme()` 并创建issue跟踪

**Q8: CI环境测试失败了怎么办？**
A:
1. 查看GitHub Actions的测试报告
2. API测试失败：检查业务逻辑
3. 集成测试失败：检查Docker环境和数据库
4. E2E测试失败：下载Playwright的截图和trace
5. 本地复现：`make integration-up && pytest integration/ -v` 或 `make e2e-up && cd tests/e2e && npx playwright test --debug`

**Q9: 什么时候应该写集成测试而不是API测试？**
A: 当涉及以下场景时应该写集成测试：
- 复杂的多步骤业务流程（3个以上步骤）
- 需要验证数据库约束和级联操作
- 并发场景测试
- PostgreSQL特定功能（JSONB、数组等）
- 跨服务交互

**Q10: 集成测试环境启动太慢怎么办？**
A:
1. 保持集成测试环境运行：`make integration-up` 后不要立即 down
2. 开发期间可以一直保持环境运行，只在完成后清理
3. 使用 `make integration-logs` 查看服务状态
4. 考虑优化Docker镜像大小和启动速度

---

## 十一、总结

本测试方案的核心理念：

1. **适应AI开发** - 减少脆弱的单元测试，增加稳定的行为测试
2. **务实高效** - 投入产出比高，5% Unit + 50% API + 20% Integration + 25% E2E
3. **环境隔离** - 集成测试和E2E测试完全独立，不干扰日常开发
4. **快速反馈** - 日常依赖快速的API测试（秒级），重要功能用集成测试（分钟级），发布前用E2E测试
5. **持续优化** - 测试也是代码，需要不断维护和改进

**四层测试架构的价值**：
- **Unit (5%)** - 核心算法保障
- **API (50%)** - 日常开发快速反馈，业务逻辑验证
- **Integration (20%)** - 真实环境验证，复杂流程和跨服务集成测试
- **E2E (25%)** - 关键用户路径保障，前后端完整集成

**预期收益**：
- ✅ 代码质量有保障（API + Integration + E2E 三层覆盖）
- ✅ 开发效率高（API测试秒级反馈）
- ✅ 真实环境验证（集成测试发现生产环境问题）
- ✅ 维护成本低（少量单元测试，稳定的行为测试）
- ✅ CI快速反馈（API测试秒级，集成测试分钟级，E2E测试分钟级）
- ✅ 团队信心提升（关键流程有完整的测试保障）

**下一步行动**：
1. 团队Review本文档，讨论并达成共识
2. 按照迁移计划逐步实施
3. 持续迭代优化测试策略
4. 根据实际情况调整各层测试比例

---

**文档版本历史**：
- v1.0 (2025-10-11): 初始版本，待团队Review
- v1.1 (2025-10-17): 增加集成测试层（Backend Integration Tests），形成四层测试架构
- v1.2 (2025-10-17): 调整命名，API测试(Flask+SQLite)用于快速验证，集成测试(HTTP+真实服务)用于真实环境验证
