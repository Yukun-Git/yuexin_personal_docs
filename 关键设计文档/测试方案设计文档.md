# pigeon_web 测试方案设计文档

## 文档信息

- **创建时间**: 2025-10-11
- **作者**: yukun.xing
- **状态**: Draft - 待团队Review
- **版本**: v1.0

---

## 一、背景与目标

### 1.1 当前测试现状

**后端测试**：
- 存在一定量的单元测试和API测试
- 使用 pytest + unittest.mock
- SQLite内存数据库
- 覆盖认证、SMS、通道等核心模块

**前端测试**：
- 几乎没有测试（仅1个工具函数测试）
- 已配置vitest但未充分使用

**缺失**：
- 缺少端到端(E2E)测试
- 缺少真实的前后端集成测试
- 单元测试维护成本高（AI频繁重构代码导致测试失效）

### 1.2 设计目标

1. **适应AI辅助开发** - 减少脆弱的单元测试，增加行为验证测试
2. **提升测试ROI** - 重点投入API测试和关键E2E测试
3. **保证代码质量** - 通过API+E2E测试覆盖实现高质量保证
4. **不干扰开发流程** - 本地开发环境与测试环境完全隔离
5. **CI友好** - 测试可在CI环境自动运行

### 1.3 核心策略

```
测试金字塔（传统）              测试金字塔（我们的策略）
     /\                              /\
    /  \  E2E (5%)                  /  \  E2E (30%)
   /----\                          /----\
  / API  \ (15%)                  / API  \ (60%)
 /--------\                      /--------\
/   Unit   \ (80%)              /   Unit   \ (10%)
-------------                   -------------
     X 不适合AI开发                  ✓ 适合AI开发
```

**策略说明**：
- **大幅减少单元测试** - 仅保留核心算法和稳定工具函数的测试
- **重点投入API测试** - 验证业务逻辑，覆盖70%+ API端点
- **关键E2E测试** - 覆盖核心用户路径，保证端到端质量
- **完全隔离** - E2E测试使用独立Docker环境，不影响开发

---

## 二、测试分层设计

### 2.1 三层测试架构

| 测试层级 | 测试对象 | 运行环境 | 速度 | 日常使用频率 | 覆盖目标 |
|---------|---------|---------|------|------------|---------|
| **Unit** | 纯函数、算法 | 无依赖/全Mock | 极快(秒) | 中 | 10% |
| **API** | 后端API端点 | Flask + 测试DB | 快(秒) | 高 | 60% |
| **E2E** | 完整用户流程 | Docker独立环境 | 慢(分钟) | 低 | 30% |

### 2.2 每层测试的职责

#### Unit Tests（单元测试）- 最小化保留

**测试什么**：
- ✅ 核心计算逻辑（如计费算法、短信拆分逻辑）
- ✅ 稳定的工具函数（如日期格式化、数据转换）
- ✅ 纯函数（无副作用，输入确定则输出确定）

**不测试什么**：
- ❌ 业务逻辑（交给API测试）
- ❌ 数据库交互（交给API测试）
- ❌ HTTP路由（交给API测试）
- ❌ React组件（维护成本高，价值低）

**示例**：
```python
# tests/unit/backend/test_billing_calculator.py
def test_calculate_sms_cost():
    """测试短信计费算法"""
    cost = calculate_sms_cost(
        content_length=160,
        country_code='GB',
        rate_per_message=0.05
    )
    assert cost == 0.05
```

#### API Tests（API集成测试）- 核心重点

**测试什么**：
- ✅ 所有HTTP API端点
- ✅ 请求参数验证
- ✅ 业务逻辑正确性
- ✅ 数据库CRUD操作
- ✅ 权限控制
- ✅ 错误处理和边界条件

**特点**：
- 使用SQLite内存数据库（快速，隔离）
- 使用factory_boy生成测试数据
- 不启动前端，直接调用Flask test client
- 每个测试用例独立，互不影响

**示例**：
```python
# tests/api/sms/test_outbox_filter.py
def test_filter_by_country_code(client, auth_headers):
    """测试按国家筛选发件箱"""
    response = client.get(
        '/api/v1/sms/outbox?country_codes=GB&start_time=2025-01-01&end_time=2025-12-31',
        headers=auth_headers
    )

    assert response.status_code == 200
    data = response.json
    assert data['success'] is True

    # 验证所有记录都是GB
    for record in data['data']['records']:
        assert record['countryCode'] == 'GB'
```

**覆盖目标**：
- 核心API端点：100%覆盖
- 边界条件：每个API至少3-5个测试用例
- 错误场景：400/401/403/404/500 等

#### E2E Tests（端到端测试）- 关键流程保障

**测试什么**：
- ✅ 核心用户旅程（登录→操作→查看结果）
- ✅ 跨模块协作流程
- ✅ 真实浏览器交互
- ✅ 前后端完整集成

**不测试什么**：
- ❌ 所有细节（交给API测试）
- ❌ 边界条件（交给API测试）
- ❌ 错误处理细节（交给API测试）

**关键E2E场景**（5-10个）：
1. 用户登录 → 查看发件箱 → 按国家筛选 → 查看详情
2. 用户登录 → 查看收件箱 → 导出数据
3. 管理员登录 → 创建账号 → 配置通道 → 查看账号列表
4. 管理员登录 → 创建通道 → 配置告警 → 查看通道状态
5. 用户登录 → 查看统计报表 → 切换时间范围

**特点**：
- 使用Playwright进行浏览器自动化
- 使用独立的Docker环境（完全隔离开发环境）
- 使用真实的PostgreSQL测试数据库
- 使用Page Object Model模式组织测试代码

**示例**：
```typescript
// tests/e2e/tests/features/outbox/filter.spec.ts
test('用户可以按国家筛选发件箱', async ({ page }) => {
  const outbox = new OutboxPage(page);

  await login(page, 'e2e_user', 'password');
  await outbox.goto();
  await outbox.selectCountry('GB');
  await outbox.clickQuery();

  const count = await outbox.getRecordCount();
  expect(count).toBeGreaterThan(0);
  await outbox.verifyAllRecordsHaveCountry('GB');
});
```

---

## 三、目录结构设计

```
pigeon/
├── pigeon_web/                         # 主项目代码
│   ├── app/                            # 后端应用代码
│   ├── frontend/                       # 前端应用代码
│   └── ...
│
└── tests/                              # 测试根目录
    ├── README.md                       # 测试文档：如何运行、如何编写
    ├── pytest.ini                      # pytest配置
    ├── .env.test                       # 测试环境变量
    ├── Makefile                        # 测试命令封装
    │
    ├── fixtures/                       # 共享的pytest fixtures
    │   ├── __init__.py
    │   ├── database.py                 # 数据库相关fixtures
    │   ├── auth.py                     # 认证相关fixtures
    │   └── test_data.py                # 测试数据生成器
    │
    ├── shared/                         # 跨测试类型的共享资源
    │   ├── factories/                  # 数据工厂（factory_boy）
    │   │   ├── __init__.py
    │   │   ├── user_factory.py
    │   │   ├── message_factory.py
    │   │   ├── account_factory.py
    │   │   └── channel_factory.py
    │   ├── helpers/                    # 测试辅助函数
    │   │   ├── __init__.py
    │   │   ├── api_client.py           # API调用封装
    │   │   ├── assertions.py           # 自定义断言
    │   │   └── data_generators.py      # 数据生成工具
    │   └── mock_data/                  # 静态测试数据
    │       ├── messages.json
    │       ├── accounts.json
    │       └── channels.json
    │
    ├── unit/                           # 单元测试（保留少量）
    │   ├── conftest.py                 # unit测试专用fixtures
    │   ├── backend/                    # 后端单元测试
    │   │   ├── __init__.py
    │   │   ├── test_query_builder.py   # SQL查询构建器逻辑
    │   │   ├── test_validators.py      # 数据验证器
    │   │   ├── test_formatters.py      # 数据格式化工具
    │   │   └── test_billing.py         # 计费算法（核心逻辑）
    │   └── frontend/                   # 前端单元测试
    │       ├── utils/
    │       │   └── formatters.test.ts  # 工具函数测试
    │       └── hooks/
    │           └── useAuth.test.ts     # 自定义hooks测试
    │
    ├── api/                            # API集成测试（重点）
    │   ├── conftest.py                 # API测试专用fixtures
    │   ├── test_app.py                 # Flask测试应用配置
    │   ├── init_test_db.sql            # 测试数据库schema初始化
    │   │
    │   ├── auth/                       # 认证模块API测试
    │   │   ├── __init__.py
    │   │   ├── test_login.py           # 登录功能
    │   │   ├── test_logout.py          # 登出功能
    │   │   ├── test_token_refresh.py   # Token刷新
    │   │   ├── test_permissions.py     # 权限验证
    │   │   └── test_password_reset.py  # 密码重置
    │   │
    │   ├── sms/                        # 短信模块API测试
    │   │   ├── __init__.py
    │   │   ├── outbox/
    │   │   │   ├── test_outbox_query.py      # 发件箱查询
    │   │   │   ├── test_outbox_filter.py     # 发件箱筛选（重点）
    │   │   │   ├── test_outbox_pagination.py # 分页功能
    │   │   │   ├── test_outbox_sort.py       # 排序功能
    │   │   │   ├── test_outbox_detail.py     # 消息详情
    │   │   │   └── test_outbox_export.py     # 导出功能
    │   │   └── inbox/
    │   │       ├── test_inbox_query.py       # 收件箱查询
    │   │       ├── test_inbox_filter.py      # 收件箱筛选
    │   │       └── test_inbox_detail.py      # 消息详情
    │   │
    │   ├── accounts/                   # 账号管理API测试
    │   │   ├── __init__.py
    │   │   ├── test_account_crud.py    # 账号增删改查
    │   │   ├── test_account_list.py    # 账号列表查询
    │   │   └── test_account_settings.py # 账号配置
    │   │
    │   ├── channels/                   # 通道管理API测试
    │   │   ├── __init__.py
    │   │   ├── test_channel_crud.py    # 通道增删改查
    │   │   ├── test_channel_alert.py   # 通道告警配置
    │   │   └── test_channel_status.py  # 通道状态查询
    │   │
    │   └── management/                 # 其他管理功能API测试
    │       ├── __init__.py
    │       ├── test_country_regions.py # 国家区域管理
    │       ├── test_blacklist.py       # 黑名单管理
    │       ├── test_whitelist.py       # 白名单管理
    │       ├── test_sender_mgmt.py     # Sender管理
    │       └── test_pricing.py         # 价格管理
    │
    └── e2e/                            # 端到端测试
        ├── README.md                   # E2E测试文档
        ├── package.json                # Playwright及相关依赖
        ├── package-lock.json
        ├── playwright.config.ts        # Playwright配置
        ├── tsconfig.json               # TypeScript配置
        │
        ├── docker/                     # Docker环境配置
        │   ├── docker-compose.e2e.yml  # Docker编排文件
        │   ├── backend.Dockerfile      # 后端测试镜像
        │   ├── frontend.Dockerfile     # 前端测试镜像
        │   ├── nginx.conf              # Nginx配置
        │   └── init-db.sql             # E2E测试数据初始化
        │
        ├── fixtures/                   # E2E测试fixtures
        │   ├── auth.ts                 # 认证相关（登录状态管理）
        │   ├── test-data.ts            # 测试数据helpers
        │   └── cleanup.ts              # 测试清理工具
        │
        ├── pages/                      # Page Object Model
        │   ├── BasePage.ts             # 基础页面类
        │   ├── LoginPage.ts            # 登录页
        │   ├── DashboardPage.ts        # 首页
        │   ├── OutboxPage.ts           # 发件箱页
        │   ├── InboxPage.ts            # 收件箱页
        │   ├── AccountManagementPage.ts # 账号管理页
        │   └── ChannelManagementPage.ts # 通道管理页
        │
        └── tests/                      # E2E测试用例
            ├── smoke/                  # 冒烟测试（最关键的流程）
            │   ├── login.spec.ts       # 登录流程
            │   └── critical-path.spec.ts # 核心业务路径
            │
            ├── features/               # 功能测试
            │   ├── outbox/
            │   │   ├── filter.spec.ts  # 发件箱筛选
            │   │   ├── export.spec.ts  # 发件箱导出
            │   │   ├── detail.spec.ts  # 消息详情查看
            │   │   └── pagination.spec.ts # 分页
            │   ├── inbox/
            │   │   ├── query.spec.ts   # 收件箱查询
            │   │   └── filter.spec.ts  # 收件箱筛选
            │   └── management/
            │       ├── accounts.spec.ts # 账号管理
            │       └── channels.spec.ts # 通道管理
            │
            └── regression/             # 回归测试（记录历史bug）
                ├── issue-001-outbox-filter-bug.spec.ts
                └── issue-002-export-timeout.spec.ts
```

---

## 四、E2E测试环境隔离方案（重点）

### 4.1 问题：与开发环境的冲突

**开发环境**（日常启动，用于手工测试）：
```
前端: http://localhost:5173
后端: http://localhost:5000
数据库: localhost:8668/pigeon_sms
```

**E2E测试环境**（运行测试时启动）：
```
前端: http://localhost:5174  ← 不同端口
后端: http://localhost:5001  ← 不同端口
数据库: localhost:5433/pigeon_sms_e2e  ← 不同端口和数据库
```

### 4.2 解决方案：独立Docker环境

**核心思想**：E2E测试使用完全独立的Docker容器，与本地开发环境零冲突。

```yaml
# tests/e2e/docker/docker-compose.e2e.yml
version: '3.8'

services:
  # PostgreSQL测试数据库
  postgres-e2e:
    image: postgres:16
    container_name: pigeon-e2e-postgres
    environment:
      POSTGRES_USER: yuexin
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: pigeon_sms_e2e
    ports:
      - "5433:5432"  # 映射到不同的端口，避免冲突
    volumes:
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U yuexin"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - e2e-network

  # 后端API服务
  backend-e2e:
    build:
      context: ../../../pigeon_web
      dockerfile: ../tests/e2e/docker/backend.Dockerfile
    container_name: pigeon-e2e-backend
    environment:
      FLASK_ENV: e2e_testing
      DATABASE_URL: postgresql://yuexin:test_password@postgres-e2e:5432/pigeon_sms_e2e
      SECRET_KEY: e2e-test-secret-key
      JWT_SECRET_KEY: e2e-jwt-secret
    ports:
      - "5001:5000"
    depends_on:
      postgres-e2e:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/api/v1/health"]
      interval: 5s
      timeout: 5s
      retries: 10
    networks:
      - e2e-network

  # 前端服务（生产构建+Nginx）
  frontend-e2e:
    build:
      context: ../../../pigeon_web/frontend
      dockerfile: ../../../tests/e2e/docker/frontend.Dockerfile
    container_name: pigeon-e2e-frontend
    environment:
      VITE_API_BASE_URL: http://localhost:5001
    ports:
      - "5174:80"
    depends_on:
      backend-e2e:
        condition: service_healthy
    networks:
      - e2e-network

networks:
  e2e-network:
    name: pigeon-e2e-network
    driver: bridge
```

### 4.3 Dockerfile配置

```dockerfile
# tests/e2e/docker/backend.Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 复制并安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 添加健康检查端点（如果没有的话）
# HEALTHCHECK CMD curl -f http://localhost:5000/api/v1/health || exit 1

EXPOSE 5000

# 启动应用
CMD ["python", "run.py"]
```

```dockerfile
# tests/e2e/docker/frontend.Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# 复制package文件并安装依赖
COPY package*.json ./
RUN npm ci

# 复制源代码并构建
COPY . .
RUN npm run build

# 生产环境：使用Nginx提供静态文件
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制Nginx配置
COPY ../../../tests/e2e/docker/nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

```nginx
# tests/e2e/docker/nginx.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # 前端路由
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API代理（可选，如果前端直接调用backend-e2e容器）
    # location /api {
    #     proxy_pass http://backend-e2e:5000;
    #     proxy_set_header Host $host;
    #     proxy_set_header X-Real-IP $remote_addr;
    #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # }
}
```

### 4.4 测试数据初始化

```sql
-- tests/e2e/docker/init-db.sql
-- 1. 使用主数据库schema
\i /docker-entrypoint-initdb.d/../../pigeon_web/sql/pigeon_web.sql

-- 2. 插入E2E测试专用数据

-- 测试管理员账号
INSERT INTO admin_users (username, password_hash, email, is_active, created_at)
VALUES
  ('e2e_admin', '$2b$12$...', 'e2e_admin@test.com', true, NOW()),
  ('e2e_user', '$2b$12$...', 'e2e_user@test.com', true, NOW());

-- 测试客户账号
INSERT INTO customers_accounts (account_id, name, enabled, created_at)
VALUES
  ('E2E_ACC_001', 'E2E测试账号1', true, NOW()),
  ('E2E_ACC_002', 'E2E测试账号2', true, NOW());

-- 测试通道
INSERT INTO customers_channels (channel_id, channel_name, channel_type, enabled, created_at)
VALUES
  ('E2E_CH_001', 'E2E测试通道1', 'SMPP', true, NOW()),
  ('E2E_CH_002', 'E2E测试通道2', 'HTTP', true, NOW());

-- 测试短信数据（发件箱）
INSERT INTO short_messages (
  message_id, account_id, status, country_code, phone_number,
  content, sender, channel_id, send_time, created_at
)
VALUES
  ('E2E_MSG_GB_001', 'E2E_ACC_001', 'ChannelSendSuccess', 'GB', '447700900001',
   'Test message to UK 1', 'TestSender', 'E2E_CH_001', NOW(), NOW()),
  ('E2E_MSG_GB_002', 'E2E_ACC_001', 'ChannelSendSuccess', 'GB', '447700900002',
   'Test message to UK 2', 'TestSender', 'E2E_CH_001', NOW(), NOW()),
  ('E2E_MSG_US_001', 'E2E_ACC_001', 'ChannelSendSuccess', 'US', '12025550123',
   'Test message to US 1', 'TestSender', 'E2E_CH_002', NOW(), NOW()),
  ('E2E_MSG_US_002', 'E2E_ACC_001', 'ChannelSendFailed', 'US', '12025550124',
   'Test message to US 2 failed', 'TestSender', 'E2E_CH_002', NOW(), NOW());

-- 测试短信数据（收件箱）
INSERT INTO delivers (
  message_id, account_id, deliver_type, status, country_code,
  phone_number, content, receive_time, created_at
)
VALUES
  ('E2E_DELIVER_001', 'E2E_ACC_001', 'UplinkSMS', 'Processed', 'GB',
   '447700900001', 'Reply from UK user', NOW(), NOW()),
  ('E2E_DELIVER_002', 'E2E_ACC_001', 'Receipt', 'Processed', 'US',
   '12025550123', '', NOW(), NOW());
```

---

## 五、运行方式

### 5.1 日常开发工作流

```bash
# 1. 本地开发环境（一直运行）
# 启动数据库
cd pigeon/deployment/docker/middleware/postgresql
docker-compose up -d

# 启动后端
cd pigeon_web
source /Users/yukun-admin/projects/pigeon/venv/bin/activate
python run.py

# 启动前端
cd pigeon_web/frontend
npm run dev

# 浏览器访问 http://localhost:5173 进行手工测试
```

```bash
# 2. 快速验证后端逻辑（推荐）
cd pigeon/tests
pytest api/sms/test_outbox_filter.py -v

# 运行所有API测试
pytest api/ -v --cov

# 运行特定模块的API测试
pytest api/auth/ -v
pytest api/sms/ -v
```

```bash
# 3. 重大功能上线前，运行E2E测试（完全独立）
cd pigeon/tests
make e2e-test

# 或者分步执行
make e2e-up      # 启动E2E环境
# 浏览器访问 http://localhost:5174 手动验证
make e2e-test    # 运行测试
make e2e-down    # 清理环境
```

### 5.2 Makefile命令封装

```makefile
# tests/Makefile
.PHONY: help test-all test-unit test-api test-smoke test-e2e e2e-up e2e-down e2e-logs clean

# 默认显示帮助
help:
	@echo "pigeon_web 测试命令"
	@echo ""
	@echo "快速测试（日常开发）："
	@echo "  make test-api          - 运行API测试（推荐）"
	@echo "  make test-unit         - 运行单元测试"
	@echo ""
	@echo "E2E测试："
	@echo "  make test-smoke        - 运行冒烟测试（5-10分钟）"
	@echo "  make test-e2e          - 运行完整E2E测试（10-20分钟）"
	@echo "  make e2e-up            - 启动E2E环境（调试用）"
	@echo "  make e2e-down          - 停止E2E环境"
	@echo "  make e2e-logs          - 查看E2E日志"
	@echo ""
	@echo "完整测试："
	@echo "  make test-all          - 运行所有测试（CI用）"
	@echo "  make clean             - 清理测试产物"

# 运行所有测试（CI用）
test-all: test-unit test-api test-e2e
	@echo "✅ 所有测试通过"

# 单元测试
test-unit:
	@echo "🧪 运行单元测试..."
	pytest unit/ -v

# API测试（日常开发推荐）
test-api:
	@echo "🧪 运行API测试..."
	pytest api/ -v --cov=../pigeon_web/app --cov-report=html --cov-report=term-missing
	@echo "📊 覆盖率报告: tests/htmlcov/index.html"

# 冒烟测试（最快的E2E）
test-smoke: e2e-up
	@echo "🧪 运行冒烟测试..."
	cd e2e && npx playwright test --project=smoke
	@echo "📊 测试报告: tests/e2e/playwright-report/index.html"

# 完整E2E测试
test-e2e: e2e-up
	@echo "🧪 运行E2E测试..."
	cd e2e && npx playwright test
	@echo "📊 测试报告: tests/e2e/playwright-report/index.html"
	$(MAKE) e2e-down

# 启动E2E环境
e2e-up:
	@echo "🚀 启动E2E测试环境..."
	cd e2e/docker && docker-compose -f docker-compose.e2e.yml up -d --build
	@echo "⏳ 等待服务就绪（约30秒）..."
	@sleep 30
	@echo "✅ E2E环境已启动"
	@echo "   前端: http://localhost:5174"
	@echo "   后端: http://localhost:5001/api/v1/health"
	@echo "   数据库: localhost:5433/pigeon_sms_e2e"

# 停止E2E环境
e2e-down:
	@echo "🛑 停止E2E环境..."
	cd e2e/docker && docker-compose -f docker-compose.e2e.yml down -v
	@echo "✅ E2E环境已清理"

# 查看E2E日志
e2e-logs:
	@echo "📋 E2E环境日志："
	cd e2e/docker && docker-compose -f docker-compose.e2e.yml logs -f

# 清理测试产物
clean:
	@echo "🧹 清理测试产物..."
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	find . -type d -name "*.pyc" -delete 2>/dev/null || true
	find . -type d -name ".pytest_cache" -exec rm -rf {} + 2>/dev/null || true
	rm -rf htmlcov/ .coverage 2>/dev/null || true
	rm -rf e2e/playwright-report/ e2e/test-results/ 2>/dev/null || true
	@echo "✅ 清理完成"
```

### 5.3 常用测试命令

```bash
# ============ 日常开发 ============

# 快速验证某个API功能
pytest tests/api/sms/test_outbox_filter.py::test_filter_by_country -v

# 运行某个模块的所有API测试
pytest tests/api/sms/ -v

# 运行API测试并生成覆盖率报告
pytest tests/api/ --cov --cov-report=html

# ============ E2E测试 ============

# 运行某个E2E测试文件
cd tests/e2e
make e2e-up
npx playwright test tests/features/outbox/filter.spec.ts

# 调试E2E测试（带浏览器界面）
npx playwright test --debug

# 查看E2E测试报告
npx playwright show-report

# ============ CI ============

# CI环境运行所有测试
cd tests
make test-all
```

---

## 六、CI集成方案

### 6.1 GitHub Actions配置

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  # Job 1: API测试（快速反馈）
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: 安装依赖
        run: |
          cd pigeon_web
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: 运行API测试
        run: |
          cd tests
          pytest api/ -v --cov=../pigeon_web/app --cov-report=xml

      - name: 上传覆盖率报告
        uses: codecov/codecov-action@v3
        with:
          files: ./tests/coverage.xml
          flags: api-tests

  # Job 2: E2E测试（较慢，但保证质量）
  e2e-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Node.js环境
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: 安装Playwright
        run: |
          cd tests/e2e
          npm ci
          npx playwright install --with-deps chromium

      - name: 启动E2E环境
        run: |
          cd tests/e2e/docker
          docker-compose -f docker-compose.e2e.yml up -d --build
          sleep 30

      - name: 运行E2E测试
        run: |
          cd tests/e2e
          npx playwright test

      - name: 上传测试报告
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: tests/e2e/playwright-report/
          retention-days: 7

      - name: 清理E2E环境
        if: always()
        run: |
          cd tests/e2e/docker
          docker-compose -f docker-compose.e2e.yml down -v

  # Job 3: 单元测试（可选）
  unit-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout代码
        uses: actions/checkout@v3

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: 安装依赖
        run: |
          cd pigeon_web
          pip install -r requirements.txt
          pip install pytest

      - name: 运行单元测试
        run: |
          cd tests
          pytest unit/ -v
```

### 6.2 测试策略

```yaml
# 不同分支的测试策略
main分支（生产）:
  - 运行所有测试（unit + api + e2e）
  - 要求100%通过
  - 生成覆盖率报告

develop分支（开发）:
  - 运行API测试 + 冒烟E2E测试
  - 允许部分测试失败（标记为flaky）

feature分支（特性）:
  - 仅运行API测试
  - 快速反馈

PR（Pull Request）:
  - 运行API测试 + 相关的E2E测试
  - 要求通过才能合并
```

---

## 七、最佳实践

### 7.1 编写测试的原则

1. **测试要独立**：每个测试用例应该能够独立运行，不依赖其他测试的执行顺序
2. **测试要快速**：API测试应在秒级完成，E2E测试应控制在分钟级
3. **测试要稳定**：避免flaky tests（不稳定的测试），特别是E2E测试
4. **测试要清晰**：测试名称应清楚描述测试内容，遵循 `test_<功能>_<场景>_<预期结果>` 格式
5. **测试要聚焦**：每个测试只验证一个功能点，不要贪多

### 7.2 API测试最佳实践

```python
# ✅ 好的API测试示例
def test_filter_outbox_by_country_returns_only_specified_country_records(
    client, auth_headers, db_session
):
    """测试按国家筛选发件箱，应只返回指定国家的记录"""
    # Arrange: 准备测试数据
    MessageFactory.create(country_code='GB', account_id='TEST_001')
    MessageFactory.create(country_code='US', account_id='TEST_001')
    MessageFactory.create(country_code='GB', account_id='TEST_001')

    # Act: 执行操作
    response = client.get(
        '/api/v1/sms/outbox?country_codes=GB&start_time=2025-01-01&end_time=2025-12-31',
        headers=auth_headers
    )

    # Assert: 验证结果
    assert response.status_code == 200
    data = response.json
    assert data['success'] is True
    assert data['data']['pagination']['totalCount'] == 2

    for record in data['data']['records']:
        assert record['countryCode'] == 'GB'

# ❌ 不好的测试示例（测试内容不清晰，验证不充分）
def test_outbox(client, auth_headers):
    response = client.get('/api/v1/sms/outbox?country_codes=GB', headers=auth_headers)
    assert response.status_code == 200
```

**命名规范**：
- `test_<API端点>_<操作>_<场景>_<预期结果>`
- 示例：`test_outbox_filter_by_invalid_country_returns_400`

**Arrange-Act-Assert模式**：
```python
def test_example(client, auth_headers):
    # Arrange: 准备测试数据和环境
    user = UserFactory.create()

    # Act: 执行被测试的操作
    response = client.post('/api/v1/users', json={...}, headers=auth_headers)

    # Assert: 验证结果
    assert response.status_code == 201
    assert response.json['data']['username'] == user.username
```

### 7.3 E2E测试最佳实践

**使用Page Object Model**：
```typescript
// ✅ 好的E2E测试示例（使用POM）
test('用户可以按国家筛选发件箱', async ({ page }) => {
  // Arrange
  const loginPage = new LoginPage(page);
  const outboxPage = new OutboxPage(page);

  // Act
  await loginPage.login('e2e_user', 'password');
  await outboxPage.goto();
  await outboxPage.selectCountry('GB');
  await outboxPage.clickQuery();

  // Assert
  await expect(outboxPage.recordCount).toBeGreaterThan(0);
  await outboxPage.verifyAllRecordsHaveCountry('GB');
});

// ❌ 不好的E2E测试示例（直接操作DOM）
test('filter test', async ({ page }) => {
  await page.goto('/login');
  await page.fill('#username', 'user');
  await page.fill('#password', 'pass');
  await page.click('button');
  await page.goto('/messages/outbox');
  await page.click('.country-select');
  // ... 测试代码难以维护
});
```

**等待策略**：
```typescript
// ✅ 显式等待加载完成
await page.waitForSelector('.ant-spin-spinning', { state: 'hidden' });

// ✅ 等待网络请求完成
await page.waitForResponse(resp => resp.url().includes('/api/v1/sms/outbox'));

// ❌ 避免使用固定延迟
await page.waitForTimeout(3000); // 不好
```

**测试数据隔离**：
```typescript
// 每个测试使用独立的测试数据
test.beforeEach(async () => {
  // 使用唯一标识创建测试数据
  testAccountId = `E2E_${Date.now()}`;
});

test.afterEach(async () => {
  // 清理测试数据（如果需要）
  await cleanupTestData(testAccountId);
});
```

### 7.4 测试数据管理

**使用Factory模式生成测试数据**：
```python
# tests/shared/factories/message_factory.py
import factory
from app.models.sms.short_message import ShortMessage
from app.extensions import db

class MessageFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        model = ShortMessage
        sqlalchemy_session = db.session

    message_id = factory.Sequence(lambda n: f'TEST_MSG_{n:06d}')
    account_id = 'TEST_ACCOUNT_001'
    status = 'ChannelSendSuccess'
    country_code = 'GB'
    phone_number = factory.Sequence(lambda n: f'4477009{n:05d}')
    content = factory.Faker('text', max_nb_chars=160)
    sender = 'TestSender'
    channel_id = 'TEST_CHANNEL_001'
    send_time = factory.Faker('date_time_this_year')

# 使用
MessageFactory.create()  # 创建单个
MessageFactory.create_batch(10)  # 批量创建
MessageFactory.create(country_code='US')  # 覆盖默认值
```

### 7.5 避免的常见陷阱

**❌ 不要在测试中使用sleep**：
```python
# 不好
def test_something(client):
    client.post('/api/v1/start-job')
    time.sleep(5)  # 等待任务完成
    response = client.get('/api/v1/job-status')
    assert response.json['status'] == 'completed'

# 好
def test_something(client):
    client.post('/api/v1/start-job')
    # 使用轮询或事件机制
    wait_for_condition(lambda: client.get('/api/v1/job-status').json['status'] == 'completed')
```

**❌ 不要在测试间共享可变状态**：
```python
# 不好
global_test_data = {'user': None}

def test_create_user():
    global_test_data['user'] = create_user()

def test_update_user():  # 依赖上一个测试
    update_user(global_test_data['user'])

# 好
@pytest.fixture
def test_user(db_session):
    user = create_user()
    yield user
    # 清理由fixture自动处理

def test_update_user(test_user):
    update_user(test_user)
```

**❌ 不要过度mock**：
```python
# 不好（mock太多，测试失去意义）
@patch('app.services.sms_service.get_account')
@patch('app.services.sms_service.get_channel')
@patch('app.services.sms_service.query_database')
@patch('app.services.sms_service.format_response')
def test_outbox_query(mock1, mock2, mock3, mock4):
    # 这个测试几乎什么都没测

# 好（仅mock外部依赖）
def test_outbox_query(client, db_session):
    # 使用真实数据库（测试数据库），真实查询
    response = client.get('/api/v1/sms/outbox?...')
    # 验证真实的业务逻辑
```

---

## 八、团队协作规范

### 8.1 开发流程中的测试要求

**功能开发流程**：
1. 开发新功能时，先写API测试（TDD可选）
2. 实现功能代码
3. 本地运行API测试验证
4. 手工测试验证UI和用户体验
5. 提交代码前运行 `make test-api`
6. 提交PR，CI自动运行测试

**Bug修复流程**：
1. 先写一个失败的测试，复现bug
2. 修复代码，使测试通过
3. 将测试放入 `tests/e2e/tests/regression/` 目录
4. 测试文件命名：`issue-<编号>-<简短描述>.spec.ts`

### 8.2 代码提交检查清单

**提交前必须**：
- [ ] 本地运行 `make test-api` 通过
- [ ] 相关API测试已更新或新增
- [ ] 手工测试验证功能正常

**可选（重大功能）**：
- [ ] 运行 `make test-smoke` 通过
- [ ] 新增E2E测试覆盖新功能

**不要求**：
- ❌ 不要求每次提交都运行E2E测试（太慢）
- ❌ 不要求100%测试覆盖率（务实即可）

### 8.3 测试失败的处理

**API测试失败**：
- 立即修复（不允许提交失败的测试）
- 如果测试本身有问题，修复测试

**E2E测试失败**：
- 区分是真bug还是flaky test
- 如果是flaky test，标记 `test.fixme()` 或增加重试
- 如果是真bug，修复并更新测试

**处理flaky E2E测试**：
```typescript
// 临时跳过不稳定的测试
test.fixme('这个测试不稳定，需要优化', async ({ page }) => {
  // test code
});

// 或者增加重试次数
test.describe.configure({ retries: 2 });
```

### 8.4 测试代码的Code Review要求

**API测试Review要点**：
- [ ] 测试名称清晰描述测试内容
- [ ] 测试独立，不依赖其他测试
- [ ] 使用Factory创建测试数据，不hardcode
- [ ] 验证充分（不仅是200状态码，还要验证数据正确性）
- [ ] 遵循AAA模式（Arrange-Act-Assert）

**E2E测试Review要点**：
- [ ] 使用Page Object Model
- [ ] 避免使用sleep，使用显式等待
- [ ] 测试聚焦关键路径，不追求细节
- [ ] 失败时截图和trace清晰

---

## 九、迁移计划

### 9.1 第一阶段：基础搭建（1周）

**目标**：搭建测试框架，迁移现有测试

**任务**：
1. 创建 `tests/` 目录结构
2. 配置pytest和Playwright
3. 迁移现有的后端测试到新目录
4. 编写1-2个API测试示例
5. 编写1个E2E测试示例
6. 配置Makefile命令

**验收标准**：
- `make test-api` 可以运行
- `make test-e2e` 可以运行E2E环境

### 9.2 第二阶段：API测试覆盖（2-3周）

**目标**：覆盖核心API端点

**任务**：
1. 发件箱API测试（查询、筛选、分页、导出、详情）
2. 收件箱API测试（查询、筛选、详情）
3. 账号管理API测试（CRUD、列表）
4. 通道管理API测试（CRUD、告警、状态）
5. 认证API测试（登录、权限、Token）

**目标覆盖率**：70%+ API端点

### 9.3 第三阶段：E2E测试补充（1-2周）

**目标**：覆盖关键用户路径

**任务**：
1. 编写5-10个关键E2E测试
2. 配置Docker环境
3. 优化E2E测试稳定性
4. 配置CI集成

**关键场景**：
- 登录 → 查看发件箱 → 筛选 → 详情
- 登录 → 查看收件箱 → 导出
- 管理员 → 创建账号 → 配置通道
- 管理员 → 查看统计报表

### 9.4 第四阶段：持续优化（长期）

**目标**：维护和优化测试套件

**任务**：
1. 定期Review测试覆盖率
2. 清理过时的单元测试
3. 优化E2E测试速度
4. 处理flaky tests
5. 更新测试文档

---

## 十、附录

### 10.1 技术栈

**后端测试**：
- pytest 7.4+
- pytest-cov（覆盖率）
- factory_boy（测试数据工厂）
- SQLAlchemy（ORM）

**前端测试**：
- Playwright（E2E测试）
- vitest（单元测试，可选）

**基础设施**：
- Docker & Docker Compose
- PostgreSQL 16
- GitHub Actions

### 10.2 参考资料

- [Playwright官方文档](https://playwright.dev/)
- [pytest官方文档](https://docs.pytest.org/)
- [Testing Best Practices](https://martinfowler.com/testing/)
- [Page Object Model](https://playwright.dev/docs/pom)

### 10.3 常见问题FAQ

**Q1: 为什么要放弃大部分单元测试？**
A: 在AI辅助开发场景下，代码重构频繁，单元测试维护成本高。API测试和E2E测试验证行为而非实现，更稳定。

**Q2: E2E测试会不会很慢？**
A: 是的，但我们只运行关键的5-10个E2E测试，控制在10-20分钟内。日常开发主要依赖快速的API测试。

**Q3: 本地开发时必须运行E2E测试吗？**
A: 不需要。日常开发只需运行API测试（秒级）。E2E测试在重大功能上线前或CI环境运行。

**Q4: 测试环境会不会和开发环境冲突？**
A: 不会。E2E测试使用完全独立的Docker环境，不同的端口和数据库。

**Q5: API测试需要手动准备数据吗？**
A: 不需要。使用factory_boy自动生成测试数据，每个测试独立创建和清理。

**Q6: 如何处理flaky E2E测试？**
A:
1. 优化等待策略（避免sleep）
2. 增加重试次数
3. 如果仍不稳定，标记为 `test.fixme()` 并创建issue跟踪

**Q7: CI环境测试失败了怎么办？**
A:
1. 查看GitHub Actions的测试报告
2. 下载Playwright的截图和trace
3. 本地复现：`make e2e-up && cd tests/e2e && npx playwright test --debug`

---

## 十一、总结

本测试方案的核心理念：

1. **适应AI开发** - 减少脆弱的单元测试，增加稳定的行为测试
2. **务实高效** - 投入产出比高，60% API + 30% E2E + 10% Unit
3. **环境隔离** - E2E测试完全独立，不干扰日常开发
4. **快速反馈** - 日常依赖快速的API测试，CI保证完整质量
5. **持续优化** - 测试也是代码，需要不断维护和改进

**预期收益**：
- ✅ 代码质量有保障（API+E2E覆盖）
- ✅ 开发效率不受影响（测试环境隔离）
- ✅ 维护成本低（少量单元测试）
- ✅ CI快速反馈（API测试秒级，E2E分钟级）
- ✅ 团队信心提升（关键流程有E2E保障）

**下一步行动**：
1. 团队Review本文档，讨论并达成共识
2. 按照迁移计划逐步实施
3. 持续迭代优化测试策略

---

**文档版本历史**：
- v1.0 (2025-10-11): 初始版本，待团队Review
