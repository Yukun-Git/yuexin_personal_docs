# 飞书登录集成开发计划 - 第2阶段：核心飞书认证服务实现

## 📋 阶段概述

**目标**：实现完整的飞书认证服务，包括OAuth2流程、用户管理、令牌处理
**预估时间**：4-6天
**优先级**：高
**依赖**：第1阶段完成

## 🎯 阶段目标

- [x] 实现FeishuAuthService核心认证服务
- [x] 完成OAuth2授权码流程
- [x] 实现用户查找、创建和同步逻辑
- [x] 建立令牌管理和缓存策略
- [x] 创建飞书认证API接口
- [x] 编写完整的单元测试和集成测试

## 📝 详细任务清单

### 任务1：FeishuAuthService核心服务开发 (2天)

#### 1.1 创建基础服务架构
```python
# app/services/feishu/service/feishu_auth.py

import requests
import logging
from datetime import datetime, timedelta
from flask import current_app
from typing import Optional, Dict, Any, Tuple
from urllib.parse import urlencode

from app.extensions import cache, db
from app.models.user.admin import AdminUser
from app.models.feishu.config import FeishuAppConfig
from app.services.auth.service.auth import AuthService

logger = logging.getLogger(__name__)

class FeishuAPIException(Exception):
    """飞书API异常"""
    def __init__(self, message: str, code: int = None, response: dict = None):
        self.message = message
        self.code = code
        self.response = response
        super().__init__(message)

class FeishuAuthService:
    """飞书认证服务"""

    # 飞书API端点
    FEISHU_API_BASE = "https://open.feishu.cn/open-apis"

    # 缓存配置
    APP_TOKEN_CACHE_PREFIX = "feishu_app_token"
    USER_TOKEN_CACHE_PREFIX = "feishu_user_token"
    USER_INFO_CACHE_PREFIX = "feishu_user_info"

    @classmethod
    def get_authorization_url(cls, app_id: str, redirect_uri: str, state: str = None) -> str:
        """
        生成飞书授权URL

        Args:
            app_id: 飞书应用ID
            redirect_uri: 回调地址
            state: 状态参数，用于防CSRF攻击

        Returns:
            str: 授权URL
        """
        params = {
            'app_id': app_id,
            'redirect_uri': redirect_uri,
            'response_type': 'code',
            'scope': 'user:read'
        }

        if state:
            params['state'] = state

        query_string = urlencode(params)
        auth_url = f"https://open.feishu.cn/open-apis/authen/v1/index?{query_string}"

        logger.info(f"Generated authorization URL for app_id: {app_id}")
        return auth_url

    @classmethod
    def get_app_access_token(cls, app_id: str, app_secret: str) -> Optional[str]:
        """
        获取应用访问令牌

        Args:
            app_id: 应用ID
            app_secret: 应用密钥

        Returns:
            str: 应用访问令牌

        Raises:
            FeishuAPIException: API调用失败
        """
        # 先从缓存获取
        cache_key = f"{cls.APP_TOKEN_CACHE_PREFIX}_{app_id}"
        cached_token = cache.get(cache_key)

        if cached_token:
            logger.debug(f"Retrieved app token from cache for app_id: {app_id}")
            return cached_token

        # 请求新令牌
        url = f"{cls.FEISHU_API_BASE}/auth/v3/app_access_token/internal"
        data = {
            'app_id': app_id,
            'app_secret': app_secret
        }

        try:
            logger.info(f"Requesting app access token for app_id: {app_id}")
            response = requests.post(url, json=data, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                token = result.get('app_access_token')
                expire = result.get('expire', 7200)

                # 缓存令牌，提前5分钟过期
                cache_ttl = max(expire - 300, 60)  # 至少缓存1分钟
                cache.set(cache_key, token, timeout=cache_ttl)

                logger.info(f"Successfully obtained app access token for app_id: {app_id}")
                return token
            else:
                error_msg = f"Failed to get app access token: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when requesting app access token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when requesting app access token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)

    @classmethod
    def exchange_code_for_token(cls, app_id: str, app_secret: str, code: str) -> Optional[Dict[str, Any]]:
        """
        使用授权码换取用户访问令牌

        Args:
            app_id: 应用ID
            app_secret: 应用密钥
            code: 授权码

        Returns:
            dict: 用户令牌信息

        Raises:
            FeishuAPIException: API调用失败
        """
        # 获取应用访问令牌
        app_token = cls.get_app_access_token(app_id, app_secret)
        if not app_token:
            raise FeishuAPIException("Failed to get app access token")

        url = f"{cls.FEISHU_API_BASE}/authen/v1/access_token"
        headers = {
            'Authorization': f'Bearer {app_token}',
            'Content-Type': 'application/json'
        }
        data = {
            'grant_type': 'authorization_code',
            'code': code
        }

        try:
            logger.info(f"Exchanging authorization code for user token")
            response = requests.post(url, json=data, headers=headers, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                token_data = result.get('data')
                logger.info("Successfully exchanged code for user token")
                return token_data
            else:
                error_msg = f"Failed to exchange code for token: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when exchanging code for token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when exchanging code for token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)

    @classmethod
    def get_user_info(cls, access_token: str) -> Optional[Dict[str, Any]]:
        """
        获取用户信息

        Args:
            access_token: 用户访问令牌

        Returns:
            dict: 用户信息

        Raises:
            FeishuAPIException: API调用失败
        """
        # 先尝试从缓存获取
        cache_key = f"{cls.USER_INFO_CACHE_PREFIX}_{access_token[:16]}"  # 使用token前16位作为缓存key
        cached_info = cache.get(cache_key)

        if cached_info:
            logger.debug("Retrieved user info from cache")
            return cached_info

        url = f"{cls.FEISHU_API_BASE}/authen/v1/user_info"
        headers = {
            'Authorization': f'Bearer {access_token}'
        }

        try:
            logger.info("Requesting user info from Feishu")
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                user_info = result.get('data')

                # 缓存用户信息30分钟
                cache.set(cache_key, user_info, timeout=1800)

                logger.info(f"Successfully retrieved user info for user_id: {user_info.get('user_id')}")
                return user_info
            else:
                error_msg = f"Failed to get user info: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when requesting user info: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when requesting user info: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)

    @classmethod
    def refresh_user_token(cls, app_id: str, app_secret: str, refresh_token: str) -> Optional[Dict[str, Any]]:
        """
        刷新用户访问令牌

        Args:
            app_id: 应用ID
            app_secret: 应用密钥
            refresh_token: 刷新令牌

        Returns:
            dict: 新的令牌信息

        Raises:
            FeishuAPIException: API调用失败
        """
        # 获取应用访问令牌
        app_token = cls.get_app_access_token(app_id, app_secret)
        if not app_token:
            raise FeishuAPIException("Failed to get app access token")

        url = f"{cls.FEISHU_API_BASE}/authen/v1/refresh_access_token"
        headers = {
            'Authorization': f'Bearer {app_token}',
            'Content-Type': 'application/json'
        }
        data = {
            'grant_type': 'refresh_token',
            'refresh_token': refresh_token
        }

        try:
            logger.info("Refreshing user access token")
            response = requests.post(url, json=data, headers=headers, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                token_data = result.get('data')
                logger.info("Successfully refreshed user access token")
                return token_data
            else:
                error_msg = f"Failed to refresh token: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when refreshing token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when refreshing token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
```

#### 1.2 实现用户管理逻辑
```python
# app/services/feishu/service/user_management.py

from typing import Optional, List, Dict, Any
from datetime import datetime
from flask import current_app

from app.extensions import db
from app.models.user.admin import AdminUser, Role, UserRole
from app.models.feishu.config import FeishuAppConfig

logger = logging.getLogger(__name__)

class FeishuUserService:
    """飞书用户管理服务"""

    @staticmethod
    def find_user_by_feishu_id(feishu_user_id: str) -> Optional[AdminUser]:
        """
        通过飞书用户ID查找用户

        Args:
            feishu_user_id: 飞书用户ID

        Returns:
            AdminUser: 用户对象或None
        """
        if not feishu_user_id:
            return None

        return AdminUser.query.filter_by(feishu_user_id=feishu_user_id).first()

    @staticmethod
    def find_user_by_email(email: str) -> Optional[AdminUser]:
        """
        通过邮箱查找用户

        Args:
            email: 邮箱地址

        Returns:
            AdminUser: 用户对象或None
        """
        if not email:
            return None

        return AdminUser.query.filter_by(email=email).first()

    @staticmethod
    def link_feishu_to_existing_user(user: AdminUser, feishu_user_info: Dict[str, Any]) -> AdminUser:
        """
        将飞书信息关联到现有用户

        Args:
            user: 现有用户对象
            feishu_user_info: 飞书用户信息

        Returns:
            AdminUser: 更新后的用户对象
        """
        try:
            user.feishu_user_id = feishu_user_info.get('user_id')
            user.feishu_union_id = feishu_user_info.get('union_id')
            user.feishu_open_id = feishu_user_info.get('open_id')
            user.feishu_avatar_url = feishu_user_info.get('avatar_url')

            # 更新认证提供方
            if user.auth_provider == 'local':
                user.auth_provider = 'mixed'
            elif user.auth_provider == 'feishu':
                user.auth_provider = 'feishu'

            user.last_sync_at = datetime.utcnow()
            user.sync_enabled = True

            db.session.commit()
            logger.info(f"Successfully linked Feishu account to user: {user.username}")

            return user

        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to link Feishu account to user {user.username}: {str(e)}")
            raise

    @staticmethod
    def create_user_from_feishu(feishu_user_info: Dict[str, Any],
                               app_config: FeishuAppConfig) -> AdminUser:
        """
        从飞书信息创建用户

        Args:
            feishu_user_info: 飞书用户信息
            app_config: 应用配置

        Returns:
            AdminUser: 新创建的用户对象

        Raises:
            Exception: 创建失败
        """
        try:
            # 验证邮箱域名（如果配置了域名限制）
            email = feishu_user_info.get('email')
            if email and app_config.allowed_domains:
                domain = email.split('@')[1] if '@' in email else ''
                if domain not in app_config.allowed_domains:
                    raise ValueError(f"Email domain {domain} is not allowed")

            # 生成用户名
            username = FeishuUserService._generate_username(feishu_user_info)

            # 创建用户对象
            user = AdminUser(
                username=username,
                email=email or f"{username}@feishu.local",
                full_name=feishu_user_info.get('name', username),
                password_hash='',  # 飞书用户不需要密码
                is_active=True,
                feishu_user_id=feishu_user_info.get('user_id'),
                feishu_union_id=feishu_user_info.get('union_id'),
                feishu_open_id=feishu_user_info.get('open_id'),
                feishu_avatar_url=feishu_user_info.get('avatar_url'),
                auth_provider='feishu',
                last_sync_at=datetime.utcnow(),
                sync_enabled=True
            )

            db.session.add(user)
            db.session.flush()  # 获取用户ID

            # 分配默认角色
            if app_config.default_role_ids:
                FeishuUserService._assign_default_roles(user.id, app_config.default_role_ids)

            db.session.commit()
            logger.info(f"Successfully created user from Feishu: {username}")

            return user

        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to create user from Feishu: {str(e)}")
            raise

    @staticmethod
    def _generate_username(feishu_user_info: Dict[str, Any]) -> str:
        """
        生成唯一用户名

        Args:
            feishu_user_info: 飞书用户信息

        Returns:
            str: 唯一的用户名
        """
        email = feishu_user_info.get('email')
        name = feishu_user_info.get('name')
        user_id = feishu_user_info.get('user_id')

        # 优先使用邮箱前缀
        if email and '@' in email:
            base_username = email.split('@')[0]
        elif name:
            # 使用姓名，去除空格和特殊字符
            base_username = ''.join(c for c in name if c.isalnum())
        else:
            base_username = f"feishu_{user_id}"

        # 确保用户名唯一
        username = base_username
        counter = 1

        while AdminUser.query.filter_by(username=username).first():
            username = f"{base_username}_{counter}"
            counter += 1

        return username

    @staticmethod
    def _assign_default_roles(user_id: int, role_ids: List[int]):
        """
        分配默认角色

        Args:
            user_id: 用户ID
            role_ids: 角色ID列表
        """
        try:
            for role_id in role_ids:
                # 检查角色是否存在
                role = Role.query.get(role_id)
                if not role:
                    logger.warning(f"Role {role_id} not found, skipping assignment")
                    continue

                # 检查是否已分配
                existing_assignment = UserRole.query.filter_by(
                    user_id=user_id,
                    role_id=role_id
                ).first()

                if not existing_assignment:
                    user_role = UserRole(user_id=user_id, role_id=role_id)
                    db.session.add(user_role)

            logger.info(f"Assigned default roles {role_ids} to user {user_id}")

        except Exception as e:
            logger.error(f"Failed to assign default roles to user {user_id}: {str(e)}")
            raise

    @staticmethod
    def update_user_from_feishu(user: AdminUser, feishu_user_info: Dict[str, Any]) -> AdminUser:
        """
        从飞书信息更新用户

        Args:
            user: 用户对象
            feishu_user_info: 飞书用户信息

        Returns:
            AdminUser: 更新后的用户对象
        """
        try:
            # 只有启用同步的用户才更新信息
            if not user.sync_enabled:
                logger.debug(f"Sync disabled for user {user.username}, skipping update")
                return user

            # 更新基本信息
            if feishu_user_info.get('name'):
                user.full_name = feishu_user_info.get('name')

            # 更新头像
            if feishu_user_info.get('avatar_url'):
                user.feishu_avatar_url = feishu_user_info.get('avatar_url')

            # 更新邮箱（如果用户允许）
            if feishu_user_info.get('email') and not user.email.endswith('@feishu.local'):
                user.email = feishu_user_info.get('email')

            # 更新同步时间
            user.last_sync_at = datetime.utcnow()

            db.session.commit()
            logger.info(f"Successfully updated user {user.username} from Feishu")

            return user

        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to update user {user.username} from Feishu: {str(e)}")
            raise

    @staticmethod
    def find_or_create_user(feishu_user_info: Dict[str, Any],
                           app_config: FeishuAppConfig) -> Optional[AdminUser]:
        """
        查找或创建用户（主要业务逻辑）

        Args:
            feishu_user_info: 飞书用户信息
            app_config: 应用配置

        Returns:
            AdminUser: 用户对象或None
        """
        feishu_user_id = feishu_user_info.get('user_id')
        email = feishu_user_info.get('email')

        if not feishu_user_id:
            logger.error("Feishu user_id is required")
            return None

        # 1. 先通过飞书ID查找
        user = FeishuUserService.find_user_by_feishu_id(feishu_user_id)

        if user:
            logger.info(f"Found existing user by Feishu ID: {user.username}")
            return FeishuUserService.update_user_from_feishu(user, feishu_user_info)

        # 2. 通过邮箱查找并关联
        if email:
            user = FeishuUserService.find_user_by_email(email)
            if user:
                logger.info(f"Found existing user by email, linking Feishu account: {user.username}")
                return FeishuUserService.link_feishu_to_existing_user(user, feishu_user_info)

        # 3. 创建新用户（如果允许）
        if app_config.auto_create_user:
            logger.info("Creating new user from Feishu")
            return FeishuUserService.create_user_from_feishu(feishu_user_info, app_config)
        else:
            logger.warning(f"User not found and auto_create_user is disabled for Feishu user: {feishu_user_id}")
            return None
```

#### 1.3 实现令牌缓存管理
```python
# app/services/feishu/service/token_manager.py

import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from flask import current_app

from app.extensions import cache

logger = logging.getLogger(__name__)

class FeishuTokenManager:
    """飞书令牌管理器"""

    # 缓存前缀
    USER_TOKEN_PREFIX = "feishu_user_token"
    USER_SESSION_PREFIX = "feishu_user_session"

    @classmethod
    def cache_user_tokens(cls, user_id: int, app_id: str, token_data: Dict[str, Any]) -> bool:
        """
        缓存用户令牌

        Args:
            user_id: 用户ID
            app_id: 应用ID
            token_data: 令牌数据

        Returns:
            bool: 缓存是否成功
        """
        try:
            cache_key = f"{cls.USER_TOKEN_PREFIX}_{app_id}_{user_id}"

            cache_data = {
                'access_token': token_data.get('access_token'),
                'refresh_token': token_data.get('refresh_token'),
                'expires_in': token_data.get('expires_in'),
                'refresh_expires_in': token_data.get('refresh_expires_in'),
                'token_type': token_data.get('token_type', 'Bearer'),
                'scope': token_data.get('scope'),
                'cached_at': datetime.utcnow().isoformat()
            }

            # 缓存到访问令牌过期时间，提前1分钟
            timeout = max(token_data.get('expires_in', 7200) - 60, 60)

            success = cache.set(cache_key, json.dumps(cache_data), timeout=timeout)

            if success:
                logger.info(f"Successfully cached user tokens for user_id: {user_id}, app_id: {app_id}")
            else:
                logger.error(f"Failed to cache user tokens for user_id: {user_id}, app_id: {app_id}")

            return success

        except Exception as e:
            logger.error(f"Error caching user tokens: {str(e)}")
            return False

    @classmethod
    def get_user_tokens(cls, user_id: int, app_id: str) -> Optional[Dict[str, Any]]:
        """
        获取用户令牌

        Args:
            user_id: 用户ID
            app_id: 应用ID

        Returns:
            dict: 令牌数据或None
        """
        try:
            cache_key = f"{cls.USER_TOKEN_PREFIX}_{app_id}_{user_id}"
            cached_data = cache.get(cache_key)

            if cached_data:
                try:
                    token_data = json.loads(cached_data)
                    logger.debug(f"Retrieved user tokens from cache for user_id: {user_id}")
                    return token_data
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to decode cached token data: {str(e)}")
                    cls.clear_user_tokens(user_id, app_id)

            return None

        except Exception as e:
            logger.error(f"Error retrieving user tokens: {str(e)}")
            return None

    @classmethod
    def clear_user_tokens(cls, user_id: int, app_id: str) -> bool:
        """
        清除用户令牌缓存

        Args:
            user_id: 用户ID
            app_id: 应用ID

        Returns:
            bool: 清除是否成功
        """
        try:
            cache_key = f"{cls.USER_TOKEN_PREFIX}_{app_id}_{user_id}"
            success = cache.delete(cache_key)

            if success:
                logger.info(f"Successfully cleared user tokens for user_id: {user_id}, app_id: {app_id}")
            else:
                logger.warning(f"Failed to clear user tokens (may not exist) for user_id: {user_id}, app_id: {app_id}")

            return success

        except Exception as e:
            logger.error(f"Error clearing user tokens: {str(e)}")
            return False

    @classmethod
    def cache_user_session(cls, user_id: int, app_id: str, session_data: Dict[str, Any],
                          expires_in: int = 86400) -> bool:
        """
        缓存用户会话信息

        Args:
            user_id: 用户ID
            app_id: 应用ID
            session_data: 会话数据
            expires_in: 过期时间（秒）

        Returns:
            bool: 缓存是否成功
        """
        try:
            cache_key = f"{cls.USER_SESSION_PREFIX}_{app_id}_{user_id}"

            session_info = {
                'user_id': user_id,
                'app_id': app_id,
                'session_data': session_data,
                'created_at': datetime.utcnow().isoformat(),
                'expires_at': (datetime.utcnow() + timedelta(seconds=expires_in)).isoformat()
            }

            success = cache.set(cache_key, json.dumps(session_info), timeout=expires_in)

            if success:
                logger.debug(f"Successfully cached user session for user_id: {user_id}")
            else:
                logger.error(f"Failed to cache user session for user_id: {user_id}")

            return success

        except Exception as e:
            logger.error(f"Error caching user session: {str(e)}")
            return False

    @classmethod
    def get_user_session(cls, user_id: int, app_id: str) -> Optional[Dict[str, Any]]:
        """
        获取用户会话信息

        Args:
            user_id: 用户ID
            app_id: 应用ID

        Returns:
            dict: 会话数据或None
        """
        try:
            cache_key = f"{cls.USER_SESSION_PREFIX}_{app_id}_{user_id}"
            cached_data = cache.get(cache_key)

            if cached_data:
                try:
                    session_info = json.loads(cached_data)
                    logger.debug(f"Retrieved user session from cache for user_id: {user_id}")
                    return session_info
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to decode cached session data: {str(e)}")
                    cls.clear_user_session(user_id, app_id)

            return None

        except Exception as e:
            logger.error(f"Error retrieving user session: {str(e)}")
            return None

    @classmethod
    def clear_user_session(cls, user_id: int, app_id: str) -> bool:
        """
        清除用户会话缓存

        Args:
            user_id: 用户ID
            app_id: 应用ID

        Returns:
            bool: 清除是否成功
        """
        try:
            cache_key = f"{cls.USER_SESSION_PREFIX}_{app_id}_{user_id}"
            success = cache.delete(cache_key)

            if success:
                logger.debug(f"Successfully cleared user session for user_id: {user_id}")

            return success

        except Exception as e:
            logger.error(f"Error clearing user session: {str(e)}")
            return False

    @classmethod
    def is_token_expired(cls, token_data: Dict[str, Any]) -> bool:
        """
        检查令牌是否过期

        Args:
            token_data: 令牌数据

        Returns:
            bool: 是否过期
        """
        try:
            cached_at_str = token_data.get('cached_at')
            expires_in = token_data.get('expires_in', 7200)

            if not cached_at_str:
                return True

            cached_at = datetime.fromisoformat(cached_at_str)
            expires_at = cached_at + timedelta(seconds=expires_in)

            # 提前1分钟认为过期
            return datetime.utcnow() >= (expires_at - timedelta(minutes=1))

        except Exception as e:
            logger.error(f"Error checking token expiration: {str(e)}")
            return True
```

**✅ 阶段测试1：核心服务验证**
```python
# tests/feishu/unit/test_feishu_auth_service.py

import pytest
from unittest.mock import patch, Mock
from datetime import datetime, timedelta

from app.services.feishu.service.feishu_auth import FeishuAuthService, FeishuAPIException
from app.services.feishu.service.user_management import FeishuUserService
from app.services.feishu.service.token_manager import FeishuTokenManager

class TestFeishuAuthService:

    def test_get_authorization_url(self):
        """测试生成授权URL"""
        url = FeishuAuthService.get_authorization_url(
            'test_app_id',
            'http://localhost/callback',
            'test_state'
        )

        assert 'open.feishu.cn' in url
        assert 'test_app_id' in url
        assert 'localhost/callback' in url
        assert 'test_state' in url

    @patch('requests.post')
    def test_get_app_access_token_success(self, mock_post):
        """测试获取应用访问令牌成功"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'code': 0,
            'app_access_token': 'test_token',
            'expire': 7200
        }
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response

        with patch.object(FeishuAuthService, 'cache') as mock_cache:
            mock_cache.get.return_value = None
            mock_cache.set.return_value = True

            token = FeishuAuthService.get_app_access_token('app_id', 'app_secret')

            assert token == 'test_token'
            mock_post.assert_called_once()
            mock_cache.set.assert_called_once()

    @patch('requests.post')
    def test_get_app_access_token_failure(self, mock_post):
        """测试获取应用访问令牌失败"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'code': 99991661,
            'msg': 'app_id or app_secret is invalid'
        }
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response

        with pytest.raises(FeishuAPIException) as exc_info:
            FeishuAuthService.get_app_access_token('invalid_id', 'invalid_secret')

        assert 'app_id or app_secret is invalid' in str(exc_info.value)

    @patch('requests.post')
    def test_exchange_code_for_token_success(self, mock_post):
        """测试授权码换令牌成功"""
        # Mock获取应用令牌
        with patch.object(FeishuAuthService, 'get_app_access_token', return_value='app_token'):
            mock_response = Mock()
            mock_response.json.return_value = {
                'code': 0,
                'data': {
                    'access_token': 'user_token',
                    'refresh_token': 'refresh_token',
                    'expires_in': 7200
                }
            }
            mock_response.raise_for_status.return_value = None
            mock_post.return_value = mock_response

            result = FeishuAuthService.exchange_code_for_token('app_id', 'app_secret', 'auth_code')

            assert result['access_token'] == 'user_token'
            assert result['refresh_token'] == 'refresh_token'

    @patch('requests.get')
    def test_get_user_info_success(self, mock_get):
        """测试获取用户信息成功"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'code': 0,
            'data': {
                'user_id': 'test_user_123',
                'name': 'Test User',
                'email': 'test@example.com',
                'avatar_url': 'https://example.com/avatar.jpg'
            }
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response

        with patch.object(FeishuAuthService, 'cache') as mock_cache:
            mock_cache.get.return_value = None
            mock_cache.set.return_value = True

            result = FeishuAuthService.get_user_info('user_token')

            assert result['user_id'] == 'test_user_123'
            assert result['name'] == 'Test User'
            assert result['email'] == 'test@example.com'

class TestFeishuUserService:

    def test_generate_username(self):
        """测试用户名生成"""
        # 测试邮箱用户名
        feishu_info = {'email': 'test.user@company.com', 'name': 'Test User'}
        username = FeishuUserService._generate_username(feishu_info)
        assert username == 'test.user'

        # 测试姓名用户名
        feishu_info = {'name': 'Test User', 'user_id': '123'}
        username = FeishuUserService._generate_username(feishu_info)
        assert username == 'TestUser'

        # 测试用户ID用户名
        feishu_info = {'user_id': '123'}
        username = FeishuUserService._generate_username(feishu_info)
        assert username == 'feishu_123'

class TestFeishuTokenManager:

    def test_cache_user_tokens(self):
        """测试缓存用户令牌"""
        token_data = {
            'access_token': 'test_token',
            'refresh_token': 'refresh_token',
            'expires_in': 7200
        }

        with patch.object(FeishuTokenManager, 'cache') as mock_cache:
            mock_cache.set.return_value = True

            result = FeishuTokenManager.cache_user_tokens(1, 'app_123', token_data)

            assert result is True
            mock_cache.set.assert_called_once()

    def test_is_token_expired(self):
        """测试令牌过期检查"""
        # 测试未过期的令牌
        token_data = {
            'cached_at': datetime.utcnow().isoformat(),
            'expires_in': 7200
        }
        assert FeishuTokenManager.is_token_expired(token_data) is False

        # 测试过期的令牌
        past_time = datetime.utcnow() - timedelta(hours=3)
        token_data = {
            'cached_at': past_time.isoformat(),
            'expires_in': 7200
        }
        assert FeishuTokenManager.is_token_expired(token_data) is True
```

**验收标准**：
- [ ] FeishuAuthService所有方法实现完成
- [ ] FeishuUserService用户管理逻辑完成
- [ ] FeishuTokenManager令牌缓存功能完成
- [ ] 单元测试覆盖率达到90%以上
- [ ] 异常处理和日志记录完善

---

### 任务2：OAuth2完整流程集成 (1.5天)

#### 2.1 创建主认证服务
```python
# app/services/feishu/service/auth_integration.py

from typing import Optional, Dict, Any, Tuple
from flask import current_app, request

from app.extensions import db
from app.models.user.admin import AdminUser
from app.models.feishu.config import FeishuAppConfig
from app.services.auth.service.auth import AuthService
from app.services.feishu.service.feishu_auth import FeishuAuthService, FeishuAPIException
from app.services.feishu.service.user_management import FeishuUserService
from app.services.feishu.service.token_manager import FeishuTokenManager

logger = logging.getLogger(__name__)

class FeishuAuthIntegration:
    """飞书认证集成服务 - 主要业务逻辑"""

    @classmethod
    def authenticate_with_feishu(cls, code: str, app_name: str = 'default') -> Optional[Dict[str, Any]]:
        """
        飞书认证主流程

        Args:
            code: 授权码
            app_name: 应用名称

        Returns:
            dict: 认证结果，包含用户和令牌信息

        Raises:
            FeishuAPIException: API调用失败
            ValueError: 参数错误或配置错误
        """
        try:
            # 1. 获取应用配置
            app_config = cls._get_app_config(app_name)
            if not app_config:
                raise ValueError(f"Feishu app config '{app_name}' not found or inactive")

            # 2. 换取用户访问令牌
            logger.info(f"Starting Feishu authentication for app: {app_name}")
            token_data = FeishuAuthService.exchange_code_for_token(
                app_config.app_id,
                app_config.app_secret,
                code
            )

            if not token_data:
                raise FeishuAPIException("Failed to exchange authorization code for tokens")

            # 3. 获取用户信息
            user_info = FeishuAuthService.get_user_info(token_data['access_token'])
            if not user_info:
                raise FeishuAPIException("Failed to get user information")

            # 4. 验证用户合法性
            if not cls._validate_user_eligibility(user_info, app_config):
                raise ValueError("User is not eligible for this application")

            # 5. 查找或创建用户
            user = FeishuUserService.find_or_create_user(user_info, app_config)
            if not user or not user.is_active:
                raise ValueError("User not found or inactive")

            # 6. 生成系统JWT令牌
            system_tokens = AuthService.generate_tokens(user)

            # 7. 缓存飞书令牌
            FeishuTokenManager.cache_user_tokens(user.id, app_config.app_id, token_data)

            # 8. 更新登录信息
            cls._update_login_info(user)

            logger.info(f"Feishu authentication successful for user: {user.username}")

            return {
                'user': user,
                'system_tokens': system_tokens,
                'feishu_tokens': token_data,
                'feishu_user_info': user_info,
                'app_config': app_config.to_safe_dict()
            }

        except FeishuAPIException:
            # API异常直接抛出
            raise
        except Exception as e:
            logger.error(f"Feishu authentication failed: {str(e)}")
            # 包装其他异常
            raise FeishuAPIException(f"Authentication failed: {str(e)}")

    @classmethod
    def refresh_feishu_tokens(cls, user_id: int, app_name: str = 'default') -> Optional[str]:
        """
        刷新飞书令牌

        Args:
            user_id: 用户ID
            app_name: 应用名称

        Returns:
            str: 新的访问令牌或None
        """
        try:
            app_config = cls._get_app_config(app_name)
            if not app_config:
                logger.error(f"App config '{app_name}' not found")
                return None

            # 获取缓存的令牌
            cached_tokens = FeishuTokenManager.get_user_tokens(user_id, app_config.app_id)
            if not cached_tokens or not cached_tokens.get('refresh_token'):
                logger.warning(f"No cached refresh token found for user {user_id}")
                return None

            # 刷新令牌
            new_token_data = FeishuAuthService.refresh_user_token(
                app_config.app_id,
                app_config.app_secret,
                cached_tokens['refresh_token']
            )

            if new_token_data:
                # 更新缓存
                FeishuTokenManager.cache_user_tokens(user_id, app_config.app_id, new_token_data)
                logger.info(f"Successfully refreshed Feishu tokens for user {user_id}")
                return new_token_data.get('access_token')

            logger.warning(f"Failed to refresh Feishu tokens for user {user_id}")
            return None

        except Exception as e:
            logger.error(f"Error refreshing Feishu tokens for user {user_id}: {str(e)}")
            return None

    @classmethod
    def get_authorization_url(cls, app_name: str, redirect_uri: str, state: str = None) -> Optional[str]:
        """
        获取授权URL

        Args:
            app_name: 应用名称
            redirect_uri: 回调地址
            state: 状态参数

        Returns:
            str: 授权URL或None
        """
        try:
            app_config = cls._get_app_config(app_name)
            if not app_config:
                logger.error(f"App config '{app_name}' not found")
                return None

            return FeishuAuthService.get_authorization_url(
                app_config.app_id,
                redirect_uri,
                state
            )

        except Exception as e:
            logger.error(f"Error generating authorization URL: {str(e)}")
            return None

    @classmethod
    def validate_user_feishu_access(cls, user: AdminUser, app_name: str = 'default') -> bool:
        """
        验证用户飞书访问权限

        Args:
            user: 用户对象
            app_name: 应用名称

        Returns:
            bool: 是否有访问权限
        """
        try:
            # 检查用户是否支持飞书登录
            if not user.can_login_with_feishu():
                return False

            app_config = cls._get_app_config(app_name)
            if not app_config:
                return False

            # 检查域名限制
            if app_config.allowed_domains:
                user_domain = user.email.split('@')[1] if '@' in user.email else ''
                if user_domain not in app_config.allowed_domains:
                    logger.warning(f"User {user.username} domain {user_domain} not in allowed domains")
                    return False

            return True

        except Exception as e:
            logger.error(f"Error validating user Feishu access: {str(e)}")
            return False

    @classmethod
    def _get_app_config(cls, app_name: str) -> Optional[FeishuAppConfig]:
        """获取应用配置"""
        return FeishuAppConfig.query.filter_by(
            app_name=app_name,
            is_active=True
        ).first()

    @classmethod
    def _validate_user_eligibility(cls, user_info: Dict[str, Any],
                                 app_config: FeishuAppConfig) -> bool:
        """
        验证用户资格

        Args:
            user_info: 飞书用户信息
            app_config: 应用配置

        Returns:
            bool: 是否符合条件
        """
        try:
            email = user_info.get('email')

            # 检查邮箱域名限制
            if email and app_config.allowed_domains:
                domain = email.split('@')[1] if '@' in email else ''
                if domain not in app_config.allowed_domains:
                    logger.warning(f"User email domain {domain} not in allowed domains")
                    return False

            # 可以添加其他验证逻辑，比如：
            # - 特定用户ID白名单
            # - 用户状态检查
            # - 企业认证状态等

            return True

        except Exception as e:
            logger.error(f"Error validating user eligibility: {str(e)}")
            return False

    @classmethod
    def _update_login_info(cls, user: AdminUser):
        """更新用户登录信息"""
        try:
            user.update_login_info(request.remote_addr if request else None)
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to update login info for user {user.username}: {str(e)}")
```

#### 2.2 创建飞书认证API路由
```python
# app/api/v1/feishu_auth/route/routes.py

from flask import request, current_app, session, jsonify
from marshmallow import ValidationError, Schema, fields
import uuid

from app.api.v1.feishu_auth.route import bp
from app.services.feishu.service.auth_integration import FeishuAuthIntegration
from app.services.feishu.service.feishu_auth import FeishuAPIException
from app.utils.response import APIResponse
from app.api.v1.auth.schema.auth import TokenResponseSchema
from app.decorators.auth import login_required, permission_required

# 请求Schema定义
class AuthorizationRequestSchema(Schema):
    """授权请求Schema"""
    app_name = fields.Str(missing='default')
    redirect_uri = fields.Str(required=True)

class CallbackRequestSchema(Schema):
    """回调请求Schema"""
    code = fields.Str(required=True)
    state = fields.Str(required=True)

class TokenRefreshRequestSchema(Schema):
    """令牌刷新请求Schema"""
    user_id = fields.Int(missing=None)
    app_name = fields.Str(missing='default')

@bp.route('/authorize', methods=['GET'])
def get_authorization_url():
    """
    获取飞书授权URL

    Query Parameters:
        - app: 应用名称，默认'default'
        - redirect_uri: 回调地址（必需）

    Returns:
        JSON: 包含授权URL和state的响应
    """
    try:
        # 验证请求参数
        schema = AuthorizationRequestSchema()
        try:
            args = schema.load(request.args)
        except ValidationError as e:
            return APIResponse.error(message='参数验证失败', errors=e.messages, code=400)

        app_name = args['app_name']
        redirect_uri = args['redirect_uri']

        # 生成state参数防止CSRF攻击
        state = str(uuid.uuid4())
        session_key = f'feishu_state_{state}'

        # 在session中存储state信息
        session[session_key] = {
            'app_name': app_name,
            'redirect_uri': redirect_uri,
            'created_at': datetime.utcnow().isoformat()
        }

        # 生成授权URL
        auth_url = FeishuAuthIntegration.get_authorization_url(
            app_name,
            redirect_uri,
            state
        )

        if not auth_url:
            return APIResponse.error(message='飞书应用配置错误', code=400)

        logger.info(f"Generated authorization URL for app: {app_name}")

        return APIResponse.success(data={
            'authorization_url': auth_url,
            'state': state,
            'app_name': app_name
        }, message='授权URL生成成功')

    except Exception as e:
        logger.error(f"Failed to get authorization URL: {str(e)}")
        return APIResponse.error(message='获取授权URL失败', code=500)


@bp.route('/callback', methods=['POST'])
def feishu_callback():
    """
    飞书授权回调处理

    Request Body:
        - code: 授权码（必需）
        - state: 状态参数（必需）

    Returns:
        JSON: 包含访问令牌和用户信息的响应
    """
    try:
        # 验证请求数据
        schema = CallbackRequestSchema()
        try:
            data = schema.load(request.get_json() or {})
        except ValidationError as e:
            return APIResponse.error(message='参数验证失败', errors=e.messages, code=400)

        code = data['code']
        state = data['state']

        # 验证state参数
        session_key = f'feishu_state_{state}'
        state_data = session.pop(session_key, None)

        if not state_data:
            logger.warning(f"Invalid state parameter: {state}")
            return APIResponse.error(message='无效的状态参数', code=400)

        app_name = state_data['app_name']

        # 检查state有效期（10分钟）
        created_at = datetime.fromisoformat(state_data['created_at'])
        if datetime.utcnow() - created_at > timedelta(minutes=10):
            logger.warning(f"Expired state parameter: {state}")
            return APIResponse.error(message='状态参数已过期', code=400)

        logger.info(f"Processing Feishu callback for app: {app_name}")

        # 执行飞书认证
        auth_result = FeishuAuthIntegration.authenticate_with_feishu(code, app_name)

        if not auth_result:
            return APIResponse.error(message='飞书认证失败', code=401)

        user = auth_result['user']
        system_tokens = auth_result['system_tokens']

        # 序列化响应
        token_schema = TokenResponseSchema()
        response_data = token_schema.dump(system_tokens)

        # 添加用户信息
        response_data['user'] = user.to_dict_with_feishu()

        logger.info(f"Feishu authentication successful for user: {user.username}")

        return APIResponse.success(
            data=response_data,
            message='飞书登录成功'
        )

    except FeishuAPIException as e:
        logger.error(f"Feishu API error: {str(e)}")
        return APIResponse.error(message=f'飞书API错误: {e.message}', code=401)
    except ValueError as e:
        logger.error(f"Feishu authentication validation error: {str(e)}")
        return APIResponse.error(message=str(e), code=400)
    except Exception as e:
        logger.error(f"Feishu callback failed: {str(e)}")
        return APIResponse.error(message='飞书认证处理失败', code=500)


@bp.route('/refresh-tokens', methods=['POST'])
@login_required
def refresh_feishu_tokens(current_user):
    """
    刷新飞书令牌

    Request Body:
        - user_id: 用户ID（可选，默认当前用户）
        - app_name: 应用名称（可选，默认'default'）

    Returns:
        JSON: 刷新结果
    """
    try:
        # 验证请求数据
        schema = TokenRefreshRequestSchema()
        try:
            data = schema.load(request.get_json() or {})
        except ValidationError as e:
            return APIResponse.error(message='参数验证失败', errors=e.messages, code=400)

        user_id = data.get('user_id') or current_user.id
        app_name = data.get('app_name')

        # 权限检查：只有超级管理员可以刷新其他用户的令牌
        if user_id != current_user.id and not current_user.is_super_admin:
            return APIResponse.error(message='权限不足', code=403)

        # 刷新令牌
        new_access_token = FeishuAuthIntegration.refresh_feishu_tokens(user_id, app_name)

        if new_access_token:
            return APIResponse.success(
                data={'access_token': new_access_token},
                message='飞书令牌刷新成功'
            )
        else:
            return APIResponse.error(message='飞书令牌刷新失败', code=400)

    except Exception as e:
        logger.error(f"Failed to refresh Feishu tokens: {str(e)}")
        return APIResponse.error(message='令牌刷新处理失败', code=500)


@bp.route('/validate-access', methods=['POST'])
@login_required
def validate_feishu_access(current_user):
    """
    验证用户飞书访问权限

    Request Body:
        - app_name: 应用名称（可选，默认'default'）

    Returns:
        JSON: 验证结果
    """
    try:
        app_name = request.json.get('app_name', 'default') if request.json else 'default'

        has_access = FeishuAuthIntegration.validate_user_feishu_access(current_user, app_name)

        return APIResponse.success(data={
            'has_access': has_access,
            'can_login_with_feishu': current_user.can_login_with_feishu(),
            'auth_provider': current_user.auth_provider,
            'feishu_user_id': current_user.feishu_user_id
        }, message='权限验证完成')

    except Exception as e:
        logger.error(f"Failed to validate Feishu access: {str(e)}")
        return APIResponse.error(message='权限验证失败', code=500)


@bp.route('/sync-user', methods=['POST'])
@login_required
@permission_required(permission_code='admin_user_write')
def sync_user_from_feishu(current_user):
    """
    手动同步飞书用户信息

    Request Body:
        - user_id: 用户ID（可选，默认当前用户）
        - app_name: 应用名称（可选，默认'default'）

    Returns:
        JSON: 同步结果
    """
    try:
        data = request.get_json() or {}
        user_id = data.get('user_id') or current_user.id
        app_name = data.get('app_name', 'default')

        # 权限检查：只有超级管理员可以同步其他用户
        if user_id != current_user.id and not current_user.is_super_admin:
            return APIResponse.error(message='权限不足', code=403)

        # 获取目标用户
        from app.models.user.admin import AdminUser
        target_user = AdminUser.query.get(user_id)

        if not target_user or not target_user.feishu_user_id:
            return APIResponse.error(message='用户不存在或未关联飞书账号', code=404)

        # TODO: 实现用户信息同步逻辑
        # 这里可以调用飞书API获取最新用户信息并更新
        # 由于需要用户访问令牌，可能需要用户重新授权

        return APIResponse.success(message='用户同步功能开发中，请重新登录以更新信息')

    except Exception as e:
        logger.error(f"Failed to sync user from Feishu: {str(e)}")
        return APIResponse.error(message='用户同步失败', code=500)

# 健康检查接口
@bp.route('/health', methods=['GET'])
def health_check():
    """飞书认证服务健康检查"""
    try:
        # 检查应用配置
        from app.models.feishu.config import FeishuAppConfig
        config_count = FeishuAppConfig.query.filter_by(is_active=True).count()

        return APIResponse.success(data={
            'service': 'feishu-auth',
            'status': 'healthy',
            'active_configs': config_count,
            'timestamp': datetime.utcnow().isoformat()
        })
    except Exception as e:
        return APIResponse.error(message=f'服务不健康: {str(e)}', code=500)
```

#### 2.3 注册路由蓝图
```python
# app/api/v1/feishu_auth/route/__init__.py

from flask import Blueprint

# 创建飞书认证蓝图
bp = Blueprint('feishu_auth', __name__, url_prefix='/feishu-auth')

# 导入路由
from app.api.v1.feishu_auth.route import routes
```

```python
# app/api/v1/__init__.py - 添加到现有文件

from app.api.v1.feishu_auth.route import bp as feishu_auth_bp

def register_blueprints(app):
    """注册所有API蓝图"""
    # ... 现有蓝图注册 ...

    # 注册飞书认证蓝图
    app.register_blueprint(feishu_auth_bp, url_prefix='/api/v1')
```

**✅ 阶段测试2：OAuth2流程验证**
```python
# tests/feishu/integration/test_oauth2_flow.py

import pytest
from unittest.mock import patch, Mock
from flask import url_for

from app import create_app
from app.extensions import db
from app.models.feishu.config import FeishuAppConfig
from app.models.user.admin import AdminUser

@pytest.fixture
def app():
    app = create_app('testing')
    with app.app_context():
        db.create_all()

        # 创建测试飞书配置
        config = FeishuAppConfig(
            app_name='test',
            app_id='test_app_id',
            app_secret='test_app_secret',
            is_active=True,
            auto_create_user=True
        )
        db.session.add(config)
        db.session.commit()

        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

class TestFeishuOAuth2Flow:

    def test_get_authorization_url(self, client):
        """测试获取授权URL"""
        response = client.get('/api/v1/feishu-auth/authorize', query_string={
            'app': 'test',
            'redirect_uri': 'http://localhost/callback'
        })

        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert 'authorization_url' in data['data']
        assert 'state' in data['data']
        assert 'open.feishu.cn' in data['data']['authorization_url']

    def test_get_authorization_url_missing_redirect_uri(self, client):
        """测试缺少redirect_uri参数"""
        response = client.get('/api/v1/feishu-auth/authorize', query_string={
            'app': 'test'
        })

        assert response.status_code == 400
        data = response.get_json()
        assert data['success'] is False
        assert 'redirect_uri' in data['errors']

    @patch('app.services.feishu.service.auth_integration.FeishuAuthIntegration.authenticate_with_feishu')
    def test_feishu_callback_success(self, mock_auth, client):
        """测试飞书回调成功"""
        # 设置session state
        with client.session_transaction() as sess:
            sess['feishu_state_test123'] = {
                'app_name': 'test',
                'redirect_uri': 'http://localhost/callback',
                'created_at': '2025-09-19T10:00:00'
            }

        # Mock认证结果
        mock_user = AdminUser(
            id=1,
            username='test_user',
            email='test@company.com',
            full_name='Test User',
            auth_provider='feishu'
        )

        mock_auth.return_value = {
            'user': mock_user,
            'system_tokens': {
                'access_token': 'system_token',
                'refresh_token': 'refresh_token',
                'expires_in': 3600
            },
            'feishu_tokens': {
                'access_token': 'feishu_token',
                'refresh_token': 'feishu_refresh'
            },
            'feishu_user_info': {
                'user_id': 'feishu_123',
                'name': 'Test User'
            }
        }

        response = client.post('/api/v1/feishu-auth/callback', json={
            'code': 'test_code',
            'state': 'test123'
        })

        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert 'access_token' in data['data']
        assert 'user' in data['data']

    def test_feishu_callback_invalid_state(self, client):
        """测试无效state参数"""
        response = client.post('/api/v1/feishu-auth/callback', json={
            'code': 'test_code',
            'state': 'invalid_state'
        })

        assert response.status_code == 400
        data = response.get_json()
        assert data['success'] is False
        assert '无效的状态参数' in data['message']

    def test_health_check(self, client):
        """测试健康检查"""
        response = client.get('/api/v1/feishu-auth/health')

        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert data['data']['service'] == 'feishu-auth'
        assert data['data']['status'] == 'healthy'

# 集成测试脚本
def run_integration_test():
    """运行完整的OAuth2流程集成测试"""
    print("🧪 开始OAuth2流程集成测试...")

    # 1. 测试获取授权URL
    print("1. 测试获取授权URL...")
    # 实际调用本地API

    # 2. 手动授权（需要人工操作）
    print("2. 请手动完成飞书授权...")
    print("   - 复制上一步的授权URL")
    print("   - 在浏览器中打开并授权")
    print("   - 从回调URL中获取code参数")

    # 3. 测试回调处理
    code = input("请输入获取到的授权码: ")
    print(f"3. 测试回调处理，code: {code[:10]}...")
    # 实际调用回调API

    print("✅ OAuth2流程集成测试完成")

if __name__ == "__main__":
    run_integration_test()
```

**验收标准**：
- [ ] OAuth2完整流程实现
- [ ] API接口功能正常
- [ ] 错误处理和验证完善
- [ ] 集成测试通过
- [ ] 安全措施（CSRF防护、state验证）有效

---

## 🏁 第2阶段完成检查表

### 核心服务实现 ✅
- [ ] FeishuAuthService基础API调用完成
- [ ] FeishuUserService用户管理逻辑完成
- [ ] FeishuTokenManager令牌缓存功能完成
- [ ] 异常处理和日志记录完善

### OAuth2流程集成 ✅
- [ ] FeishuAuthIntegration主认证服务完成
- [ ] API路由和请求处理完成
- [ ] CSRF防护和安全验证实现
- [ ] 完整的错误处理机制

### 测试覆盖 ✅
- [ ] 单元测试覆盖率90%以上
- [ ] 集成测试场景覆盖完整
- [ ] Mock测试和真实API测试
- [ ] 错误场景测试完善

### 代码质量 ✅
- [ ] 代码规范符合项目标准
- [ ] 文档注释完整
- [ ] 日志记录详细
- [ ] 性能和安全考虑

## 🎯 第3阶段预告

**第3阶段：前端集成和用户体验**
- React登录组件开发
- 飞书回调页面实现
- 用户信息显示扩展
- 状态管理和路由集成
- 完整的前端测试

**预估时间**：3-4天
**主要产出**：完整的前端飞书登录用户体验

---

**第2阶段完成标志**：后端飞书认证服务完全可用，所有API接口测试通过，为前端集成做好准备。