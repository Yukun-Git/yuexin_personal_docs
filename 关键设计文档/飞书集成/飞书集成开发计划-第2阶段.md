# é£ä¹¦ç™»å½•é›†æˆå¼€å‘è®¡åˆ’ - ç¬¬2é˜¶æ®µï¼šæ ¸å¿ƒé£ä¹¦è®¤è¯æœåŠ¡å®ç°

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

**ç›®æ ‡**ï¼šå®ç°å®Œæ•´çš„é£ä¹¦è®¤è¯æœåŠ¡ï¼ŒåŒ…æ‹¬OAuth2æµç¨‹ã€ç”¨æˆ·ç®¡ç†ã€ä»¤ç‰Œå¤„ç†
**é¢„ä¼°æ—¶é—´**ï¼š4-6å¤©
**ä¼˜å…ˆçº§**ï¼šé«˜
**ä¾èµ–**ï¼šç¬¬1é˜¶æ®µå®Œæˆ

## ğŸ¯ é˜¶æ®µç›®æ ‡

- [x] å®ç°FeishuAuthServiceæ ¸å¿ƒè®¤è¯æœåŠ¡
- [x] å®ŒæˆOAuth2æˆæƒç æµç¨‹
- [x] å®ç°ç”¨æˆ·æŸ¥æ‰¾ã€åˆ›å»ºå’ŒåŒæ­¥é€»è¾‘
- [x] å»ºç«‹ä»¤ç‰Œç®¡ç†å’Œç¼“å­˜ç­–ç•¥
- [x] åˆ›å»ºé£ä¹¦è®¤è¯APIæ¥å£
- [x] ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

## ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

### ä»»åŠ¡1ï¼šFeishuAuthServiceæ ¸å¿ƒæœåŠ¡å¼€å‘ (2å¤©)

#### 1.1 åˆ›å»ºåŸºç¡€æœåŠ¡æ¶æ„
```python
# app/services/feishu/service/feishu_auth.py

import requests
import logging
from datetime import datetime, timedelta
from flask import current_app
from typing import Optional, Dict, Any, Tuple
from urllib.parse import urlencode

from app.extensions import cache, db
from app.models.user.admin import AdminUser
from app.models.feishu.config import FeishuAppConfig
from app.services.auth.service.auth import AuthService

logger = logging.getLogger(__name__)

class FeishuAPIException(Exception):
    """é£ä¹¦APIå¼‚å¸¸"""
    def __init__(self, message: str, code: int = None, response: dict = None):
        self.message = message
        self.code = code
        self.response = response
        super().__init__(message)

class FeishuAuthService:
    """é£ä¹¦è®¤è¯æœåŠ¡"""

    # é£ä¹¦APIç«¯ç‚¹
    FEISHU_API_BASE = "https://open.feishu.cn/open-apis"

    # ç¼“å­˜é…ç½®
    APP_TOKEN_CACHE_PREFIX = "feishu_app_token"
    USER_TOKEN_CACHE_PREFIX = "feishu_user_token"
    USER_INFO_CACHE_PREFIX = "feishu_user_info"

    @classmethod
    def get_authorization_url(cls, app_id: str, redirect_uri: str, state: str = None) -> str:
        """
        ç”Ÿæˆé£ä¹¦æˆæƒURL

        Args:
            app_id: é£ä¹¦åº”ç”¨ID
            redirect_uri: å›è°ƒåœ°å€
            state: çŠ¶æ€å‚æ•°ï¼Œç”¨äºé˜²CSRFæ”»å‡»

        Returns:
            str: æˆæƒURL
        """
        params = {
            'app_id': app_id,
            'redirect_uri': redirect_uri,
            'response_type': 'code',
            'scope': 'user:read'
        }

        if state:
            params['state'] = state

        query_string = urlencode(params)
        auth_url = f"https://open.feishu.cn/open-apis/authen/v1/index?{query_string}"

        logger.info(f"Generated authorization URL for app_id: {app_id}")
        return auth_url

    @classmethod
    def get_app_access_token(cls, app_id: str, app_secret: str) -> Optional[str]:
        """
        è·å–åº”ç”¨è®¿é—®ä»¤ç‰Œ

        Args:
            app_id: åº”ç”¨ID
            app_secret: åº”ç”¨å¯†é’¥

        Returns:
            str: åº”ç”¨è®¿é—®ä»¤ç‰Œ

        Raises:
            FeishuAPIException: APIè°ƒç”¨å¤±è´¥
        """
        # å…ˆä»ç¼“å­˜è·å–
        cache_key = f"{cls.APP_TOKEN_CACHE_PREFIX}_{app_id}"
        cached_token = cache.get(cache_key)

        if cached_token:
            logger.debug(f"Retrieved app token from cache for app_id: {app_id}")
            return cached_token

        # è¯·æ±‚æ–°ä»¤ç‰Œ
        url = f"{cls.FEISHU_API_BASE}/auth/v3/app_access_token/internal"
        data = {
            'app_id': app_id,
            'app_secret': app_secret
        }

        try:
            logger.info(f"Requesting app access token for app_id: {app_id}")
            response = requests.post(url, json=data, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                token = result.get('app_access_token')
                expire = result.get('expire', 7200)

                # ç¼“å­˜ä»¤ç‰Œï¼Œæå‰5åˆ†é’Ÿè¿‡æœŸ
                cache_ttl = max(expire - 300, 60)  # è‡³å°‘ç¼“å­˜1åˆ†é’Ÿ
                cache.set(cache_key, token, timeout=cache_ttl)

                logger.info(f"Successfully obtained app access token for app_id: {app_id}")
                return token
            else:
                error_msg = f"Failed to get app access token: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when requesting app access token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when requesting app access token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)

    @classmethod
    def exchange_code_for_token(cls, app_id: str, app_secret: str, code: str) -> Optional[Dict[str, Any]]:
        """
        ä½¿ç”¨æˆæƒç æ¢å–ç”¨æˆ·è®¿é—®ä»¤ç‰Œ

        Args:
            app_id: åº”ç”¨ID
            app_secret: åº”ç”¨å¯†é’¥
            code: æˆæƒç 

        Returns:
            dict: ç”¨æˆ·ä»¤ç‰Œä¿¡æ¯

        Raises:
            FeishuAPIException: APIè°ƒç”¨å¤±è´¥
        """
        # è·å–åº”ç”¨è®¿é—®ä»¤ç‰Œ
        app_token = cls.get_app_access_token(app_id, app_secret)
        if not app_token:
            raise FeishuAPIException("Failed to get app access token")

        url = f"{cls.FEISHU_API_BASE}/authen/v1/access_token"
        headers = {
            'Authorization': f'Bearer {app_token}',
            'Content-Type': 'application/json'
        }
        data = {
            'grant_type': 'authorization_code',
            'code': code
        }

        try:
            logger.info(f"Exchanging authorization code for user token")
            response = requests.post(url, json=data, headers=headers, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                token_data = result.get('data')
                logger.info("Successfully exchanged code for user token")
                return token_data
            else:
                error_msg = f"Failed to exchange code for token: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when exchanging code for token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when exchanging code for token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)

    @classmethod
    def get_user_info(cls, access_token: str) -> Optional[Dict[str, Any]]:
        """
        è·å–ç”¨æˆ·ä¿¡æ¯

        Args:
            access_token: ç”¨æˆ·è®¿é—®ä»¤ç‰Œ

        Returns:
            dict: ç”¨æˆ·ä¿¡æ¯

        Raises:
            FeishuAPIException: APIè°ƒç”¨å¤±è´¥
        """
        # å…ˆå°è¯•ä»ç¼“å­˜è·å–
        cache_key = f"{cls.USER_INFO_CACHE_PREFIX}_{access_token[:16]}"  # ä½¿ç”¨tokenå‰16ä½ä½œä¸ºç¼“å­˜key
        cached_info = cache.get(cache_key)

        if cached_info:
            logger.debug("Retrieved user info from cache")
            return cached_info

        url = f"{cls.FEISHU_API_BASE}/authen/v1/user_info"
        headers = {
            'Authorization': f'Bearer {access_token}'
        }

        try:
            logger.info("Requesting user info from Feishu")
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                user_info = result.get('data')

                # ç¼“å­˜ç”¨æˆ·ä¿¡æ¯30åˆ†é’Ÿ
                cache.set(cache_key, user_info, timeout=1800)

                logger.info(f"Successfully retrieved user info for user_id: {user_info.get('user_id')}")
                return user_info
            else:
                error_msg = f"Failed to get user info: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when requesting user info: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when requesting user info: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)

    @classmethod
    def refresh_user_token(cls, app_id: str, app_secret: str, refresh_token: str) -> Optional[Dict[str, Any]]:
        """
        åˆ·æ–°ç”¨æˆ·è®¿é—®ä»¤ç‰Œ

        Args:
            app_id: åº”ç”¨ID
            app_secret: åº”ç”¨å¯†é’¥
            refresh_token: åˆ·æ–°ä»¤ç‰Œ

        Returns:
            dict: æ–°çš„ä»¤ç‰Œä¿¡æ¯

        Raises:
            FeishuAPIException: APIè°ƒç”¨å¤±è´¥
        """
        # è·å–åº”ç”¨è®¿é—®ä»¤ç‰Œ
        app_token = cls.get_app_access_token(app_id, app_secret)
        if not app_token:
            raise FeishuAPIException("Failed to get app access token")

        url = f"{cls.FEISHU_API_BASE}/authen/v1/refresh_access_token"
        headers = {
            'Authorization': f'Bearer {app_token}',
            'Content-Type': 'application/json'
        }
        data = {
            'grant_type': 'refresh_token',
            'refresh_token': refresh_token
        }

        try:
            logger.info("Refreshing user access token")
            response = requests.post(url, json=data, headers=headers, timeout=10)
            response.raise_for_status()

            result = response.json()

            if result.get('code') == 0:
                token_data = result.get('data')
                logger.info("Successfully refreshed user access token")
                return token_data
            else:
                error_msg = f"Failed to refresh token: {result.get('msg', 'Unknown error')}"
                logger.error(error_msg)
                raise FeishuAPIException(error_msg, result.get('code'), result)

        except requests.RequestException as e:
            error_msg = f"Network error when refreshing token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error when refreshing token: {str(e)}"
            logger.error(error_msg)
            raise FeishuAPIException(error_msg)
```

#### 1.2 å®ç°ç”¨æˆ·ç®¡ç†é€»è¾‘
```python
# app/services/feishu/service/user_management.py

from typing import Optional, List, Dict, Any
from datetime import datetime
from flask import current_app

from app.extensions import db
from app.models.user.admin import AdminUser, Role, UserRole
from app.models.feishu.config import FeishuAppConfig

logger = logging.getLogger(__name__)

class FeishuUserService:
    """é£ä¹¦ç”¨æˆ·ç®¡ç†æœåŠ¡"""

    @staticmethod
    def find_user_by_feishu_id(feishu_user_id: str) -> Optional[AdminUser]:
        """
        é€šè¿‡é£ä¹¦ç”¨æˆ·IDæŸ¥æ‰¾ç”¨æˆ·

        Args:
            feishu_user_id: é£ä¹¦ç”¨æˆ·ID

        Returns:
            AdminUser: ç”¨æˆ·å¯¹è±¡æˆ–None
        """
        if not feishu_user_id:
            return None

        return AdminUser.query.filter_by(feishu_user_id=feishu_user_id).first()

    @staticmethod
    def find_user_by_email(email: str) -> Optional[AdminUser]:
        """
        é€šè¿‡é‚®ç®±æŸ¥æ‰¾ç”¨æˆ·

        Args:
            email: é‚®ç®±åœ°å€

        Returns:
            AdminUser: ç”¨æˆ·å¯¹è±¡æˆ–None
        """
        if not email:
            return None

        return AdminUser.query.filter_by(email=email).first()

    @staticmethod
    def link_feishu_to_existing_user(user: AdminUser, feishu_user_info: Dict[str, Any]) -> AdminUser:
        """
        å°†é£ä¹¦ä¿¡æ¯å…³è”åˆ°ç°æœ‰ç”¨æˆ·

        Args:
            user: ç°æœ‰ç”¨æˆ·å¯¹è±¡
            feishu_user_info: é£ä¹¦ç”¨æˆ·ä¿¡æ¯

        Returns:
            AdminUser: æ›´æ–°åçš„ç”¨æˆ·å¯¹è±¡
        """
        try:
            user.feishu_user_id = feishu_user_info.get('user_id')
            user.feishu_union_id = feishu_user_info.get('union_id')
            user.feishu_open_id = feishu_user_info.get('open_id')
            user.feishu_avatar_url = feishu_user_info.get('avatar_url')

            # æ›´æ–°è®¤è¯æä¾›æ–¹
            if user.auth_provider == 'local':
                user.auth_provider = 'mixed'
            elif user.auth_provider == 'feishu':
                user.auth_provider = 'feishu'

            user.last_sync_at = datetime.utcnow()
            user.sync_enabled = True

            db.session.commit()
            logger.info(f"Successfully linked Feishu account to user: {user.username}")

            return user

        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to link Feishu account to user {user.username}: {str(e)}")
            raise

    @staticmethod
    def create_user_from_feishu(feishu_user_info: Dict[str, Any],
                               app_config: FeishuAppConfig) -> AdminUser:
        """
        ä»é£ä¹¦ä¿¡æ¯åˆ›å»ºç”¨æˆ·

        Args:
            feishu_user_info: é£ä¹¦ç”¨æˆ·ä¿¡æ¯
            app_config: åº”ç”¨é…ç½®

        Returns:
            AdminUser: æ–°åˆ›å»ºçš„ç”¨æˆ·å¯¹è±¡

        Raises:
            Exception: åˆ›å»ºå¤±è´¥
        """
        try:
            # éªŒè¯é‚®ç®±åŸŸåï¼ˆå¦‚æœé…ç½®äº†åŸŸåé™åˆ¶ï¼‰
            email = feishu_user_info.get('email')
            if email and app_config.allowed_domains:
                domain = email.split('@')[1] if '@' in email else ''
                if domain not in app_config.allowed_domains:
                    raise ValueError(f"Email domain {domain} is not allowed")

            # ç”Ÿæˆç”¨æˆ·å
            username = FeishuUserService._generate_username(feishu_user_info)

            # åˆ›å»ºç”¨æˆ·å¯¹è±¡
            user = AdminUser(
                username=username,
                email=email or f"{username}@feishu.local",
                full_name=feishu_user_info.get('name', username),
                password_hash='',  # é£ä¹¦ç”¨æˆ·ä¸éœ€è¦å¯†ç 
                is_active=True,
                feishu_user_id=feishu_user_info.get('user_id'),
                feishu_union_id=feishu_user_info.get('union_id'),
                feishu_open_id=feishu_user_info.get('open_id'),
                feishu_avatar_url=feishu_user_info.get('avatar_url'),
                auth_provider='feishu',
                last_sync_at=datetime.utcnow(),
                sync_enabled=True
            )

            db.session.add(user)
            db.session.flush()  # è·å–ç”¨æˆ·ID

            # åˆ†é…é»˜è®¤è§’è‰²
            if app_config.default_role_ids:
                FeishuUserService._assign_default_roles(user.id, app_config.default_role_ids)

            db.session.commit()
            logger.info(f"Successfully created user from Feishu: {username}")

            return user

        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to create user from Feishu: {str(e)}")
            raise

    @staticmethod
    def _generate_username(feishu_user_info: Dict[str, Any]) -> str:
        """
        ç”Ÿæˆå”¯ä¸€ç”¨æˆ·å

        Args:
            feishu_user_info: é£ä¹¦ç”¨æˆ·ä¿¡æ¯

        Returns:
            str: å”¯ä¸€çš„ç”¨æˆ·å
        """
        email = feishu_user_info.get('email')
        name = feishu_user_info.get('name')
        user_id = feishu_user_info.get('user_id')

        # ä¼˜å…ˆä½¿ç”¨é‚®ç®±å‰ç¼€
        if email and '@' in email:
            base_username = email.split('@')[0]
        elif name:
            # ä½¿ç”¨å§“åï¼Œå»é™¤ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦
            base_username = ''.join(c for c in name if c.isalnum())
        else:
            base_username = f"feishu_{user_id}"

        # ç¡®ä¿ç”¨æˆ·åå”¯ä¸€
        username = base_username
        counter = 1

        while AdminUser.query.filter_by(username=username).first():
            username = f"{base_username}_{counter}"
            counter += 1

        return username

    @staticmethod
    def _assign_default_roles(user_id: int, role_ids: List[int]):
        """
        åˆ†é…é»˜è®¤è§’è‰²

        Args:
            user_id: ç”¨æˆ·ID
            role_ids: è§’è‰²IDåˆ—è¡¨
        """
        try:
            for role_id in role_ids:
                # æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
                role = Role.query.get(role_id)
                if not role:
                    logger.warning(f"Role {role_id} not found, skipping assignment")
                    continue

                # æ£€æŸ¥æ˜¯å¦å·²åˆ†é…
                existing_assignment = UserRole.query.filter_by(
                    user_id=user_id,
                    role_id=role_id
                ).first()

                if not existing_assignment:
                    user_role = UserRole(user_id=user_id, role_id=role_id)
                    db.session.add(user_role)

            logger.info(f"Assigned default roles {role_ids} to user {user_id}")

        except Exception as e:
            logger.error(f"Failed to assign default roles to user {user_id}: {str(e)}")
            raise

    @staticmethod
    def update_user_from_feishu(user: AdminUser, feishu_user_info: Dict[str, Any]) -> AdminUser:
        """
        ä»é£ä¹¦ä¿¡æ¯æ›´æ–°ç”¨æˆ·

        Args:
            user: ç”¨æˆ·å¯¹è±¡
            feishu_user_info: é£ä¹¦ç”¨æˆ·ä¿¡æ¯

        Returns:
            AdminUser: æ›´æ–°åçš„ç”¨æˆ·å¯¹è±¡
        """
        try:
            # åªæœ‰å¯ç”¨åŒæ­¥çš„ç”¨æˆ·æ‰æ›´æ–°ä¿¡æ¯
            if not user.sync_enabled:
                logger.debug(f"Sync disabled for user {user.username}, skipping update")
                return user

            # æ›´æ–°åŸºæœ¬ä¿¡æ¯
            if feishu_user_info.get('name'):
                user.full_name = feishu_user_info.get('name')

            # æ›´æ–°å¤´åƒ
            if feishu_user_info.get('avatar_url'):
                user.feishu_avatar_url = feishu_user_info.get('avatar_url')

            # æ›´æ–°é‚®ç®±ï¼ˆå¦‚æœç”¨æˆ·å…è®¸ï¼‰
            if feishu_user_info.get('email') and not user.email.endswith('@feishu.local'):
                user.email = feishu_user_info.get('email')

            # æ›´æ–°åŒæ­¥æ—¶é—´
            user.last_sync_at = datetime.utcnow()

            db.session.commit()
            logger.info(f"Successfully updated user {user.username} from Feishu")

            return user

        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to update user {user.username} from Feishu: {str(e)}")
            raise

    @staticmethod
    def find_or_create_user(feishu_user_info: Dict[str, Any],
                           app_config: FeishuAppConfig) -> Optional[AdminUser]:
        """
        æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·ï¼ˆä¸»è¦ä¸šåŠ¡é€»è¾‘ï¼‰

        Args:
            feishu_user_info: é£ä¹¦ç”¨æˆ·ä¿¡æ¯
            app_config: åº”ç”¨é…ç½®

        Returns:
            AdminUser: ç”¨æˆ·å¯¹è±¡æˆ–None
        """
        feishu_user_id = feishu_user_info.get('user_id')
        email = feishu_user_info.get('email')

        if not feishu_user_id:
            logger.error("Feishu user_id is required")
            return None

        # 1. å…ˆé€šè¿‡é£ä¹¦IDæŸ¥æ‰¾
        user = FeishuUserService.find_user_by_feishu_id(feishu_user_id)

        if user:
            logger.info(f"Found existing user by Feishu ID: {user.username}")
            return FeishuUserService.update_user_from_feishu(user, feishu_user_info)

        # 2. é€šè¿‡é‚®ç®±æŸ¥æ‰¾å¹¶å…³è”
        if email:
            user = FeishuUserService.find_user_by_email(email)
            if user:
                logger.info(f"Found existing user by email, linking Feishu account: {user.username}")
                return FeishuUserService.link_feishu_to_existing_user(user, feishu_user_info)

        # 3. åˆ›å»ºæ–°ç”¨æˆ·ï¼ˆå¦‚æœå…è®¸ï¼‰
        if app_config.auto_create_user:
            logger.info("Creating new user from Feishu")
            return FeishuUserService.create_user_from_feishu(feishu_user_info, app_config)
        else:
            logger.warning(f"User not found and auto_create_user is disabled for Feishu user: {feishu_user_id}")
            return None
```

#### 1.3 å®ç°ä»¤ç‰Œç¼“å­˜ç®¡ç†
```python
# app/services/feishu/service/token_manager.py

import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from flask import current_app

from app.extensions import cache

logger = logging.getLogger(__name__)

class FeishuTokenManager:
    """é£ä¹¦ä»¤ç‰Œç®¡ç†å™¨"""

    # ç¼“å­˜å‰ç¼€
    USER_TOKEN_PREFIX = "feishu_user_token"
    USER_SESSION_PREFIX = "feishu_user_session"

    @classmethod
    def cache_user_tokens(cls, user_id: int, app_id: str, token_data: Dict[str, Any]) -> bool:
        """
        ç¼“å­˜ç”¨æˆ·ä»¤ç‰Œ

        Args:
            user_id: ç”¨æˆ·ID
            app_id: åº”ç”¨ID
            token_data: ä»¤ç‰Œæ•°æ®

        Returns:
            bool: ç¼“å­˜æ˜¯å¦æˆåŠŸ
        """
        try:
            cache_key = f"{cls.USER_TOKEN_PREFIX}_{app_id}_{user_id}"

            cache_data = {
                'access_token': token_data.get('access_token'),
                'refresh_token': token_data.get('refresh_token'),
                'expires_in': token_data.get('expires_in'),
                'refresh_expires_in': token_data.get('refresh_expires_in'),
                'token_type': token_data.get('token_type', 'Bearer'),
                'scope': token_data.get('scope'),
                'cached_at': datetime.utcnow().isoformat()
            }

            # ç¼“å­˜åˆ°è®¿é—®ä»¤ç‰Œè¿‡æœŸæ—¶é—´ï¼Œæå‰1åˆ†é’Ÿ
            timeout = max(token_data.get('expires_in', 7200) - 60, 60)

            success = cache.set(cache_key, json.dumps(cache_data), timeout=timeout)

            if success:
                logger.info(f"Successfully cached user tokens for user_id: {user_id}, app_id: {app_id}")
            else:
                logger.error(f"Failed to cache user tokens for user_id: {user_id}, app_id: {app_id}")

            return success

        except Exception as e:
            logger.error(f"Error caching user tokens: {str(e)}")
            return False

    @classmethod
    def get_user_tokens(cls, user_id: int, app_id: str) -> Optional[Dict[str, Any]]:
        """
        è·å–ç”¨æˆ·ä»¤ç‰Œ

        Args:
            user_id: ç”¨æˆ·ID
            app_id: åº”ç”¨ID

        Returns:
            dict: ä»¤ç‰Œæ•°æ®æˆ–None
        """
        try:
            cache_key = f"{cls.USER_TOKEN_PREFIX}_{app_id}_{user_id}"
            cached_data = cache.get(cache_key)

            if cached_data:
                try:
                    token_data = json.loads(cached_data)
                    logger.debug(f"Retrieved user tokens from cache for user_id: {user_id}")
                    return token_data
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to decode cached token data: {str(e)}")
                    cls.clear_user_tokens(user_id, app_id)

            return None

        except Exception as e:
            logger.error(f"Error retrieving user tokens: {str(e)}")
            return None

    @classmethod
    def clear_user_tokens(cls, user_id: int, app_id: str) -> bool:
        """
        æ¸…é™¤ç”¨æˆ·ä»¤ç‰Œç¼“å­˜

        Args:
            user_id: ç”¨æˆ·ID
            app_id: åº”ç”¨ID

        Returns:
            bool: æ¸…é™¤æ˜¯å¦æˆåŠŸ
        """
        try:
            cache_key = f"{cls.USER_TOKEN_PREFIX}_{app_id}_{user_id}"
            success = cache.delete(cache_key)

            if success:
                logger.info(f"Successfully cleared user tokens for user_id: {user_id}, app_id: {app_id}")
            else:
                logger.warning(f"Failed to clear user tokens (may not exist) for user_id: {user_id}, app_id: {app_id}")

            return success

        except Exception as e:
            logger.error(f"Error clearing user tokens: {str(e)}")
            return False

    @classmethod
    def cache_user_session(cls, user_id: int, app_id: str, session_data: Dict[str, Any],
                          expires_in: int = 86400) -> bool:
        """
        ç¼“å­˜ç”¨æˆ·ä¼šè¯ä¿¡æ¯

        Args:
            user_id: ç”¨æˆ·ID
            app_id: åº”ç”¨ID
            session_data: ä¼šè¯æ•°æ®
            expires_in: è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰

        Returns:
            bool: ç¼“å­˜æ˜¯å¦æˆåŠŸ
        """
        try:
            cache_key = f"{cls.USER_SESSION_PREFIX}_{app_id}_{user_id}"

            session_info = {
                'user_id': user_id,
                'app_id': app_id,
                'session_data': session_data,
                'created_at': datetime.utcnow().isoformat(),
                'expires_at': (datetime.utcnow() + timedelta(seconds=expires_in)).isoformat()
            }

            success = cache.set(cache_key, json.dumps(session_info), timeout=expires_in)

            if success:
                logger.debug(f"Successfully cached user session for user_id: {user_id}")
            else:
                logger.error(f"Failed to cache user session for user_id: {user_id}")

            return success

        except Exception as e:
            logger.error(f"Error caching user session: {str(e)}")
            return False

    @classmethod
    def get_user_session(cls, user_id: int, app_id: str) -> Optional[Dict[str, Any]]:
        """
        è·å–ç”¨æˆ·ä¼šè¯ä¿¡æ¯

        Args:
            user_id: ç”¨æˆ·ID
            app_id: åº”ç”¨ID

        Returns:
            dict: ä¼šè¯æ•°æ®æˆ–None
        """
        try:
            cache_key = f"{cls.USER_SESSION_PREFIX}_{app_id}_{user_id}"
            cached_data = cache.get(cache_key)

            if cached_data:
                try:
                    session_info = json.loads(cached_data)
                    logger.debug(f"Retrieved user session from cache for user_id: {user_id}")
                    return session_info
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to decode cached session data: {str(e)}")
                    cls.clear_user_session(user_id, app_id)

            return None

        except Exception as e:
            logger.error(f"Error retrieving user session: {str(e)}")
            return None

    @classmethod
    def clear_user_session(cls, user_id: int, app_id: str) -> bool:
        """
        æ¸…é™¤ç”¨æˆ·ä¼šè¯ç¼“å­˜

        Args:
            user_id: ç”¨æˆ·ID
            app_id: åº”ç”¨ID

        Returns:
            bool: æ¸…é™¤æ˜¯å¦æˆåŠŸ
        """
        try:
            cache_key = f"{cls.USER_SESSION_PREFIX}_{app_id}_{user_id}"
            success = cache.delete(cache_key)

            if success:
                logger.debug(f"Successfully cleared user session for user_id: {user_id}")

            return success

        except Exception as e:
            logger.error(f"Error clearing user session: {str(e)}")
            return False

    @classmethod
    def is_token_expired(cls, token_data: Dict[str, Any]) -> bool:
        """
        æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœŸ

        Args:
            token_data: ä»¤ç‰Œæ•°æ®

        Returns:
            bool: æ˜¯å¦è¿‡æœŸ
        """
        try:
            cached_at_str = token_data.get('cached_at')
            expires_in = token_data.get('expires_in', 7200)

            if not cached_at_str:
                return True

            cached_at = datetime.fromisoformat(cached_at_str)
            expires_at = cached_at + timedelta(seconds=expires_in)

            # æå‰1åˆ†é’Ÿè®¤ä¸ºè¿‡æœŸ
            return datetime.utcnow() >= (expires_at - timedelta(minutes=1))

        except Exception as e:
            logger.error(f"Error checking token expiration: {str(e)}")
            return True
```

**âœ… é˜¶æ®µæµ‹è¯•1ï¼šæ ¸å¿ƒæœåŠ¡éªŒè¯**
```python
# tests/feishu/unit/test_feishu_auth_service.py

import pytest
from unittest.mock import patch, Mock
from datetime import datetime, timedelta

from app.services.feishu.service.feishu_auth import FeishuAuthService, FeishuAPIException
from app.services.feishu.service.user_management import FeishuUserService
from app.services.feishu.service.token_manager import FeishuTokenManager

class TestFeishuAuthService:

    def test_get_authorization_url(self):
        """æµ‹è¯•ç”ŸæˆæˆæƒURL"""
        url = FeishuAuthService.get_authorization_url(
            'test_app_id',
            'http://localhost/callback',
            'test_state'
        )

        assert 'open.feishu.cn' in url
        assert 'test_app_id' in url
        assert 'localhost/callback' in url
        assert 'test_state' in url

    @patch('requests.post')
    def test_get_app_access_token_success(self, mock_post):
        """æµ‹è¯•è·å–åº”ç”¨è®¿é—®ä»¤ç‰ŒæˆåŠŸ"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'code': 0,
            'app_access_token': 'test_token',
            'expire': 7200
        }
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response

        with patch.object(FeishuAuthService, 'cache') as mock_cache:
            mock_cache.get.return_value = None
            mock_cache.set.return_value = True

            token = FeishuAuthService.get_app_access_token('app_id', 'app_secret')

            assert token == 'test_token'
            mock_post.assert_called_once()
            mock_cache.set.assert_called_once()

    @patch('requests.post')
    def test_get_app_access_token_failure(self, mock_post):
        """æµ‹è¯•è·å–åº”ç”¨è®¿é—®ä»¤ç‰Œå¤±è´¥"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'code': 99991661,
            'msg': 'app_id or app_secret is invalid'
        }
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response

        with pytest.raises(FeishuAPIException) as exc_info:
            FeishuAuthService.get_app_access_token('invalid_id', 'invalid_secret')

        assert 'app_id or app_secret is invalid' in str(exc_info.value)

    @patch('requests.post')
    def test_exchange_code_for_token_success(self, mock_post):
        """æµ‹è¯•æˆæƒç æ¢ä»¤ç‰ŒæˆåŠŸ"""
        # Mockè·å–åº”ç”¨ä»¤ç‰Œ
        with patch.object(FeishuAuthService, 'get_app_access_token', return_value='app_token'):
            mock_response = Mock()
            mock_response.json.return_value = {
                'code': 0,
                'data': {
                    'access_token': 'user_token',
                    'refresh_token': 'refresh_token',
                    'expires_in': 7200
                }
            }
            mock_response.raise_for_status.return_value = None
            mock_post.return_value = mock_response

            result = FeishuAuthService.exchange_code_for_token('app_id', 'app_secret', 'auth_code')

            assert result['access_token'] == 'user_token'
            assert result['refresh_token'] == 'refresh_token'

    @patch('requests.get')
    def test_get_user_info_success(self, mock_get):
        """æµ‹è¯•è·å–ç”¨æˆ·ä¿¡æ¯æˆåŠŸ"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'code': 0,
            'data': {
                'user_id': 'test_user_123',
                'name': 'Test User',
                'email': 'test@example.com',
                'avatar_url': 'https://example.com/avatar.jpg'
            }
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response

        with patch.object(FeishuAuthService, 'cache') as mock_cache:
            mock_cache.get.return_value = None
            mock_cache.set.return_value = True

            result = FeishuAuthService.get_user_info('user_token')

            assert result['user_id'] == 'test_user_123'
            assert result['name'] == 'Test User'
            assert result['email'] == 'test@example.com'

class TestFeishuUserService:

    def test_generate_username(self):
        """æµ‹è¯•ç”¨æˆ·åç”Ÿæˆ"""
        # æµ‹è¯•é‚®ç®±ç”¨æˆ·å
        feishu_info = {'email': 'test.user@company.com', 'name': 'Test User'}
        username = FeishuUserService._generate_username(feishu_info)
        assert username == 'test.user'

        # æµ‹è¯•å§“åç”¨æˆ·å
        feishu_info = {'name': 'Test User', 'user_id': '123'}
        username = FeishuUserService._generate_username(feishu_info)
        assert username == 'TestUser'

        # æµ‹è¯•ç”¨æˆ·IDç”¨æˆ·å
        feishu_info = {'user_id': '123'}
        username = FeishuUserService._generate_username(feishu_info)
        assert username == 'feishu_123'

class TestFeishuTokenManager:

    def test_cache_user_tokens(self):
        """æµ‹è¯•ç¼“å­˜ç”¨æˆ·ä»¤ç‰Œ"""
        token_data = {
            'access_token': 'test_token',
            'refresh_token': 'refresh_token',
            'expires_in': 7200
        }

        with patch.object(FeishuTokenManager, 'cache') as mock_cache:
            mock_cache.set.return_value = True

            result = FeishuTokenManager.cache_user_tokens(1, 'app_123', token_data)

            assert result is True
            mock_cache.set.assert_called_once()

    def test_is_token_expired(self):
        """æµ‹è¯•ä»¤ç‰Œè¿‡æœŸæ£€æŸ¥"""
        # æµ‹è¯•æœªè¿‡æœŸçš„ä»¤ç‰Œ
        token_data = {
            'cached_at': datetime.utcnow().isoformat(),
            'expires_in': 7200
        }
        assert FeishuTokenManager.is_token_expired(token_data) is False

        # æµ‹è¯•è¿‡æœŸçš„ä»¤ç‰Œ
        past_time = datetime.utcnow() - timedelta(hours=3)
        token_data = {
            'cached_at': past_time.isoformat(),
            'expires_in': 7200
        }
        assert FeishuTokenManager.is_token_expired(token_data) is True
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] FeishuAuthServiceæ‰€æœ‰æ–¹æ³•å®ç°å®Œæˆ
- [ ] FeishuUserServiceç”¨æˆ·ç®¡ç†é€»è¾‘å®Œæˆ
- [ ] FeishuTokenManagerä»¤ç‰Œç¼“å­˜åŠŸèƒ½å®Œæˆ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°90%ä»¥ä¸Š
- [ ] å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•å®Œå–„

---

### ä»»åŠ¡2ï¼šOAuth2å®Œæ•´æµç¨‹é›†æˆ (1.5å¤©)

#### 2.1 åˆ›å»ºä¸»è®¤è¯æœåŠ¡
```python
# app/services/feishu/service/auth_integration.py

from typing import Optional, Dict, Any, Tuple
from flask import current_app, request

from app.extensions import db
from app.models.user.admin import AdminUser
from app.models.feishu.config import FeishuAppConfig
from app.services.auth.service.auth import AuthService
from app.services.feishu.service.feishu_auth import FeishuAuthService, FeishuAPIException
from app.services.feishu.service.user_management import FeishuUserService
from app.services.feishu.service.token_manager import FeishuTokenManager

logger = logging.getLogger(__name__)

class FeishuAuthIntegration:
    """é£ä¹¦è®¤è¯é›†æˆæœåŠ¡ - ä¸»è¦ä¸šåŠ¡é€»è¾‘"""

    @classmethod
    def authenticate_with_feishu(cls, code: str, app_name: str = 'default') -> Optional[Dict[str, Any]]:
        """
        é£ä¹¦è®¤è¯ä¸»æµç¨‹

        Args:
            code: æˆæƒç 
            app_name: åº”ç”¨åç§°

        Returns:
            dict: è®¤è¯ç»“æœï¼ŒåŒ…å«ç”¨æˆ·å’Œä»¤ç‰Œä¿¡æ¯

        Raises:
            FeishuAPIException: APIè°ƒç”¨å¤±è´¥
            ValueError: å‚æ•°é”™è¯¯æˆ–é…ç½®é”™è¯¯
        """
        try:
            # 1. è·å–åº”ç”¨é…ç½®
            app_config = cls._get_app_config(app_name)
            if not app_config:
                raise ValueError(f"Feishu app config '{app_name}' not found or inactive")

            # 2. æ¢å–ç”¨æˆ·è®¿é—®ä»¤ç‰Œ
            logger.info(f"Starting Feishu authentication for app: {app_name}")
            token_data = FeishuAuthService.exchange_code_for_token(
                app_config.app_id,
                app_config.app_secret,
                code
            )

            if not token_data:
                raise FeishuAPIException("Failed to exchange authorization code for tokens")

            # 3. è·å–ç”¨æˆ·ä¿¡æ¯
            user_info = FeishuAuthService.get_user_info(token_data['access_token'])
            if not user_info:
                raise FeishuAPIException("Failed to get user information")

            # 4. éªŒè¯ç”¨æˆ·åˆæ³•æ€§
            if not cls._validate_user_eligibility(user_info, app_config):
                raise ValueError("User is not eligible for this application")

            # 5. æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·
            user = FeishuUserService.find_or_create_user(user_info, app_config)
            if not user or not user.is_active:
                raise ValueError("User not found or inactive")

            # 6. ç”Ÿæˆç³»ç»ŸJWTä»¤ç‰Œ
            system_tokens = AuthService.generate_tokens(user)

            # 7. ç¼“å­˜é£ä¹¦ä»¤ç‰Œ
            FeishuTokenManager.cache_user_tokens(user.id, app_config.app_id, token_data)

            # 8. æ›´æ–°ç™»å½•ä¿¡æ¯
            cls._update_login_info(user)

            logger.info(f"Feishu authentication successful for user: {user.username}")

            return {
                'user': user,
                'system_tokens': system_tokens,
                'feishu_tokens': token_data,
                'feishu_user_info': user_info,
                'app_config': app_config.to_safe_dict()
            }

        except FeishuAPIException:
            # APIå¼‚å¸¸ç›´æ¥æŠ›å‡º
            raise
        except Exception as e:
            logger.error(f"Feishu authentication failed: {str(e)}")
            # åŒ…è£…å…¶ä»–å¼‚å¸¸
            raise FeishuAPIException(f"Authentication failed: {str(e)}")

    @classmethod
    def refresh_feishu_tokens(cls, user_id: int, app_name: str = 'default') -> Optional[str]:
        """
        åˆ·æ–°é£ä¹¦ä»¤ç‰Œ

        Args:
            user_id: ç”¨æˆ·ID
            app_name: åº”ç”¨åç§°

        Returns:
            str: æ–°çš„è®¿é—®ä»¤ç‰Œæˆ–None
        """
        try:
            app_config = cls._get_app_config(app_name)
            if not app_config:
                logger.error(f"App config '{app_name}' not found")
                return None

            # è·å–ç¼“å­˜çš„ä»¤ç‰Œ
            cached_tokens = FeishuTokenManager.get_user_tokens(user_id, app_config.app_id)
            if not cached_tokens or not cached_tokens.get('refresh_token'):
                logger.warning(f"No cached refresh token found for user {user_id}")
                return None

            # åˆ·æ–°ä»¤ç‰Œ
            new_token_data = FeishuAuthService.refresh_user_token(
                app_config.app_id,
                app_config.app_secret,
                cached_tokens['refresh_token']
            )

            if new_token_data:
                # æ›´æ–°ç¼“å­˜
                FeishuTokenManager.cache_user_tokens(user_id, app_config.app_id, new_token_data)
                logger.info(f"Successfully refreshed Feishu tokens for user {user_id}")
                return new_token_data.get('access_token')

            logger.warning(f"Failed to refresh Feishu tokens for user {user_id}")
            return None

        except Exception as e:
            logger.error(f"Error refreshing Feishu tokens for user {user_id}: {str(e)}")
            return None

    @classmethod
    def get_authorization_url(cls, app_name: str, redirect_uri: str, state: str = None) -> Optional[str]:
        """
        è·å–æˆæƒURL

        Args:
            app_name: åº”ç”¨åç§°
            redirect_uri: å›è°ƒåœ°å€
            state: çŠ¶æ€å‚æ•°

        Returns:
            str: æˆæƒURLæˆ–None
        """
        try:
            app_config = cls._get_app_config(app_name)
            if not app_config:
                logger.error(f"App config '{app_name}' not found")
                return None

            return FeishuAuthService.get_authorization_url(
                app_config.app_id,
                redirect_uri,
                state
            )

        except Exception as e:
            logger.error(f"Error generating authorization URL: {str(e)}")
            return None

    @classmethod
    def validate_user_feishu_access(cls, user: AdminUser, app_name: str = 'default') -> bool:
        """
        éªŒè¯ç”¨æˆ·é£ä¹¦è®¿é—®æƒé™

        Args:
            user: ç”¨æˆ·å¯¹è±¡
            app_name: åº”ç”¨åç§°

        Returns:
            bool: æ˜¯å¦æœ‰è®¿é—®æƒé™
        """
        try:
            # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ”¯æŒé£ä¹¦ç™»å½•
            if not user.can_login_with_feishu():
                return False

            app_config = cls._get_app_config(app_name)
            if not app_config:
                return False

            # æ£€æŸ¥åŸŸåé™åˆ¶
            if app_config.allowed_domains:
                user_domain = user.email.split('@')[1] if '@' in user.email else ''
                if user_domain not in app_config.allowed_domains:
                    logger.warning(f"User {user.username} domain {user_domain} not in allowed domains")
                    return False

            return True

        except Exception as e:
            logger.error(f"Error validating user Feishu access: {str(e)}")
            return False

    @classmethod
    def _get_app_config(cls, app_name: str) -> Optional[FeishuAppConfig]:
        """è·å–åº”ç”¨é…ç½®"""
        return FeishuAppConfig.query.filter_by(
            app_name=app_name,
            is_active=True
        ).first()

    @classmethod
    def _validate_user_eligibility(cls, user_info: Dict[str, Any],
                                 app_config: FeishuAppConfig) -> bool:
        """
        éªŒè¯ç”¨æˆ·èµ„æ ¼

        Args:
            user_info: é£ä¹¦ç”¨æˆ·ä¿¡æ¯
            app_config: åº”ç”¨é…ç½®

        Returns:
            bool: æ˜¯å¦ç¬¦åˆæ¡ä»¶
        """
        try:
            email = user_info.get('email')

            # æ£€æŸ¥é‚®ç®±åŸŸåé™åˆ¶
            if email and app_config.allowed_domains:
                domain = email.split('@')[1] if '@' in email else ''
                if domain not in app_config.allowed_domains:
                    logger.warning(f"User email domain {domain} not in allowed domains")
                    return False

            # å¯ä»¥æ·»åŠ å…¶ä»–éªŒè¯é€»è¾‘ï¼Œæ¯”å¦‚ï¼š
            # - ç‰¹å®šç”¨æˆ·IDç™½åå•
            # - ç”¨æˆ·çŠ¶æ€æ£€æŸ¥
            # - ä¼ä¸šè®¤è¯çŠ¶æ€ç­‰

            return True

        except Exception as e:
            logger.error(f"Error validating user eligibility: {str(e)}")
            return False

    @classmethod
    def _update_login_info(cls, user: AdminUser):
        """æ›´æ–°ç”¨æˆ·ç™»å½•ä¿¡æ¯"""
        try:
            user.update_login_info(request.remote_addr if request else None)
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to update login info for user {user.username}: {str(e)}")
```

#### 2.2 åˆ›å»ºé£ä¹¦è®¤è¯APIè·¯ç”±
```python
# app/api/v1/feishu_auth/route/routes.py

from flask import request, current_app, session, jsonify
from marshmallow import ValidationError, Schema, fields
import uuid

from app.api.v1.feishu_auth.route import bp
from app.services.feishu.service.auth_integration import FeishuAuthIntegration
from app.services.feishu.service.feishu_auth import FeishuAPIException
from app.utils.response import APIResponse
from app.api.v1.auth.schema.auth import TokenResponseSchema
from app.decorators.auth import login_required, permission_required

# è¯·æ±‚Schemaå®šä¹‰
class AuthorizationRequestSchema(Schema):
    """æˆæƒè¯·æ±‚Schema"""
    app_name = fields.Str(missing='default')
    redirect_uri = fields.Str(required=True)

class CallbackRequestSchema(Schema):
    """å›è°ƒè¯·æ±‚Schema"""
    code = fields.Str(required=True)
    state = fields.Str(required=True)

class TokenRefreshRequestSchema(Schema):
    """ä»¤ç‰Œåˆ·æ–°è¯·æ±‚Schema"""
    user_id = fields.Int(missing=None)
    app_name = fields.Str(missing='default')

@bp.route('/authorize', methods=['GET'])
def get_authorization_url():
    """
    è·å–é£ä¹¦æˆæƒURL

    Query Parameters:
        - app: åº”ç”¨åç§°ï¼Œé»˜è®¤'default'
        - redirect_uri: å›è°ƒåœ°å€ï¼ˆå¿…éœ€ï¼‰

    Returns:
        JSON: åŒ…å«æˆæƒURLå’Œstateçš„å“åº”
    """
    try:
        # éªŒè¯è¯·æ±‚å‚æ•°
        schema = AuthorizationRequestSchema()
        try:
            args = schema.load(request.args)
        except ValidationError as e:
            return APIResponse.error(message='å‚æ•°éªŒè¯å¤±è´¥', errors=e.messages, code=400)

        app_name = args['app_name']
        redirect_uri = args['redirect_uri']

        # ç”Ÿæˆstateå‚æ•°é˜²æ­¢CSRFæ”»å‡»
        state = str(uuid.uuid4())
        session_key = f'feishu_state_{state}'

        # åœ¨sessionä¸­å­˜å‚¨stateä¿¡æ¯
        session[session_key] = {
            'app_name': app_name,
            'redirect_uri': redirect_uri,
            'created_at': datetime.utcnow().isoformat()
        }

        # ç”ŸæˆæˆæƒURL
        auth_url = FeishuAuthIntegration.get_authorization_url(
            app_name,
            redirect_uri,
            state
        )

        if not auth_url:
            return APIResponse.error(message='é£ä¹¦åº”ç”¨é…ç½®é”™è¯¯', code=400)

        logger.info(f"Generated authorization URL for app: {app_name}")

        return APIResponse.success(data={
            'authorization_url': auth_url,
            'state': state,
            'app_name': app_name
        }, message='æˆæƒURLç”ŸæˆæˆåŠŸ')

    except Exception as e:
        logger.error(f"Failed to get authorization URL: {str(e)}")
        return APIResponse.error(message='è·å–æˆæƒURLå¤±è´¥', code=500)


@bp.route('/callback', methods=['POST'])
def feishu_callback():
    """
    é£ä¹¦æˆæƒå›è°ƒå¤„ç†

    Request Body:
        - code: æˆæƒç ï¼ˆå¿…éœ€ï¼‰
        - state: çŠ¶æ€å‚æ•°ï¼ˆå¿…éœ€ï¼‰

    Returns:
        JSON: åŒ…å«è®¿é—®ä»¤ç‰Œå’Œç”¨æˆ·ä¿¡æ¯çš„å“åº”
    """
    try:
        # éªŒè¯è¯·æ±‚æ•°æ®
        schema = CallbackRequestSchema()
        try:
            data = schema.load(request.get_json() or {})
        except ValidationError as e:
            return APIResponse.error(message='å‚æ•°éªŒè¯å¤±è´¥', errors=e.messages, code=400)

        code = data['code']
        state = data['state']

        # éªŒè¯stateå‚æ•°
        session_key = f'feishu_state_{state}'
        state_data = session.pop(session_key, None)

        if not state_data:
            logger.warning(f"Invalid state parameter: {state}")
            return APIResponse.error(message='æ— æ•ˆçš„çŠ¶æ€å‚æ•°', code=400)

        app_name = state_data['app_name']

        # æ£€æŸ¥stateæœ‰æ•ˆæœŸï¼ˆ10åˆ†é’Ÿï¼‰
        created_at = datetime.fromisoformat(state_data['created_at'])
        if datetime.utcnow() - created_at > timedelta(minutes=10):
            logger.warning(f"Expired state parameter: {state}")
            return APIResponse.error(message='çŠ¶æ€å‚æ•°å·²è¿‡æœŸ', code=400)

        logger.info(f"Processing Feishu callback for app: {app_name}")

        # æ‰§è¡Œé£ä¹¦è®¤è¯
        auth_result = FeishuAuthIntegration.authenticate_with_feishu(code, app_name)

        if not auth_result:
            return APIResponse.error(message='é£ä¹¦è®¤è¯å¤±è´¥', code=401)

        user = auth_result['user']
        system_tokens = auth_result['system_tokens']

        # åºåˆ—åŒ–å“åº”
        token_schema = TokenResponseSchema()
        response_data = token_schema.dump(system_tokens)

        # æ·»åŠ ç”¨æˆ·ä¿¡æ¯
        response_data['user'] = user.to_dict_with_feishu()

        logger.info(f"Feishu authentication successful for user: {user.username}")

        return APIResponse.success(
            data=response_data,
            message='é£ä¹¦ç™»å½•æˆåŠŸ'
        )

    except FeishuAPIException as e:
        logger.error(f"Feishu API error: {str(e)}")
        return APIResponse.error(message=f'é£ä¹¦APIé”™è¯¯: {e.message}', code=401)
    except ValueError as e:
        logger.error(f"Feishu authentication validation error: {str(e)}")
        return APIResponse.error(message=str(e), code=400)
    except Exception as e:
        logger.error(f"Feishu callback failed: {str(e)}")
        return APIResponse.error(message='é£ä¹¦è®¤è¯å¤„ç†å¤±è´¥', code=500)


@bp.route('/refresh-tokens', methods=['POST'])
@login_required
def refresh_feishu_tokens(current_user):
    """
    åˆ·æ–°é£ä¹¦ä»¤ç‰Œ

    Request Body:
        - user_id: ç”¨æˆ·IDï¼ˆå¯é€‰ï¼Œé»˜è®¤å½“å‰ç”¨æˆ·ï¼‰
        - app_name: åº”ç”¨åç§°ï¼ˆå¯é€‰ï¼Œé»˜è®¤'default'ï¼‰

    Returns:
        JSON: åˆ·æ–°ç»“æœ
    """
    try:
        # éªŒè¯è¯·æ±‚æ•°æ®
        schema = TokenRefreshRequestSchema()
        try:
            data = schema.load(request.get_json() or {})
        except ValidationError as e:
            return APIResponse.error(message='å‚æ•°éªŒè¯å¤±è´¥', errors=e.messages, code=400)

        user_id = data.get('user_id') or current_user.id
        app_name = data.get('app_name')

        # æƒé™æ£€æŸ¥ï¼šåªæœ‰è¶…çº§ç®¡ç†å‘˜å¯ä»¥åˆ·æ–°å…¶ä»–ç”¨æˆ·çš„ä»¤ç‰Œ
        if user_id != current_user.id and not current_user.is_super_admin:
            return APIResponse.error(message='æƒé™ä¸è¶³', code=403)

        # åˆ·æ–°ä»¤ç‰Œ
        new_access_token = FeishuAuthIntegration.refresh_feishu_tokens(user_id, app_name)

        if new_access_token:
            return APIResponse.success(
                data={'access_token': new_access_token},
                message='é£ä¹¦ä»¤ç‰Œåˆ·æ–°æˆåŠŸ'
            )
        else:
            return APIResponse.error(message='é£ä¹¦ä»¤ç‰Œåˆ·æ–°å¤±è´¥', code=400)

    except Exception as e:
        logger.error(f"Failed to refresh Feishu tokens: {str(e)}")
        return APIResponse.error(message='ä»¤ç‰Œåˆ·æ–°å¤„ç†å¤±è´¥', code=500)


@bp.route('/validate-access', methods=['POST'])
@login_required
def validate_feishu_access(current_user):
    """
    éªŒè¯ç”¨æˆ·é£ä¹¦è®¿é—®æƒé™

    Request Body:
        - app_name: åº”ç”¨åç§°ï¼ˆå¯é€‰ï¼Œé»˜è®¤'default'ï¼‰

    Returns:
        JSON: éªŒè¯ç»“æœ
    """
    try:
        app_name = request.json.get('app_name', 'default') if request.json else 'default'

        has_access = FeishuAuthIntegration.validate_user_feishu_access(current_user, app_name)

        return APIResponse.success(data={
            'has_access': has_access,
            'can_login_with_feishu': current_user.can_login_with_feishu(),
            'auth_provider': current_user.auth_provider,
            'feishu_user_id': current_user.feishu_user_id
        }, message='æƒé™éªŒè¯å®Œæˆ')

    except Exception as e:
        logger.error(f"Failed to validate Feishu access: {str(e)}")
        return APIResponse.error(message='æƒé™éªŒè¯å¤±è´¥', code=500)


@bp.route('/sync-user', methods=['POST'])
@login_required
@permission_required(permission_code='admin_user_write')
def sync_user_from_feishu(current_user):
    """
    æ‰‹åŠ¨åŒæ­¥é£ä¹¦ç”¨æˆ·ä¿¡æ¯

    Request Body:
        - user_id: ç”¨æˆ·IDï¼ˆå¯é€‰ï¼Œé»˜è®¤å½“å‰ç”¨æˆ·ï¼‰
        - app_name: åº”ç”¨åç§°ï¼ˆå¯é€‰ï¼Œé»˜è®¤'default'ï¼‰

    Returns:
        JSON: åŒæ­¥ç»“æœ
    """
    try:
        data = request.get_json() or {}
        user_id = data.get('user_id') or current_user.id
        app_name = data.get('app_name', 'default')

        # æƒé™æ£€æŸ¥ï¼šåªæœ‰è¶…çº§ç®¡ç†å‘˜å¯ä»¥åŒæ­¥å…¶ä»–ç”¨æˆ·
        if user_id != current_user.id and not current_user.is_super_admin:
            return APIResponse.error(message='æƒé™ä¸è¶³', code=403)

        # è·å–ç›®æ ‡ç”¨æˆ·
        from app.models.user.admin import AdminUser
        target_user = AdminUser.query.get(user_id)

        if not target_user or not target_user.feishu_user_id:
            return APIResponse.error(message='ç”¨æˆ·ä¸å­˜åœ¨æˆ–æœªå…³è”é£ä¹¦è´¦å·', code=404)

        # TODO: å®ç°ç”¨æˆ·ä¿¡æ¯åŒæ­¥é€»è¾‘
        # è¿™é‡Œå¯ä»¥è°ƒç”¨é£ä¹¦APIè·å–æœ€æ–°ç”¨æˆ·ä¿¡æ¯å¹¶æ›´æ–°
        # ç”±äºéœ€è¦ç”¨æˆ·è®¿é—®ä»¤ç‰Œï¼Œå¯èƒ½éœ€è¦ç”¨æˆ·é‡æ–°æˆæƒ

        return APIResponse.success(message='ç”¨æˆ·åŒæ­¥åŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·é‡æ–°ç™»å½•ä»¥æ›´æ–°ä¿¡æ¯')

    except Exception as e:
        logger.error(f"Failed to sync user from Feishu: {str(e)}")
        return APIResponse.error(message='ç”¨æˆ·åŒæ­¥å¤±è´¥', code=500)

# å¥åº·æ£€æŸ¥æ¥å£
@bp.route('/health', methods=['GET'])
def health_check():
    """é£ä¹¦è®¤è¯æœåŠ¡å¥åº·æ£€æŸ¥"""
    try:
        # æ£€æŸ¥åº”ç”¨é…ç½®
        from app.models.feishu.config import FeishuAppConfig
        config_count = FeishuAppConfig.query.filter_by(is_active=True).count()

        return APIResponse.success(data={
            'service': 'feishu-auth',
            'status': 'healthy',
            'active_configs': config_count,
            'timestamp': datetime.utcnow().isoformat()
        })
    except Exception as e:
        return APIResponse.error(message=f'æœåŠ¡ä¸å¥åº·: {str(e)}', code=500)
```

#### 2.3 æ³¨å†Œè·¯ç”±è“å›¾
```python
# app/api/v1/feishu_auth/route/__init__.py

from flask import Blueprint

# åˆ›å»ºé£ä¹¦è®¤è¯è“å›¾
bp = Blueprint('feishu_auth', __name__, url_prefix='/feishu-auth')

# å¯¼å…¥è·¯ç”±
from app.api.v1.feishu_auth.route import routes
```

```python
# app/api/v1/__init__.py - æ·»åŠ åˆ°ç°æœ‰æ–‡ä»¶

from app.api.v1.feishu_auth.route import bp as feishu_auth_bp

def register_blueprints(app):
    """æ³¨å†Œæ‰€æœ‰APIè“å›¾"""
    # ... ç°æœ‰è“å›¾æ³¨å†Œ ...

    # æ³¨å†Œé£ä¹¦è®¤è¯è“å›¾
    app.register_blueprint(feishu_auth_bp, url_prefix='/api/v1')
```

**âœ… é˜¶æ®µæµ‹è¯•2ï¼šOAuth2æµç¨‹éªŒè¯**
```python
# tests/feishu/integration/test_oauth2_flow.py

import pytest
from unittest.mock import patch, Mock
from flask import url_for

from app import create_app
from app.extensions import db
from app.models.feishu.config import FeishuAppConfig
from app.models.user.admin import AdminUser

@pytest.fixture
def app():
    app = create_app('testing')
    with app.app_context():
        db.create_all()

        # åˆ›å»ºæµ‹è¯•é£ä¹¦é…ç½®
        config = FeishuAppConfig(
            app_name='test',
            app_id='test_app_id',
            app_secret='test_app_secret',
            is_active=True,
            auto_create_user=True
        )
        db.session.add(config)
        db.session.commit()

        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

class TestFeishuOAuth2Flow:

    def test_get_authorization_url(self, client):
        """æµ‹è¯•è·å–æˆæƒURL"""
        response = client.get('/api/v1/feishu-auth/authorize', query_string={
            'app': 'test',
            'redirect_uri': 'http://localhost/callback'
        })

        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert 'authorization_url' in data['data']
        assert 'state' in data['data']
        assert 'open.feishu.cn' in data['data']['authorization_url']

    def test_get_authorization_url_missing_redirect_uri(self, client):
        """æµ‹è¯•ç¼ºå°‘redirect_uriå‚æ•°"""
        response = client.get('/api/v1/feishu-auth/authorize', query_string={
            'app': 'test'
        })

        assert response.status_code == 400
        data = response.get_json()
        assert data['success'] is False
        assert 'redirect_uri' in data['errors']

    @patch('app.services.feishu.service.auth_integration.FeishuAuthIntegration.authenticate_with_feishu')
    def test_feishu_callback_success(self, mock_auth, client):
        """æµ‹è¯•é£ä¹¦å›è°ƒæˆåŠŸ"""
        # è®¾ç½®session state
        with client.session_transaction() as sess:
            sess['feishu_state_test123'] = {
                'app_name': 'test',
                'redirect_uri': 'http://localhost/callback',
                'created_at': '2025-09-19T10:00:00'
            }

        # Mockè®¤è¯ç»“æœ
        mock_user = AdminUser(
            id=1,
            username='test_user',
            email='test@company.com',
            full_name='Test User',
            auth_provider='feishu'
        )

        mock_auth.return_value = {
            'user': mock_user,
            'system_tokens': {
                'access_token': 'system_token',
                'refresh_token': 'refresh_token',
                'expires_in': 3600
            },
            'feishu_tokens': {
                'access_token': 'feishu_token',
                'refresh_token': 'feishu_refresh'
            },
            'feishu_user_info': {
                'user_id': 'feishu_123',
                'name': 'Test User'
            }
        }

        response = client.post('/api/v1/feishu-auth/callback', json={
            'code': 'test_code',
            'state': 'test123'
        })

        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert 'access_token' in data['data']
        assert 'user' in data['data']

    def test_feishu_callback_invalid_state(self, client):
        """æµ‹è¯•æ— æ•ˆstateå‚æ•°"""
        response = client.post('/api/v1/feishu-auth/callback', json={
            'code': 'test_code',
            'state': 'invalid_state'
        })

        assert response.status_code == 400
        data = response.get_json()
        assert data['success'] is False
        assert 'æ— æ•ˆçš„çŠ¶æ€å‚æ•°' in data['message']

    def test_health_check(self, client):
        """æµ‹è¯•å¥åº·æ£€æŸ¥"""
        response = client.get('/api/v1/feishu-auth/health')

        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert data['data']['service'] == 'feishu-auth'
        assert data['data']['status'] == 'healthy'

# é›†æˆæµ‹è¯•è„šæœ¬
def run_integration_test():
    """è¿è¡Œå®Œæ•´çš„OAuth2æµç¨‹é›†æˆæµ‹è¯•"""
    print("ğŸ§ª å¼€å§‹OAuth2æµç¨‹é›†æˆæµ‹è¯•...")

    # 1. æµ‹è¯•è·å–æˆæƒURL
    print("1. æµ‹è¯•è·å–æˆæƒURL...")
    # å®é™…è°ƒç”¨æœ¬åœ°API

    # 2. æ‰‹åŠ¨æˆæƒï¼ˆéœ€è¦äººå·¥æ“ä½œï¼‰
    print("2. è¯·æ‰‹åŠ¨å®Œæˆé£ä¹¦æˆæƒ...")
    print("   - å¤åˆ¶ä¸Šä¸€æ­¥çš„æˆæƒURL")
    print("   - åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€å¹¶æˆæƒ")
    print("   - ä»å›è°ƒURLä¸­è·å–codeå‚æ•°")

    # 3. æµ‹è¯•å›è°ƒå¤„ç†
    code = input("è¯·è¾“å…¥è·å–åˆ°çš„æˆæƒç : ")
    print(f"3. æµ‹è¯•å›è°ƒå¤„ç†ï¼Œcode: {code[:10]}...")
    # å®é™…è°ƒç”¨å›è°ƒAPI

    print("âœ… OAuth2æµç¨‹é›†æˆæµ‹è¯•å®Œæˆ")

if __name__ == "__main__":
    run_integration_test()
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] OAuth2å®Œæ•´æµç¨‹å®ç°
- [ ] APIæ¥å£åŠŸèƒ½æ­£å¸¸
- [ ] é”™è¯¯å¤„ç†å’ŒéªŒè¯å®Œå–„
- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] å®‰å…¨æªæ–½ï¼ˆCSRFé˜²æŠ¤ã€stateéªŒè¯ï¼‰æœ‰æ•ˆ

---

## ğŸ ç¬¬2é˜¶æ®µå®Œæˆæ£€æŸ¥è¡¨

### æ ¸å¿ƒæœåŠ¡å®ç° âœ…
- [ ] FeishuAuthServiceåŸºç¡€APIè°ƒç”¨å®Œæˆ
- [ ] FeishuUserServiceç”¨æˆ·ç®¡ç†é€»è¾‘å®Œæˆ
- [ ] FeishuTokenManagerä»¤ç‰Œç¼“å­˜åŠŸèƒ½å®Œæˆ
- [ ] å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•å®Œå–„

### OAuth2æµç¨‹é›†æˆ âœ…
- [ ] FeishuAuthIntegrationä¸»è®¤è¯æœåŠ¡å®Œæˆ
- [ ] APIè·¯ç”±å’Œè¯·æ±‚å¤„ç†å®Œæˆ
- [ ] CSRFé˜²æŠ¤å’Œå®‰å…¨éªŒè¯å®ç°
- [ ] å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶

### æµ‹è¯•è¦†ç›– âœ…
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡90%ä»¥ä¸Š
- [ ] é›†æˆæµ‹è¯•åœºæ™¯è¦†ç›–å®Œæ•´
- [ ] Mockæµ‹è¯•å’ŒçœŸå®APIæµ‹è¯•
- [ ] é”™è¯¯åœºæ™¯æµ‹è¯•å®Œå–„

### ä»£ç è´¨é‡ âœ…
- [ ] ä»£ç è§„èŒƒç¬¦åˆé¡¹ç›®æ ‡å‡†
- [ ] æ–‡æ¡£æ³¨é‡Šå®Œæ•´
- [ ] æ—¥å¿—è®°å½•è¯¦ç»†
- [ ] æ€§èƒ½å’Œå®‰å…¨è€ƒè™‘

## ğŸ¯ ç¬¬3é˜¶æ®µé¢„å‘Š

**ç¬¬3é˜¶æ®µï¼šå‰ç«¯é›†æˆå’Œç”¨æˆ·ä½“éªŒ**
- Reactç™»å½•ç»„ä»¶å¼€å‘
- é£ä¹¦å›è°ƒé¡µé¢å®ç°
- ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤ºæ‰©å±•
- çŠ¶æ€ç®¡ç†å’Œè·¯ç”±é›†æˆ
- å®Œæ•´çš„å‰ç«¯æµ‹è¯•

**é¢„ä¼°æ—¶é—´**ï¼š3-4å¤©
**ä¸»è¦äº§å‡º**ï¼šå®Œæ•´çš„å‰ç«¯é£ä¹¦ç™»å½•ç”¨æˆ·ä½“éªŒ

---

**ç¬¬2é˜¶æ®µå®Œæˆæ ‡å¿—**ï¼šåç«¯é£ä¹¦è®¤è¯æœåŠ¡å®Œå…¨å¯ç”¨ï¼Œæ‰€æœ‰APIæ¥å£æµ‹è¯•é€šè¿‡ï¼Œä¸ºå‰ç«¯é›†æˆåšå¥½å‡†å¤‡ã€‚