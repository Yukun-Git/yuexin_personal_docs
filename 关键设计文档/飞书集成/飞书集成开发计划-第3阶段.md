# é£ä¹¦ç™»å½•é›†æˆå¼€å‘è®¡åˆ’ - ç¬¬3é˜¶æ®µï¼šå‰ç«¯é›†æˆå’Œç”¨æˆ·ä½“éªŒ

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

**ç›®æ ‡**ï¼šå®ç°å®Œæ•´çš„å‰ç«¯é£ä¹¦ç™»å½•é›†æˆï¼ŒåŒ…æ‹¬ç™»å½•ç»„ä»¶ã€å›è°ƒå¤„ç†ã€ç”¨æˆ·ä½“éªŒä¼˜åŒ–
**é¢„ä¼°æ—¶é—´**ï¼š3-4å¤©
**ä¼˜å…ˆçº§**ï¼šé«˜
**ä¾èµ–**ï¼šç¬¬1ã€2é˜¶æ®µå®Œæˆ

## ğŸ¯ é˜¶æ®µç›®æ ‡

- [ ] å¼€å‘Reacté£ä¹¦ç™»å½•ç»„ä»¶
- [ ] å®ç°é£ä¹¦å›è°ƒé¡µé¢å¤„ç†
- [ ] æ‰©å±•ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤ºå’Œç®¡ç†
- [ ] é›†æˆå‰ç«¯çŠ¶æ€ç®¡ç†å’Œè·¯ç”±
- [ ] ä¼˜åŒ–ç”¨æˆ·ä½“éªŒå’Œé”™è¯¯å¤„ç†
- [ ] ç¼–å†™å®Œæ•´çš„å‰ç«¯æµ‹è¯•

## ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

### ä»»åŠ¡1ï¼šReactç™»å½•ç»„ä»¶å¼€å‘ (1.5å¤©)

#### 1.1 åˆ›å»ºé£ä¹¦ç™»å½•æŒ‰é’®ç»„ä»¶
```typescript
// frontend/src/components/auth/FeishuLoginButton.tsx

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React, { useState } from 'react';
import { Button, message } from 'antd';
import { FeishuOutlined } from '@ant-design/icons';
import { useFeishuAuth } from '../../hooks/useFeishuAuth';
import { LoadingOutlined } from '@ant-design/icons';

interface FeishuLoginButtonProps {
  onLoginStart?: () => void;
  onLoginSuccess?: (userInfo: any) => void;
  onLoginError?: (error: string) => void;
  className?: string;
  size?: 'small' | 'middle' | 'large';
  block?: boolean;
  disabled?: boolean;
}

export const FeishuLoginButton: React.FC<FeishuLoginButtonProps> = ({
  onLoginStart,
  onLoginSuccess,
  onLoginError,
  className,
  size = 'middle',
  block = false,
  disabled = false
}) => {
  const [loading, setLoading] = useState(false);
  const { getAuthorizationUrl } = useFeishuAuth();

  const handleLogin = async () => {
    try {
      setLoading(true);
      onLoginStart?.();

      // Generate CSRF state token
      const state = generateStateToken();

      // Store state in sessionStorage for validation
      sessionStorage.setItem('feishu_oauth_state', state);

      // Get authorization URL
      const authUrl = await getAuthorizationUrl(state);

      // Redirect to Feishu authorization page
      window.location.href = authUrl;

    } catch (error: any) {
      setLoading(false);
      const errorMessage = error?.message || 'Failed to initiate Feishu login';
      message.error(errorMessage);
      onLoginError?.(errorMessage);
    }
  };

  const generateStateToken = (): string => {
    const timestamp = Date.now().toString();
    const random = Math.random().toString(36).substring(2);
    return btoa(`${timestamp}-${random}`);
  };

  return (
    <Button
      type="default"
      size={size}
      block={block}
      disabled={disabled || loading}
      className={`feishu-login-button ${className || ''}`}
      onClick={handleLogin}
      icon={loading ? <LoadingOutlined /> : <FeishuOutlined />}
      style={{
        borderColor: '#00d4aa',
        color: '#00d4aa'
      }}
    >
      {loading ? 'Connecting to Feishu...' : 'Login with Feishu'}
    </Button>
  );
};

export default FeishuLoginButton;
```

#### 1.2 åˆ›å»ºé£ä¹¦è®¤è¯Hook
```typescript
// frontend/src/hooks/useFeishuAuth.ts

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { useState, useCallback } from 'react';
import { useDispatch } from 'react-redux';
import { feishuApi } from '../api/feishuApi';
import { authSlice } from '../store/slices/authSlice';
import { message } from 'antd';

interface FeishuAuthState {
  isLoading: boolean;
  error: string | null;
  isAuthenticated: boolean;
}

export const useFeishuAuth = () => {
  const dispatch = useDispatch();
  const [state, setState] = useState<FeishuAuthState>({
    isLoading: false,
    error: null,
    isAuthenticated: false
  });

  const getAuthorizationUrl = useCallback(async (state?: string): Promise<string> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await feishuApi.getAuthorizationUrl({ state });
      setState(prev => ({ ...prev, isLoading: false }));
      return response.authorization_url;
    } catch (error: any) {
      const errorMessage = error?.message || 'Failed to get authorization URL';
      setState(prev => ({ ...prev, isLoading: false, error: errorMessage }));
      throw error;
    }
  }, []);

  const handleCallback = useCallback(async (code: string, state?: string): Promise<void> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Validate state parameter
      const storedState = sessionStorage.getItem('feishu_oauth_state');
      if (state && state !== storedState) {
        throw new Error('Invalid state parameter - possible CSRF attack');
      }

      // Process callback
      const response = await feishuApi.handleCallback({ code, state });

      // Update auth state
      dispatch(authSlice.actions.setUser(response.user));
      dispatch(authSlice.actions.setTokens({
        access_token: response.access_token,
        refresh_token: response.refresh_token
      }));

      setState(prev => ({
        ...prev,
        isLoading: false,
        isAuthenticated: true
      }));

      // Clear stored state
      sessionStorage.removeItem('feishu_oauth_state');

      message.success('Login successful!');
    } catch (error: any) {
      const errorMessage = error?.message || 'Login failed';
      setState(prev => ({ ...prev, isLoading: false, error: errorMessage }));
      message.error(errorMessage);
      throw error;
    }
  }, [dispatch]);

  const refreshTokens = useCallback(async (): Promise<void> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await feishuApi.refreshTokens();

      dispatch(authSlice.actions.setTokens({
        access_token: response.access_token,
        refresh_token: response.refresh_token
      }));

      setState(prev => ({ ...prev, isLoading: false }));
    } catch (error: any) {
      const errorMessage = error?.message || 'Failed to refresh tokens';
      setState(prev => ({ ...prev, isLoading: false, error: errorMessage }));
      throw error;
    }
  }, [dispatch]);

  const validateAccess = useCallback(async (): Promise<boolean> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await feishuApi.validateAccess();
      setState(prev => ({
        ...prev,
        isLoading: false,
        isAuthenticated: response.valid
      }));
      return response.valid;
    } catch (error: any) {
      setState(prev => ({ ...prev, isLoading: false, error: error?.message }));
      return false;
    }
  }, []);

  return {
    ...state,
    getAuthorizationUrl,
    handleCallback,
    refreshTokens,
    validateAccess
  };
};
```

#### 1.3 é›†æˆåˆ°ç°æœ‰ç™»å½•é¡µé¢
```typescript
// frontend/src/pages/auth/LoginPage.tsx - æ‰©å±•ç°æœ‰ç™»å½•é¡µé¢

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React from 'react';
import { Card, Space, Divider, Typography } from 'antd';
import LoginForm from '../../components/auth/LoginForm'; // ç°æœ‰ç™»å½•è¡¨å•
import FeishuLoginButton from '../../components/auth/FeishuLoginButton';
import { useNavigate } from 'react-router-dom';

const { Title, Text } = Typography;

const LoginPage: React.FC = () => {
  const navigate = useNavigate();

  const handleFeishuLoginSuccess = (userInfo: any) => {
    // Navigate to dashboard after successful login
    navigate('/dashboard');
  };

  const handleFeishuLoginError = (error: string) => {
    console.error('Feishu login error:', error);
  };

  return (
    <div className="login-page">
      <Card className="login-card" style={{ width: 400, margin: '0 auto', marginTop: '10vh' }}>
        <Title level={3} style={{ textAlign: 'center', marginBottom: 24 }}>
          Pigeon Web Login
        </Title>

        {/* ç°æœ‰çš„ç”¨æˆ·åå¯†ç ç™»å½•è¡¨å• */}
        <LoginForm />

        <Divider>
          <Text type="secondary">OR</Text>
        </Divider>

        {/* é£ä¹¦ç™»å½•é€‰é¡¹ */}
        <Space direction="vertical" style={{ width: '100%' }}>
          <FeishuLoginButton
            block
            size="large"
            onLoginSuccess={handleFeishuLoginSuccess}
            onLoginError={handleFeishuLoginError}
          />

          <Text type="secondary" style={{ fontSize: '12px', textAlign: 'center', display: 'block' }}>
            Use your Feishu account to login securely
          </Text>
        </Space>
      </Card>
    </div>
  );
};

export default LoginPage;
```

**âœ… é˜¶æ®µæµ‹è¯•1ï¼šç™»å½•ç»„ä»¶åŠŸèƒ½éªŒè¯**
```typescript
// frontend/src/tests/components/FeishuLoginButton.test.tsx

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import FeishuLoginButton from '../../components/auth/FeishuLoginButton';
import { authSlice } from '../../store/slices/authSlice';

// Mock the feishu API
jest.mock('../../api/feishuApi', () => ({
  feishuApi: {
    getAuthorizationUrl: jest.fn().mockResolvedValue({
      authorization_url: 'https://open.feishu.cn/open-apis/authen/v1/index?app_id=test&redirect_uri=test'
    })
  }
}));

const mockStore = configureStore({
  reducer: {
    auth: authSlice.reducer
  }
});

const renderWithProviders = (component: React.ReactElement) => {
  return render(
    <Provider store={mockStore}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </Provider>
  );
};

describe('FeishuLoginButton', () => {
  beforeEach(() => {
    // Mock sessionStorage
    Object.defineProperty(window, 'sessionStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
      },
    });

    // Mock window.location
    delete (window as any).location;
    window.location = { href: '' } as any;
  });

  test('renders login button correctly', () => {
    renderWithProviders(<FeishuLoginButton />);

    const button = screen.getByRole('button', { name: /login with feishu/i });
    expect(button).toBeInTheDocument();
    expect(button).toHaveClass('feishu-login-button');
  });

  test('handles login click correctly', async () => {
    const onLoginStart = jest.fn();

    renderWithProviders(
      <FeishuLoginButton onLoginStart={onLoginStart} />
    );

    const button = screen.getByRole('button', { name: /login with feishu/i });
    fireEvent.click(button);

    await waitFor(() => {
      expect(onLoginStart).toHaveBeenCalled();
      expect(window.sessionStorage.setItem).toHaveBeenCalledWith(
        'feishu_oauth_state',
        expect.any(String)
      );
    });
  });

  test('shows loading state during login process', async () => {
    renderWithProviders(<FeishuLoginButton />);

    const button = screen.getByRole('button', { name: /login with feishu/i });
    fireEvent.click(button);

    // Should show loading state
    expect(screen.getByText(/connecting to feishu/i)).toBeInTheDocument();
  });

  test('handles disabled state correctly', () => {
    renderWithProviders(<FeishuLoginButton disabled />);

    const button = screen.getByRole('button', { name: /login with feishu/i });
    expect(button).toBeDisabled();
  });
});
```

### ä»»åŠ¡2ï¼šé£ä¹¦å›è°ƒé¡µé¢å®ç° (1å¤©)

#### 2.1 åˆ›å»ºå›è°ƒå¤„ç†é¡µé¢
```typescript
// frontend/src/pages/auth/FeishuCallbackPage.tsx

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React, { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Card, Spin, Result, Button } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';
import { useFeishuAuth } from '../../hooks/useFeishuAuth';

type CallbackState = 'loading' | 'success' | 'error';

const FeishuCallbackPage: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { handleCallback } = useFeishuAuth();

  const [state, setState] = useState<CallbackState>('loading');
  const [errorMessage, setErrorMessage] = useState<string>('');
  const [userInfo, setUserInfo] = useState<any>(null);

  useEffect(() => {
    const processCallback = async () => {
      try {
        // Extract parameters from URL
        const code = searchParams.get('code');
        const state = searchParams.get('state');
        const error = searchParams.get('error');
        const errorDescription = searchParams.get('error_description');

        // Handle OAuth error response
        if (error) {
          throw new Error(errorDescription || `OAuth error: ${error}`);
        }

        // Validate required parameters
        if (!code) {
          throw new Error('Authorization code not received');
        }

        // Process the callback
        await handleCallback(code, state || undefined);

        setState('success');

        // Redirect to dashboard after 2 seconds
        setTimeout(() => {
          navigate('/dashboard', { replace: true });
        }, 2000);

      } catch (error: any) {
        console.error('Feishu callback error:', error);
        setErrorMessage(error?.message || 'Login failed');
        setState('error');
      }
    };

    processCallback();
  }, [searchParams, handleCallback, navigate]);

  const handleRetry = () => {
    navigate('/auth/login', { replace: true });
  };

  const renderContent = () => {
    switch (state) {
      case 'loading':
        return (
          <Card style={{ textAlign: 'center', padding: '40px' }}>
            <Spin size="large" />
            <div style={{ marginTop: 16, fontSize: '16px' }}>
              Processing Feishu login...
            </div>
            <div style={{ marginTop: 8, color: '#666', fontSize: '14px' }}>
              Please wait while we verify your account
            </div>
          </Card>
        );

      case 'success':
        return (
          <Result
            icon={<CheckCircleOutlined style={{ color: '#52c41a' }} />}
            title="Login Successful!"
            subTitle="You have successfully logged in with Feishu. Redirecting to dashboard..."
            extra={
              <Button type="primary" onClick={() => navigate('/dashboard')}>
                Go to Dashboard
              </Button>
            }
          />
        );

      case 'error':
        return (
          <Result
            icon={<CloseCircleOutlined style={{ color: '#ff4d4f' }} />}
            title="Login Failed"
            subTitle={errorMessage}
            extra={[
              <Button type="primary" onClick={handleRetry} key="retry">
                Try Again
              </Button>,
              <Button onClick={() => navigate('/')} key="home">
                Go Home
              </Button>
            ]}
          />
        );

      default:
        return null;
    }
  };

  return (
    <div style={{
      minHeight: '100vh',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#f5f5f5'
    }}>
      {renderContent()}
    </div>
  );
};

export default FeishuCallbackPage;
```

#### 2.2 æ·»åŠ è·¯ç”±é…ç½®
```typescript
// frontend/src/routes/authRoutes.tsx - æ‰©å±•ç°æœ‰è·¯ç”±é…ç½®

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React from 'react';
import { RouteObject } from 'react-router-dom';
import LoginPage from '../pages/auth/LoginPage';
import FeishuCallbackPage from '../pages/auth/FeishuCallbackPage';

export const authRoutes: RouteObject[] = [
  {
    path: '/auth/login',
    element: <LoginPage />
  },
  {
    path: '/auth/feishu/callback',
    element: <FeishuCallbackPage />
  },
  // ... å…¶ä»–è®¤è¯ç›¸å…³è·¯ç”±
];
```

#### 2.3 åˆ›å»ºé”™è¯¯è¾¹ç•Œç»„ä»¶
```typescript
// frontend/src/components/auth/FeishuAuthErrorBoundary.tsx

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React, { Component, ReactNode } from 'react';
import { Result, Button } from 'antd';
import { ExceptionOutlined } from '@ant-design/icons';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class FeishuAuthErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Feishu Auth Error Boundary caught an error:', error, errorInfo);

    // You can also log the error to an error reporting service here
    // logErrorToService(error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    window.location.href = '/auth/login';
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <Result
            icon={<ExceptionOutlined />}
            title="Authentication Error"
            subTitle={`Something went wrong during the login process: ${this.state.error?.message}`}
            extra={
              <Button type="primary" onClick={this.handleReset}>
                Return to Login
              </Button>
            }
          />
        </div>
      );
    }

    return this.props.children;
  }
}

export default FeishuAuthErrorBoundary;
```

**âœ… é˜¶æ®µæµ‹è¯•2ï¼šå›è°ƒå¤„ç†éªŒè¯**
```typescript
// frontend/src/tests/pages/FeishuCallbackPage.test.tsx

import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import FeishuCallbackPage from '../../pages/auth/FeishuCallbackPage';
import { mockStore } from '../testUtils';

// Mock the useFeishuAuth hook
jest.mock('../../hooks/useFeishuAuth', () => ({
  useFeishuAuth: jest.fn()
}));

// Mock react-router-dom
const mockNavigate = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate,
  useSearchParams: () => [new URLSearchParams('code=test_code&state=test_state')]
}));

describe('FeishuCallbackPage', () => {
  const mockHandleCallback = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();

    (require('../../hooks/useFeishuAuth').useFeishuAuth as jest.Mock).mockReturnValue({
      handleCallback: mockHandleCallback
    });
  });

  const renderWithProviders = (component: React.ReactElement) => {
    return render(
      <Provider store={mockStore}>
        <BrowserRouter>
          {component}
        </BrowserRouter>
      </Provider>
    );
  };

  test('shows loading state initially', () => {
    renderWithProviders(<FeishuCallbackPage />);

    expect(screen.getByText(/processing feishu login/i)).toBeInTheDocument();
    expect(screen.getByText(/please wait while we verify/i)).toBeInTheDocument();
  });

  test('handles successful callback', async () => {
    mockHandleCallback.mockResolvedValue({});

    renderWithProviders(<FeishuCallbackPage />);

    await waitFor(() => {
      expect(screen.getByText(/login successful/i)).toBeInTheDocument();
    });

    expect(mockHandleCallback).toHaveBeenCalledWith('test_code', 'test_state');
  });

  test('handles callback error', async () => {
    const errorMessage = 'Invalid authorization code';
    mockHandleCallback.mockRejectedValue(new Error(errorMessage));

    renderWithProviders(<FeishuCallbackPage />);

    await waitFor(() => {
      expect(screen.getByText(/login failed/i)).toBeInTheDocument();
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });

  test('handles OAuth error in URL', async () => {
    // Mock URL with error parameter
    jest.mocked(require('react-router-dom').useSearchParams).mockReturnValue([
      new URLSearchParams('error=access_denied&error_description=User cancelled')
    ]);

    renderWithProviders(<FeishuCallbackPage />);

    await waitFor(() => {
      expect(screen.getByText(/login failed/i)).toBeInTheDocument();
      expect(screen.getByText(/user cancelled/i)).toBeInTheDocument();
    });
  });
});
```

### ä»»åŠ¡3ï¼šç”¨æˆ·ä¿¡æ¯æ‰©å±•å’ŒçŠ¶æ€ç®¡ç† (0.5å¤©)

#### 3.1 æ‰©å±•ç”¨æˆ·çŠ¶æ€ç®¡ç†
```typescript
// frontend/src/store/slices/authSlice.ts - æ‰©å±•ç°æœ‰è®¤è¯çŠ¶æ€ç®¡ç†

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface FeishuInfo {
  user_id: string;
  name: string;
  en_name?: string;
  email?: string;
  avatar_url?: string;
  mobile?: string;
  department_ids?: string[];
  union_id?: string;
  open_id?: string;
}

interface User {
  id: string;
  username: string;
  email: string;
  full_name: string;
  avatar_url?: string;
  roles: string[];
  permissions: string[];
  // æ‰©å±•é£ä¹¦ç›¸å…³å­—æ®µ
  auth_provider?: 'local' | 'feishu';
  feishu_info?: FeishuInfo;
  last_feishu_sync?: string;
  is_feishu_user?: boolean;
}

interface AuthState {
  user: User | null;
  access_token: string | null;
  refresh_token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  // é£ä¹¦ç›¸å…³çŠ¶æ€
  feishu_access_token?: string;
  feishu_refresh_token?: string;
  feishu_expires_at?: number;
}

const initialState: AuthState = {
  user: null,
  access_token: null,
  refresh_token: null,
  isAuthenticated: false,
  isLoading: false,
  error: null
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // ç°æœ‰çš„actions...

    // é£ä¹¦ç™»å½•ç›¸å…³actions
    setFeishuTokens: (state, action: PayloadAction<{
      feishu_access_token: string;
      feishu_refresh_token: string;
      feishu_expires_at: number;
    }>) => {
      state.feishu_access_token = action.payload.feishu_access_token;
      state.feishu_refresh_token = action.payload.feishu_refresh_token;
      state.feishu_expires_at = action.payload.feishu_expires_at;
    },

    updateFeishuInfo: (state, action: PayloadAction<FeishuInfo>) => {
      if (state.user) {
        state.user.feishu_info = action.payload;
        state.user.last_feishu_sync = new Date().toISOString();
        state.user.is_feishu_user = true;
        if (state.user.auth_provider !== 'feishu') {
          state.user.auth_provider = 'feishu';
        }
      }
    },

    clearFeishuTokens: (state) => {
      state.feishu_access_token = undefined;
      state.feishu_refresh_token = undefined;
      state.feishu_expires_at = undefined;
    },

    setAuthProvider: (state, action: PayloadAction<'local' | 'feishu'>) => {
      if (state.user) {
        state.user.auth_provider = action.payload;
      }
    },

    // æ‰©å±•ç°æœ‰çš„ setUser action ä»¥æ”¯æŒé£ä¹¦ç”¨æˆ·
    setUser: (state, action: PayloadAction<User>) => {
      state.user = action.payload;
      state.isAuthenticated = true;
      state.error = null;
    },

    // ... å…¶ä»–ç°æœ‰actions
  }
});

export const {
  setUser,
  setTokens,
  setFeishuTokens,
  updateFeishuInfo,
  clearFeishuTokens,
  setAuthProvider,
  // ... å…¶ä»–ç°æœ‰actions
} = authSlice.actions;

export default authSlice.reducer;

// Selectors
export const selectCurrentUser = (state: { auth: AuthState }) => state.auth.user;
export const selectIsFeishuUser = (state: { auth: AuthState }) =>
  state.auth.user?.auth_provider === 'feishu';
export const selectFeishuInfo = (state: { auth: AuthState }) =>
  state.auth.user?.feishu_info;
export const selectFeishuTokens = (state: { auth: AuthState }) => ({
  access_token: state.auth.feishu_access_token,
  refresh_token: state.auth.feishu_refresh_token,
  expires_at: state.auth.feishu_expires_at
});
```

#### 3.2 åˆ›å»ºç”¨æˆ·ä¿¡æ¯æ˜¾ç¤ºç»„ä»¶
```typescript
// frontend/src/components/user/UserProfileCard.tsx - æ‰©å±•ç°æœ‰ç”¨æˆ·ä¿¡æ¯ç»„ä»¶

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React from 'react';
import { Card, Avatar, Tag, Space, Typography, Tooltip, Badge } from 'antd';
import { UserOutlined, MailOutlined, PhoneOutlined, TeamOutlined } from '@ant-design/icons';
import { useSelector } from 'react-redux';
import { selectCurrentUser, selectIsFeishuUser, selectFeishuInfo } from '../../store/slices/authSlice';

const { Text, Title } = Typography;

interface UserProfileCardProps {
  showFeishuInfo?: boolean;
  compact?: boolean;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({
  showFeishuInfo = true,
  compact = false
}) => {
  const user = useSelector(selectCurrentUser);
  const isFeishuUser = useSelector(selectIsFeishuUser);
  const feishuInfo = useSelector(selectFeishuInfo);

  if (!user) return null;

  const renderAuthProviderBadge = () => {
    if (user.auth_provider === 'feishu') {
      return (
        <Tooltip title="Logged in via Feishu">
          <Tag color="green" style={{ marginLeft: 8 }}>
            Feishu
          </Tag>
        </Tooltip>
      );
    }
    return (
      <Tooltip title="Local account">
        <Tag color="blue" style={{ marginLeft: 8 }}>
          Local
        </Tag>
      </Tooltip>
    );
  };

  const renderFeishuInfo = () => {
    if (!showFeishuInfo || !isFeishuUser || !feishuInfo) return null;

    return (
      <Card
        size="small"
        title="Feishu Information"
        style={{ marginTop: 16 }}
        extra={
          <Tag color="processing" size="small">
            Synced
          </Tag>
        }
      >
        <Space direction="vertical" style={{ width: '100%' }}>
          {feishuInfo.en_name && (
            <div>
              <Text type="secondary">English Name: </Text>
              <Text>{feishuInfo.en_name}</Text>
            </div>
          )}

          {feishuInfo.mobile && (
            <div>
              <PhoneOutlined style={{ marginRight: 8, color: '#1890ff' }} />
              <Text>{feishuInfo.mobile}</Text>
            </div>
          )}

          {feishuInfo.department_ids && feishuInfo.department_ids.length > 0 && (
            <div>
              <TeamOutlined style={{ marginRight: 8, color: '#1890ff' }} />
              <Text>Departments: {feishuInfo.department_ids.length}</Text>
            </div>
          )}

          {user.last_feishu_sync && (
            <div>
              <Text type="secondary" style={{ fontSize: '12px' }}>
                Last sync: {new Date(user.last_feishu_sync).toLocaleString()}
              </Text>
            </div>
          )}
        </Space>
      </Card>
    );
  };

  if (compact) {
    return (
      <Space>
        <Avatar
          src={user.avatar_url || feishuInfo?.avatar_url}
          icon={<UserOutlined />}
          size="small"
        />
        <Text>{user.full_name}</Text>
        {renderAuthProviderBadge()}
      </Space>
    );
  }

  return (
    <Card>
      <Space direction="vertical" style={{ width: '100%' }}>
        <div style={{ textAlign: 'center' }}>
          <Badge
            dot={isFeishuUser}
            color="green"
            offset={[-10, 10]}
          >
            <Avatar
              src={user.avatar_url || feishuInfo?.avatar_url}
              icon={<UserOutlined />}
              size={64}
            />
          </Badge>

          <Title level={4} style={{ margin: '16px 0 8px 0' }}>
            {user.full_name}
            {renderAuthProviderBadge()}
          </Title>

          <Text type="secondary">@{user.username}</Text>
        </div>

        <Space direction="vertical" style={{ width: '100%' }}>
          <div>
            <MailOutlined style={{ marginRight: 8, color: '#1890ff' }} />
            <Text>{user.email}</Text>
          </div>

          <div>
            <Text type="secondary">Roles: </Text>
            <Space wrap>
              {user.roles.map(role => (
                <Tag key={role} color="blue">{role}</Tag>
              ))}
            </Space>
          </div>
        </Space>

        {renderFeishuInfo()}
      </Space>
    </Card>
  );
};

export default UserProfileCard;
```

**âœ… é˜¶æ®µæµ‹è¯•3ï¼šçŠ¶æ€ç®¡ç†éªŒè¯**
```typescript
// frontend/src/tests/store/authSlice.test.ts

import { configureStore } from '@reduxjs/toolkit';
import authSlice, {
  setUser,
  setFeishuTokens,
  updateFeishuInfo,
  clearFeishuTokens,
  selectIsFeishuUser,
  selectFeishuInfo
} from '../../store/slices/authSlice';

describe('authSlice - Feishu integration', () => {
  let store: ReturnType<typeof configureStore>;

  beforeEach(() => {
    store = configureStore({
      reducer: {
        auth: authSlice
      }
    });
  });

  test('should handle setFeishuTokens', () => {
    const tokens = {
      feishu_access_token: 'test_token',
      feishu_refresh_token: 'refresh_token',
      feishu_expires_at: 1234567890
    };

    store.dispatch(setFeishuTokens(tokens));

    const state = store.getState().auth;
    expect(state.feishu_access_token).toBe(tokens.feishu_access_token);
    expect(state.feishu_refresh_token).toBe(tokens.feishu_refresh_token);
    expect(state.feishu_expires_at).toBe(tokens.feishu_expires_at);
  });

  test('should handle updateFeishuInfo', () => {
    const user = {
      id: '1',
      username: 'testuser',
      email: 'test@example.com',
      full_name: 'Test User',
      roles: ['user'],
      permissions: []
    };

    const feishuInfo = {
      user_id: 'feishu_123',
      name: 'Test User',
      en_name: 'Test User EN',
      email: 'test@company.com',
      avatar_url: 'https://example.com/avatar.jpg'
    };

    store.dispatch(setUser(user));
    store.dispatch(updateFeishuInfo(feishuInfo));

    const state = store.getState().auth;
    expect(state.user?.feishu_info).toEqual(feishuInfo);
    expect(state.user?.is_feishu_user).toBe(true);
    expect(state.user?.auth_provider).toBe('feishu');
    expect(state.user?.last_feishu_sync).toBeDefined();
  });

  test('should handle clearFeishuTokens', () => {
    const tokens = {
      feishu_access_token: 'test_token',
      feishu_refresh_token: 'refresh_token',
      feishu_expires_at: 1234567890
    };

    store.dispatch(setFeishuTokens(tokens));
    store.dispatch(clearFeishuTokens());

    const state = store.getState().auth;
    expect(state.feishu_access_token).toBeUndefined();
    expect(state.feishu_refresh_token).toBeUndefined();
    expect(state.feishu_expires_at).toBeUndefined();
  });

  test('selectors should work correctly', () => {
    const user = {
      id: '1',
      username: 'testuser',
      email: 'test@example.com',
      full_name: 'Test User',
      roles: ['user'],
      permissions: [],
      auth_provider: 'feishu' as const,
      feishu_info: {
        user_id: 'feishu_123',
        name: 'Test User',
        email: 'test@company.com'
      }
    };

    store.dispatch(setUser(user));

    const state = store.getState();
    expect(selectIsFeishuUser(state)).toBe(true);
    expect(selectFeishuInfo(state)).toEqual(user.feishu_info);
  });
});
```

### ä»»åŠ¡4ï¼šå‰ç«¯å®Œæ•´é›†æˆå’Œæµ‹è¯• (1å¤©)

#### 4.1 åˆ›å»ºé£ä¹¦APIå®¢æˆ·ç«¯
```typescript
// frontend/src/api/feishuApi.ts

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { RootState } from '../store';

interface GetAuthorizationUrlRequest {
  state?: string;
}

interface GetAuthorizationUrlResponse {
  authorization_url: string;
  state: string;
}

interface HandleCallbackRequest {
  code: string;
  state?: string;
}

interface HandleCallbackResponse {
  access_token: string;
  refresh_token: string;
  user: {
    id: string;
    username: string;
    email: string;
    full_name: string;
    avatar_url?: string;
    roles: string[];
    permissions: string[];
    auth_provider: 'feishu';
    feishu_info: {
      user_id: string;
      name: string;
      en_name?: string;
      email?: string;
      avatar_url?: string;
      mobile?: string;
      department_ids?: string[];
      union_id?: string;
      open_id?: string;
    };
  };
}

interface RefreshTokensResponse {
  access_token: string;
  refresh_token: string;
}

interface ValidateAccessResponse {
  valid: boolean;
  user?: any;
}

export const feishuApi = createApi({
  reducerPath: 'feishuApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/v1/feishu-auth',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.access_token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['FeishuAuth'],
  endpoints: (builder) => ({
    getAuthorizationUrl: builder.mutation<GetAuthorizationUrlResponse, GetAuthorizationUrlRequest>({
      query: (params) => ({
        url: '/authorize',
        method: 'GET',
        params,
      }),
    }),

    handleCallback: builder.mutation<HandleCallbackResponse, HandleCallbackRequest>({
      query: (data) => ({
        url: '/callback',
        method: 'POST',
        body: data,
      }),
    }),

    refreshTokens: builder.mutation<RefreshTokensResponse, void>({
      query: () => ({
        url: '/refresh-tokens',
        method: 'POST',
      }),
    }),

    validateAccess: builder.query<ValidateAccessResponse, void>({
      query: () => '/validate-access',
      providesTags: ['FeishuAuth'],
    }),

    // ç”¨æˆ·ä¿¡æ¯åŒæ­¥
    syncUserInfo: builder.mutation<{ success: boolean; message: string }, void>({
      query: () => ({
        url: '/sync-user-info',
        method: 'POST',
      }),
      invalidatesTags: ['FeishuAuth'],
    }),

    // è·å–é£ä¹¦ç”¨æˆ·è¯¦ç»†ä¿¡æ¯
    getFeishuUserInfo: builder.query<any, void>({
      query: () => '/user-info',
      providesTags: ['FeishuAuth'],
    }),
  }),
});

export const {
  useGetAuthorizationUrlMutation,
  useHandleCallbackMutation,
  useRefreshTokensMutation,
  useValidateAccessQuery,
  useSyncUserInfoMutation,
  useGetFeishuUserInfoQuery,
} = feishuApi;

// å¯¼å‡ºéHookç‰ˆæœ¬çš„APIï¼Œä¾›useFeishuAuth Hookä½¿ç”¨
export const feishuApiEndpoints = {
  getAuthorizationUrl: async (params: GetAuthorizationUrlRequest): Promise<GetAuthorizationUrlResponse> => {
    const response = await fetch(`/api/v1/feishu-auth/authorize?${new URLSearchParams(params as any)}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to get authorization URL');
    }

    return response.json();
  },

  handleCallback: async (data: HandleCallbackRequest): Promise<HandleCallbackResponse> => {
    const response = await fetch('/api/v1/feishu-auth/callback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to handle callback');
    }

    return response.json();
  },

  refreshTokens: async (): Promise<RefreshTokensResponse> => {
    const token = localStorage.getItem('refresh_token');
    const response = await fetch('/api/v1/feishu-auth/refresh-tokens', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to refresh tokens');
    }

    return response.json();
  },

  validateAccess: async (): Promise<ValidateAccessResponse> => {
    const token = localStorage.getItem('access_token');
    const response = await fetch('/api/v1/feishu-auth/validate-access', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to validate access');
    }

    return response.json();
  },
};
```

#### 4.2 é›†æˆåˆ°ä¸»åº”ç”¨
```typescript
// frontend/src/store/index.ts - æ‰©å±•ç°æœ‰storeé…ç½®

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authSlice from './slices/authSlice';
import { feishuApi } from '../api/feishuApi';
// ... å…¶ä»–ç°æœ‰APIå’Œsliceå¯¼å…¥

export const store = configureStore({
  reducer: {
    auth: authSlice,
    // ... å…¶ä»–ç°æœ‰reducer

    // æ·»åŠ feishuApi reducer
    [feishuApi.reducerPath]: feishuApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [
          // RTK Queryçš„å†…éƒ¨actions
          feishuApi.util.getRunningQueriesThunk.fulfilled.type,
          feishuApi.util.getRunningQueriesThunk.pending.type,
          feishuApi.util.getRunningQueriesThunk.rejected.type,
        ],
      },
    })
      // æ·»åŠ ç°æœ‰çš„middleware
      .concat(feishuApi.middleware),
});

// å¯ç”¨RTK Queryçš„è‡ªåŠ¨é‡æ–°è·å–å’Œç¼“å­˜è¡Œä¸º
setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

#### 4.3 åˆ›å»ºç«¯åˆ°ç«¯æµ‹è¯•
```typescript
// frontend/src/tests/e2e/feishuLogin.test.ts

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { test, expect, Page } from '@playwright/test';

// æ¨¡æ‹Ÿé£ä¹¦OAuthæµç¨‹çš„ç«¯åˆ°ç«¯æµ‹è¯•
test.describe('Feishu Login Integration', () => {
  let page: Page;

  test.beforeEach(async ({ browser }) => {
    page = await browser.newPage();

    // ç›‘å¬ç½‘ç»œè¯·æ±‚ä»¥éªŒè¯APIè°ƒç”¨
    await page.route('/api/v1/feishu-auth/**', async route => {
      // æ¨¡æ‹Ÿåç«¯å“åº”
      const url = route.request().url();

      if (url.includes('/authorize')) {
        await route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify({
            authorization_url: 'https://open.feishu.cn/open-apis/authen/v1/index?app_id=test&redirect_uri=http://localhost:3000/auth/feishu/callback&response_type=code&scope=user:read&state=test_state',
            state: 'test_state'
          })
        });
      } else if (url.includes('/callback')) {
        await route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify({
            access_token: 'test_access_token',
            refresh_token: 'test_refresh_token',
            user: {
              id: '1',
              username: 'testuser',
              email: 'test@company.com',
              full_name: 'Test User',
              avatar_url: 'https://example.com/avatar.jpg',
              roles: ['user'],
              permissions: ['read:dashboard'],
              auth_provider: 'feishu',
              feishu_info: {
                user_id: 'ou_123456',
                name: 'Test User',
                en_name: 'Test User',
                email: 'test@company.com',
                avatar_url: 'https://example.com/avatar.jpg'
              }
            }
          })
        });
      }
    });
  });

  test('should display Feishu login button on login page', async () => {
    await page.goto('/auth/login');

    // éªŒè¯é£ä¹¦ç™»å½•æŒ‰é’®å­˜åœ¨
    const feishuButton = page.locator('button:has-text("Login with Feishu")');
    await expect(feishuButton).toBeVisible();

    // éªŒè¯æŒ‰é’®æ ·å¼
    await expect(feishuButton).toHaveCSS('border-color', 'rgb(0, 212, 170)');
  });

  test('should handle Feishu login flow', async () => {
    await page.goto('/auth/login');

    // ç‚¹å‡»é£ä¹¦ç™»å½•æŒ‰é’®
    const feishuButton = page.locator('button:has-text("Login with Feishu")');
    await feishuButton.click();

    // éªŒè¯æŒ‰é’®æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    await expect(page.locator('button:has-text("Connecting to Feishu")')).toBeVisible();

    // ç”±äºæˆ‘ä»¬mockäº†APIå“åº”ï¼Œé¡µé¢åº”è¯¥é‡å®šå‘åˆ°é£ä¹¦æˆæƒé¡µé¢
    // åœ¨çœŸå®ç¯å¢ƒä¸­ï¼Œè¿™é‡Œä¼šè·³è½¬åˆ°é£ä¹¦çš„æˆæƒé¡µé¢
    // ä½†åœ¨æµ‹è¯•ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿè¿™ä¸ªæµç¨‹

    // éªŒè¯sessionStorageä¸­å­˜å‚¨äº†state
    const storedState = await page.evaluate(() => sessionStorage.getItem('feishu_oauth_state'));
    expect(storedState).toBeTruthy();
  });

  test('should handle callback page correctly', async () => {
    // æ¨¡æ‹Ÿä»é£ä¹¦å›è°ƒçš„URL
    await page.goto('/auth/feishu/callback?code=test_code&state=test_state');

    // åˆå§‹åº”è¯¥æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    await expect(page.locator('text=Processing Feishu login')).toBeVisible();

    // ç­‰å¾…å¤„ç†å®Œæˆï¼Œåº”è¯¥æ˜¾ç¤ºæˆåŠŸçŠ¶æ€
    await expect(page.locator('text=Login Successful!')).toBeVisible();

    // åº”è¯¥æœ‰é‡å®šå‘æŒ‰é’®
    const dashboardButton = page.locator('button:has-text("Go to Dashboard")');
    await expect(dashboardButton).toBeVisible();
  });

  test('should handle callback error correctly', async () => {
    // æ¨¡æ‹Ÿé£ä¹¦å›è°ƒé”™è¯¯
    await page.goto('/auth/feishu/callback?error=access_denied&error_description=User%20cancelled');

    // åº”è¯¥æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
    await expect(page.locator('text=Login Failed')).toBeVisible();
    await expect(page.locator('text=User cancelled')).toBeVisible();

    // åº”è¯¥æœ‰é‡è¯•æŒ‰é’®
    const retryButton = page.locator('button:has-text("Try Again")');
    await expect(retryButton).toBeVisible();
  });

  test('should display user info correctly after login', async () => {
    // å…ˆæ¨¡æ‹Ÿå·²ç™»å½•çŠ¶æ€
    await page.evaluate(() => {
      localStorage.setItem('access_token', 'test_token');
      localStorage.setItem('user', JSON.stringify({
        id: '1',
        username: 'testuser',
        email: 'test@company.com',
        full_name: 'Test User',
        avatar_url: 'https://example.com/avatar.jpg',
        roles: ['user'],
        permissions: ['read:dashboard'],
        auth_provider: 'feishu',
        feishu_info: {
          user_id: 'ou_123456',
          name: 'Test User',
          en_name: 'Test User',
          email: 'test@company.com',
          avatar_url: 'https://example.com/avatar.jpg'
        }
      }));
    });

    await page.goto('/dashboard');

    // éªŒè¯ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º
    await expect(page.locator('text=Test User')).toBeVisible();

    // éªŒè¯é£ä¹¦æ ‡ç­¾æ˜¾ç¤º
    await expect(page.locator('.ant-tag:has-text("Feishu")')).toBeVisible();
  });
});
```

**âœ… é˜¶æ®µæµ‹è¯•4ï¼šå®Œæ•´é›†æˆéªŒè¯**
```bash
# å‰ç«¯æµ‹è¯•è„šæœ¬
# frontend/scripts/test-feishu-integration.sh

#!/bin/bash

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

echo "ğŸš€ Running Feishu Frontend Integration Tests..."

# ç¡®ä¿åœ¨æ­£ç¡®çš„ç›®å½•
cd "$(dirname "$0")/.."

# å®‰è£…ä¾èµ–
echo "ğŸ“¦ Installing dependencies..."
npm install

# è¿è¡Œå•å…ƒæµ‹è¯•
echo "ğŸ§ª Running unit tests..."
npm run test -- --testPathPattern="feishu|Feishu" --coverage

# è¿è¡Œç±»å‹æ£€æŸ¥
echo "ğŸ” Running TypeScript checks..."
npm run type-check

# è¿è¡Œlinting
echo "âœ¨ Running ESLint..."
npm run lint

# æ„å»ºæ£€æŸ¥
echo "ğŸ—ï¸ Running build check..."
npm run build

# å¦‚æœå®‰è£…äº†playwrightï¼Œè¿è¡ŒE2Eæµ‹è¯•
if command -v npx playwright &> /dev/null; then
    echo "ğŸ­ Running E2E tests..."
    npx playwright test --grep="Feishu"
else
    echo "âš ï¸  Playwright not found, skipping E2E tests"
fi

echo "âœ… Feishu Frontend Integration Tests Completed!"

# è¿è¡Œç¤ºä¾‹å‘½ä»¤
echo ""
echo "ğŸ“‹ Manual Testing Checklist:"
echo "1. Start the development server: npm run dev"
echo "2. Navigate to /auth/login"
echo "3. Verify Feishu login button is displayed"
echo "4. Click the button and verify redirect behavior"
echo "5. Test callback page with mock parameters"
echo "6. Verify user profile displays Feishu information"
echo "7. Test error handling scenarios"
```

## ğŸ¯ é˜¶æ®µäº¤ä»˜ç‰©

### æ–‡æ¡£è¾“å‡º
- [ ] Reactç»„ä»¶å¼€å‘æ–‡æ¡£
- [ ] å‰ç«¯é›†æˆæµ‹è¯•æŠ¥å‘Š
- [ ] ç”¨æˆ·ä½“éªŒè®¾è®¡è¯´æ˜
- [ ] é—®é¢˜æ’æŸ¥æŒ‡å—

### ä»£ç è¾“å‡º
- [ ] 5ä¸ªæ ¸å¿ƒReactç»„ä»¶
- [ ] 2ä¸ªè‡ªå®šä¹‰Hook
- [ ] 1ä¸ªRedux Sliceæ‰©å±•
- [ ] 1ä¸ªAPIå®¢æˆ·ç«¯
- [ ] å®Œæ•´çš„æµ‹è¯•å¥—ä»¶ï¼ˆå•å…ƒæµ‹è¯• + E2Eæµ‹è¯•ï¼‰

### åŠŸèƒ½éªŒè¯
- [ ] é£ä¹¦ç™»å½•æŒ‰é’®æ­£å¸¸æ˜¾ç¤ºå’Œäº¤äº’
- [ ] OAuthå›è°ƒå¤„ç†å®Œæ•´æµç¨‹
- [ ] ç”¨æˆ·ä¿¡æ¯æ­£ç¡®æ˜¾ç¤ºå’ŒåŒæ­¥
- [ ] é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ
- [ ] çŠ¶æ€ç®¡ç†å’Œè·¯ç”±é›†æˆ
- [ ] è·¨æµè§ˆå™¨å…¼å®¹æ€§éªŒè¯

## ğŸ“ˆ æˆåŠŸæ ‡å‡†

1. **åŠŸèƒ½å®Œæ•´æ€§**ï¼šæ‰€æœ‰é£ä¹¦ç™»å½•ç›¸å…³åŠŸèƒ½æ­£å¸¸å·¥ä½œ
2. **ç”¨æˆ·ä½“éªŒ**ï¼šç™»å½•æµç¨‹é¡ºç•…ï¼Œé”™è¯¯å¤„ç†å‹å¥½
3. **ä»£ç è´¨é‡**ï¼šé€šè¿‡æ‰€æœ‰æµ‹è¯•ï¼Œç¬¦åˆé¡¹ç›®ç¼–ç è§„èŒƒ
4. **æ€§èƒ½è¡¨ç°**ï¼šç™»å½•å“åº”æ—¶é—´ < 3ç§’
5. **å®‰å…¨æ€§**ï¼šCSRFé˜²æŠ¤ã€çŠ¶æ€éªŒè¯ã€ä»¤ç‰Œç®¡ç†å®‰å…¨
6. **å…¼å®¹æ€§**ï¼šæ”¯æŒä¸»æµæµè§ˆå™¨ï¼Œå“åº”å¼è®¾è®¡

---

**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š3-4å¤©
**å…³é”®ä¾èµ–**ï¼šç¬¬1ã€2é˜¶æ®µå®Œæˆï¼Œåç«¯APIå¯ç”¨
**é£é™©æ§åˆ¶**ï¼šå……åˆ†çš„æµ‹è¯•è¦†ç›–ï¼Œè¯¦ç»†çš„é”™è¯¯å¤„ç†
**ä¸‹ä¸€é˜¶æ®µ**ï¼šç¬¬4é˜¶æ®µ - é«˜çº§åŠŸèƒ½å’Œç”Ÿäº§éƒ¨ç½²