# 飞书登录集成开发计划 - 第4阶段：高级功能和系统优化

## 📋 阶段概述

**目标**：实现监控告警系统、性能优化、安全加固等高级功能
**预估时间**：2-3天
**优先级**：中
**依赖**：第1、2、3阶段完成

## 🎯 阶段目标

- [ ] 实现监控告警系统
- [ ] 性能优化和缓存策略
- [ ] 安全加固和审计日志
- [ ] 异常处理和降级机制
- [ ] API限流和防护
- [ ] 健康检查和诊断工具

## 📝 详细任务清单

### 任务1：监控告警系统 (1天)

#### 1.1 创建飞书认证监控服务
```python
# app/services/feishu/monitor/feishu_monitor.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import logging
import time
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
from flask import current_app

from app.extensions import db, cache
from app.models.feishu.metrics import FeishuMetrics
from app.services.notification.service.notification import NotificationService

logger = logging.getLogger(__name__)

class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

@dataclass
class MetricData:
    name: str
    value: float
    timestamp: datetime
    tags: Dict[str, str] = None

@dataclass
class AlertRule:
    name: str
    metric: str
    threshold: float
    comparison: str  # gt, lt, gte, lte, eq
    level: AlertLevel
    description: str
    enabled: bool = True

class FeishuMonitorService:
    """飞书认证监控服务"""

    # 缓存键
    METRICS_CACHE_PREFIX = "feishu_metrics"
    ALERT_CACHE_PREFIX = "feishu_alerts"

    # 监控指标
    METRICS_TTL = 300  # 5分钟
    ALERT_COOLDOWN = 1800  # 30分钟告警冷却

    def __init__(self):
        self.notification_service = NotificationService()
        self.alert_rules = self._load_alert_rules()

    def _load_alert_rules(self) -> List[AlertRule]:
        """加载告警规则配置"""
        return [
            AlertRule(
                name="feishu_login_failure_rate",
                metric="login_failure_rate",
                threshold=0.1,  # 失败率超过10%
                comparison="gt",
                level=AlertLevel.WARNING,
                description="Feishu login failure rate is too high"
            ),
            AlertRule(
                name="feishu_api_response_time",
                metric="api_response_time_avg",
                threshold=5000,  # 响应时间超过5秒
                comparison="gt",
                level=AlertLevel.ERROR,
                description="Feishu API response time is too slow"
            ),
            AlertRule(
                name="feishu_token_refresh_failure",
                metric="token_refresh_failure_rate",
                threshold=0.05,  # 令牌刷新失败率超过5%
                comparison="gt",
                level=AlertLevel.WARNING,
                description="Feishu token refresh failure rate is high"
            ),
            AlertRule(
                name="feishu_user_sync_failure",
                metric="user_sync_failure_rate",
                threshold=0.02,  # 用户同步失败率超过2%
                comparison="gt",
                level=AlertLevel.ERROR,
                description="Feishu user sync failure rate is high"
            ),
            AlertRule(
                name="feishu_api_quota_usage",
                metric="api_quota_usage_rate",
                threshold=0.8,  # API配额使用率超过80%
                comparison="gt",
                level=AlertLevel.WARNING,
                description="Feishu API quota usage is approaching limit"
            )
        ]

    def record_metric(self, metric: MetricData) -> None:
        """记录监控指标"""
        try:
            # 存储到数据库
            feishu_metric = FeishuMetrics(
                metric_name=metric.name,
                metric_value=metric.value,
                timestamp=metric.timestamp,
                tags=metric.tags or {}
            )
            db.session.add(feishu_metric)
            db.session.commit()

            # 存储到缓存（用于实时查询）
            cache_key = f"{self.METRICS_CACHE_PREFIX}:{metric.name}"
            cache.zadd(cache_key, {
                str(metric.timestamp.timestamp()): metric.value
            })
            cache.expire(cache_key, self.METRICS_TTL)

            # 检查告警规则
            self._check_alert_rules(metric)

            logger.debug(f"Recorded metric: {metric.name}={metric.value}")

        except Exception as e:
            logger.error(f"Failed to record metric {metric.name}: {e}")

    def _check_alert_rules(self, metric: MetricData) -> None:
        """检查告警规则"""
        for rule in self.alert_rules:
            if not rule.enabled or rule.metric != metric.name:
                continue

            try:
                # 检查是否满足告警条件
                if self._evaluate_rule(rule, metric.value):
                    self._trigger_alert(rule, metric)

            except Exception as e:
                logger.error(f"Failed to check alert rule {rule.name}: {e}")

    def _evaluate_rule(self, rule: AlertRule, value: float) -> bool:
        """评估告警规则"""
        if rule.comparison == "gt":
            return value > rule.threshold
        elif rule.comparison == "lt":
            return value < rule.threshold
        elif rule.comparison == "gte":
            return value >= rule.threshold
        elif rule.comparison == "lte":
            return value <= rule.threshold
        elif rule.comparison == "eq":
            return value == rule.threshold
        else:
            return False

    def _trigger_alert(self, rule: AlertRule, metric: MetricData) -> None:
        """触发告警"""
        # 检查告警冷却期
        cooldown_key = f"{self.ALERT_CACHE_PREFIX}:cooldown:{rule.name}"
        if cache.get(cooldown_key):
            return

        # 发送告警通知
        alert_message = {
            "title": f"Feishu Auth Alert: {rule.name}",
            "level": rule.level.value,
            "description": rule.description,
            "metric_name": metric.name,
            "metric_value": metric.value,
            "threshold": rule.threshold,
            "timestamp": metric.timestamp.isoformat(),
            "tags": metric.tags
        }

        self.notification_service.send_alert(alert_message)

        # 设置冷却期
        cache.setex(cooldown_key, self.ALERT_COOLDOWN, "1")

        logger.warning(f"Alert triggered: {rule.name}, value={metric.value}")

    def get_metrics_summary(self, hours: int = 24) -> Dict[str, Any]:
        """获取指标摘要"""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=hours)

        try:
            # 从数据库查询指标数据
            metrics = db.session.query(FeishuMetrics).filter(
                FeishuMetrics.timestamp >= start_time,
                FeishuMetrics.timestamp <= end_time
            ).all()

            # 聚合统计
            summary = {}
            for metric in metrics:
                metric_name = metric.metric_name
                if metric_name not in summary:
                    summary[metric_name] = {
                        "count": 0,
                        "sum": 0,
                        "min": float('inf'),
                        "max": float('-inf'),
                        "avg": 0,
                        "latest": None
                    }

                value = metric.metric_value
                summary[metric_name]["count"] += 1
                summary[metric_name]["sum"] += value
                summary[metric_name]["min"] = min(summary[metric_name]["min"], value)
                summary[metric_name]["max"] = max(summary[metric_name]["max"], value)
                summary[metric_name]["latest"] = metric.timestamp

            # 计算平均值
            for metric_name in summary:
                if summary[metric_name]["count"] > 0:
                    summary[metric_name]["avg"] = summary[metric_name]["sum"] / summary[metric_name]["count"]

            return summary

        except Exception as e:
            logger.error(f"Failed to get metrics summary: {e}")
            return {}

    def get_health_status(self) -> Dict[str, Any]:
        """获取健康状态"""
        try:
            status = {
                "status": "healthy",
                "timestamp": datetime.utcnow().isoformat(),
                "checks": {}
            }

            # 检查数据库连接
            try:
                db.session.execute("SELECT 1")
                status["checks"]["database"] = {"status": "healthy"}
            except Exception as e:
                status["checks"]["database"] = {"status": "unhealthy", "error": str(e)}
                status["status"] = "unhealthy"

            # 检查缓存连接
            try:
                cache.ping()
                status["checks"]["cache"] = {"status": "healthy"}
            except Exception as e:
                status["checks"]["cache"] = {"status": "unhealthy", "error": str(e)}
                status["status"] = "unhealthy"

            # 检查最近的指标数据
            recent_metrics = self.get_metrics_summary(hours=1)
            if recent_metrics:
                status["checks"]["metrics"] = {"status": "healthy", "count": len(recent_metrics)}
            else:
                status["checks"]["metrics"] = {"status": "warning", "message": "No recent metrics"}

            return status

        except Exception as e:
            logger.error(f"Failed to get health status: {e}")
            return {
                "status": "error",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }

# 监控装饰器
def monitor_feishu_operation(operation_name: str):
    """飞书操作监控装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            monitor = FeishuMonitorService()

            try:
                result = func(*args, **kwargs)

                # 记录成功指标
                duration = (time.time() - start_time) * 1000  # 毫秒
                monitor.record_metric(MetricData(
                    name=f"{operation_name}_duration",
                    value=duration,
                    timestamp=datetime.utcnow(),
                    tags={"status": "success", "operation": operation_name}
                ))

                monitor.record_metric(MetricData(
                    name=f"{operation_name}_count",
                    value=1,
                    timestamp=datetime.utcnow(),
                    tags={"status": "success", "operation": operation_name}
                ))

                return result

            except Exception as e:
                # 记录失败指标
                monitor.record_metric(MetricData(
                    name=f"{operation_name}_count",
                    value=1,
                    timestamp=datetime.utcnow(),
                    tags={"status": "error", "operation": operation_name, "error": str(e)}
                ))

                raise

        return wrapper
    return decorator
```

#### 1.2 创建指标数据模型
```python
# app/models/feishu/metrics.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

from sqlalchemy import Column, String, Float, DateTime, JSON, Index
from app.extensions import db
from app.models.base import TimestampMixin

class FeishuMetrics(db.Model, TimestampMixin):
    """飞书认证指标模型"""

    __tablename__ = 'feishu_metrics'

    id = Column(db.Integer, primary_key=True)
    metric_name = Column(String(100), nullable=False, comment='指标名称')
    metric_value = Column(Float, nullable=False, comment='指标值')
    timestamp = Column(DateTime, nullable=False, comment='时间戳')
    tags = Column(JSON, default={}, comment='标签数据')

    # 索引
    __table_args__ = (
        Index('idx_feishu_metrics_name_time', 'metric_name', 'timestamp'),
        Index('idx_feishu_metrics_timestamp', 'timestamp'),
        {'comment': '飞书认证指标表'}
    )

    def __repr__(self):
        return f'<FeishuMetrics {self.metric_name}={self.metric_value}>'

class FeishuOperationLog(db.Model, TimestampMixin):
    """飞书操作日志模型"""

    __tablename__ = 'feishu_operation_logs'

    id = Column(db.Integer, primary_key=True)
    operation_type = Column(String(50), nullable=False, comment='操作类型')
    user_id = Column(String(50), comment='用户ID')
    feishu_user_id = Column(String(100), comment='飞书用户ID')
    operation_data = Column(JSON, default={}, comment='操作数据')
    result_status = Column(String(20), nullable=False, comment='结果状态')
    error_message = Column(String(500), comment='错误信息')
    ip_address = Column(String(45), comment='IP地址')
    user_agent = Column(String(500), comment='用户代理')

    # 索引
    __table_args__ = (
        Index('idx_feishu_logs_type_time', 'operation_type', 'created_at'),
        Index('idx_feishu_logs_user', 'user_id'),
        Index('idx_feishu_logs_feishu_user', 'feishu_user_id'),
        {'comment': '飞书操作日志表'}
    )

    def __repr__(self):
        return f'<FeishuOperationLog {self.operation_type}:{self.result_status}>'
```

**✅ 阶段测试1：监控系统验证**
```python
# scripts/test_feishu_monitoring.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import sys
import os
import time
from datetime import datetime

# 添加项目路径
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from app import create_app
from app.services.feishu.monitor.feishu_monitor import FeishuMonitorService, MetricData

def test_monitoring_system():
    """测试监控系统"""
    app = create_app()

    with app.app_context():
        monitor = FeishuMonitorService()

        print("🔍 Testing Feishu Monitoring System...")

        # 测试指标记录
        print("📊 Testing metric recording...")
        test_metrics = [
            MetricData("login_success_count", 10, datetime.utcnow()),
            MetricData("login_failure_count", 2, datetime.utcnow()),
            MetricData("api_response_time_avg", 1500, datetime.utcnow()),
            MetricData("token_refresh_count", 5, datetime.utcnow()),
        ]

        for metric in test_metrics:
            monitor.record_metric(metric)
            print(f"  ✅ Recorded: {metric.name} = {metric.value}")

        # 等待一秒钟让数据生效
        time.sleep(1)

        # 测试指标摘要
        print("📈 Testing metrics summary...")
        summary = monitor.get_metrics_summary(hours=1)
        print(f"  📊 Metrics summary: {len(summary)} metrics")
        for name, data in summary.items():
            print(f"    - {name}: avg={data['avg']:.2f}, count={data['count']}")

        # 测试健康检查
        print("🏥 Testing health check...")
        health = monitor.get_health_status()
        print(f"  🏥 Health status: {health['status']}")
        for check, result in health['checks'].items():
            print(f"    - {check}: {result['status']}")

        # 测试告警规则
        print("🚨 Testing alert rules...")
        # 触发一个告警（高失败率）
        alert_metric = MetricData("login_failure_rate", 0.15, datetime.utcnow())
        monitor.record_metric(alert_metric)
        print(f"  🚨 Triggered alert with failure rate: {alert_metric.value}")

        print("✅ Monitoring system test completed!")

if __name__ == "__main__":
    test_monitoring_system()
```

### 任务2：性能优化和缓存策略 (0.5天)

#### 2.1 优化飞书API调用性能
```python
# app/services/feishu/performance/cache_optimizer.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import asyncio
import json
import hashlib
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, Callable
from functools import wraps

from app.extensions import cache
from app.services.feishu.monitor.feishu_monitor import monitor_feishu_operation

class FeishuCacheOptimizer:
    """飞书API缓存优化器"""

    # 缓存配置
    USER_INFO_TTL = 3600  # 用户信息缓存1小时
    APP_TOKEN_TTL = 7200  # 应用令牌缓存2小时
    DEPT_INFO_TTL = 1800  # 部门信息缓存30分钟
    RATE_LIMIT_TTL = 60   # 限流信息缓存1分钟

    @classmethod
    def cache_key(cls, prefix: str, *args, **kwargs) -> str:
        """生成缓存键"""
        key_data = f"{prefix}:{':'.join(map(str, args))}"
        if kwargs:
            key_data += f":{hashlib.md5(json.dumps(kwargs, sort_keys=True).encode()).hexdigest()[:8]}"
        return key_data

    @classmethod
    def cached_user_info(cls, ttl: int = USER_INFO_TTL):
        """用户信息缓存装饰器"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            @monitor_feishu_operation("cached_user_info")
            def wrapper(self, user_id: str, *args, **kwargs):
                cache_key = cls.cache_key("feishu_user_info", user_id)

                # 尝试从缓存获取
                cached_result = cache.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)

                # 调用原函数
                result = func(self, user_id, *args, **kwargs)

                # 存储到缓存
                if result:
                    cache.setex(cache_key, ttl, json.dumps(result, default=str))

                return result
            return wrapper
        return decorator

    @classmethod
    def cached_app_token(cls, ttl: int = APP_TOKEN_TTL):
        """应用令牌缓存装饰器"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            @monitor_feishu_operation("cached_app_token")
            def wrapper(self, app_id: str, app_secret: str, *args, **kwargs):
                cache_key = cls.cache_key("feishu_app_token", app_id)

                # 尝试从缓存获取
                cached_result = cache.get(cache_key)
                if cached_result:
                    return cached_result

                # 调用原函数
                result = func(self, app_id, app_secret, *args, **kwargs)

                # 存储到缓存（提前10分钟过期）
                if result:
                    cache.setex(cache_key, ttl - 600, result)

                return result
            return wrapper
        return decorator

    @classmethod
    def rate_limited(cls, max_calls: int = 100, window: int = 60):
        """API限流装饰器"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            def wrapper(*args, **kwargs):
                # 生成限流键（基于函数名和参数）
                rate_key = cls.cache_key("rate_limit", func.__name__)

                # 检查当前调用次数
                current_calls = cache.get(rate_key) or 0
                if int(current_calls) >= max_calls:
                    raise Exception(f"Rate limit exceeded: {max_calls} calls per {window} seconds")

                # 增加调用计数
                pipe = cache.pipeline()
                pipe.incr(rate_key)
                pipe.expire(rate_key, window)
                pipe.execute()

                return func(*args, **kwargs)
            return wrapper
        return decorator

    @classmethod
    def batch_cache_invalidation(cls, patterns: list):
        """批量缓存失效"""
        try:
            for pattern in patterns:
                # 使用Redis SCAN命令查找匹配的键
                cursor = 0
                while True:
                    cursor, keys = cache.scan(cursor, match=pattern, count=100)
                    if keys:
                        cache.delete(*keys)
                    if cursor == 0:
                        break
        except Exception as e:
            print(f"Cache invalidation error: {e}")

    @classmethod
    def warmup_cache(cls, user_ids: list):
        """预热缓存"""
        # 这里可以批量预加载常用的用户信息
        pass

# 应用缓存装饰器到飞书服务
def apply_cache_optimizations():
    """应用缓存优化到飞书服务"""
    from app.services.feishu.service.feishu_auth import FeishuAuthService

    # 为关键方法添加缓存
    FeishuAuthService.get_app_access_token = FeishuCacheOptimizer.cached_app_token()(
        FeishuAuthService.get_app_access_token
    )

    FeishuAuthService.get_user_info = FeishuCacheOptimizer.cached_user_info()(
        FeishuAuthService.get_user_info
    )

    # 添加限流保护
    FeishuAuthService.get_user_access_token = FeishuCacheOptimizer.rate_limited(
        max_calls=50, window=60
    )(FeishuAuthService.get_user_access_token)
```

### 任务3：安全加固和审计日志 (1天)

#### 3.1 安全加固措施
```python
# app/services/feishu/security/security_enhancer.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import hmac
import hashlib
import secrets
import ipaddress
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from flask import request, current_app

from app.extensions import cache, db
from app.models.feishu.metrics import FeishuOperationLog

class FeishuSecurityEnhancer:
    """飞书安全增强器"""

    # 安全配置
    MAX_LOGIN_ATTEMPTS = 5
    LOCKOUT_DURATION = 3600  # 1小时
    ALLOWED_DOMAINS = []  # 从配置加载
    IP_WHITELIST = []     # 从配置加载

    @classmethod
    def verify_webhook_signature(cls, body: bytes, signature: str, secret: str) -> bool:
        """验证webhook签名"""
        try:
            expected_signature = hmac.new(
                secret.encode('utf-8'),
                body,
                hashlib.sha256
            ).hexdigest()

            return hmac.compare_digest(signature, expected_signature)
        except Exception:
            return False

    @classmethod
    def generate_secure_state(cls) -> str:
        """生成安全的state参数"""
        timestamp = str(int(datetime.utcnow().timestamp()))
        random_part = secrets.token_urlsafe(32)
        return f"{timestamp}:{random_part}"

    @classmethod
    def validate_state(cls, state: str, max_age: int = 600) -> bool:
        """验证state参数"""
        try:
            if ':' not in state:
                return False

            timestamp_str, _ = state.split(':', 1)
            timestamp = int(timestamp_str)

            # 检查时间有效性
            current_time = int(datetime.utcnow().timestamp())
            return (current_time - timestamp) <= max_age
        except (ValueError, TypeError):
            return False

    @classmethod
    def check_rate_limit(cls, identifier: str, max_attempts: int = 10, window: int = 300) -> bool:
        """检查速率限制"""
        key = f"rate_limit:feishu:{identifier}"

        try:
            current_count = cache.get(key) or 0
            if int(current_count) >= max_attempts:
                return False

            # 增加计数
            pipe = cache.pipeline()
            pipe.incr(key)
            pipe.expire(key, window)
            pipe.execute()

            return True
        except Exception:
            return True  # 缓存故障时允许通过

    @classmethod
    def log_security_event(cls, event_type: str, details: Dict[str, Any], level: str = 'info'):
        """记录安全事件"""
        try:
            log_entry = FeishuOperationLog(
                operation_type=f"security_{event_type}",
                operation_data={
                    'event_type': event_type,
                    'details': details,
                    'level': level,
                    'timestamp': datetime.utcnow().isoformat()
                },
                result_status=level,
                ip_address=cls._get_client_ip(),
                user_agent=request.headers.get('User-Agent', '')[:500]
            )

            db.session.add(log_entry)
            db.session.commit()

        except Exception as e:
            current_app.logger.error(f"Failed to log security event: {e}")

    @classmethod
    def check_ip_whitelist(cls, ip: str) -> bool:
        """检查IP白名单"""
        if not cls.IP_WHITELIST:
            return True  # 未配置白名单时允许所有IP

        try:
            client_ip = ipaddress.ip_address(ip)
            for allowed_ip in cls.IP_WHITELIST:
                if client_ip in ipaddress.ip_network(allowed_ip, strict=False):
                    return True
            return False
        except ValueError:
            return False

    @classmethod
    def validate_email_domain(cls, email: str) -> bool:
        """验证邮箱域名"""
        if not cls.ALLOWED_DOMAINS:
            return True  # 未配置域名限制时允许所有域名

        try:
            domain = email.split('@')[1].lower()
            return domain in [d.lower() for d in cls.ALLOWED_DOMAINS]
        except (IndexError, AttributeError):
            return False

    @classmethod
    def check_login_attempts(cls, identifier: str) -> bool:
        """检查登录尝试次数"""
        key = f"login_attempts:feishu:{identifier}"

        try:
            attempts = cache.get(key) or 0
            return int(attempts) < cls.MAX_LOGIN_ATTEMPTS
        except Exception:
            return True

    @classmethod
    def record_login_attempt(cls, identifier: str, success: bool):
        """记录登录尝试"""
        key = f"login_attempts:feishu:{identifier}"

        try:
            if success:
                # 成功登录清除计数
                cache.delete(key)
            else:
                # 失败登录增加计数
                pipe = cache.pipeline()
                pipe.incr(key)
                pipe.expire(key, cls.LOCKOUT_DURATION)
                pipe.execute()
        except Exception:
            pass

    @classmethod
    def sanitize_user_data(cls, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """清理用户数据"""
        # 只保留安全的字段
        safe_fields = [
            'user_id', 'name', 'en_name', 'email', 'avatar_url',
            'mobile', 'department_ids', 'union_id', 'open_id'
        ]

        sanitized = {}
        for field in safe_fields:
            if field in user_data:
                value = user_data[field]
                # 基本清理
                if isinstance(value, str):
                    value = value.strip()[:500]  # 限制长度
                sanitized[field] = value

        return sanitized

    @classmethod
    def _get_client_ip(cls) -> str:
        """获取客户端IP地址"""
        # 检查代理头
        if request.headers.get('X-Forwarded-For'):
            return request.headers.get('X-Forwarded-For').split(',')[0].strip()
        elif request.headers.get('X-Real-IP'):
            return request.headers.get('X-Real-IP')
        else:
            return request.remote_addr or 'unknown'

# 安全装饰器
def require_valid_ip(func):
    """IP白名单验证装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        client_ip = FeishuSecurityEnhancer._get_client_ip()

        if not FeishuSecurityEnhancer.check_ip_whitelist(client_ip):
            FeishuSecurityEnhancer.log_security_event(
                'ip_blocked',
                {'ip': client_ip, 'endpoint': request.endpoint},
                'warning'
            )
            abort(403, 'Access denied from this IP address')

        return func(*args, **kwargs)
    return wrapper

def require_rate_limit(identifier_func: Callable = None):
    """速率限制装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 获取限流标识符
            if identifier_func:
                identifier = identifier_func()
            else:
                identifier = FeishuSecurityEnhancer._get_client_ip()

            if not FeishuSecurityEnhancer.check_rate_limit(identifier):
                FeishuSecurityEnhancer.log_security_event(
                    'rate_limit_exceeded',
                    {'identifier': identifier, 'endpoint': request.endpoint},
                    'warning'
                )
                abort(429, 'Rate limit exceeded')

            return func(*args, **kwargs)
        return wrapper
    return decorator
```

**✅ 阶段测试2：安全功能验证**
```python
# scripts/test_feishu_security.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import sys
import os
import time
from datetime import datetime

# 添加项目路径
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from app import create_app
from app.services.feishu.security.security_enhancer import FeishuSecurityEnhancer

def test_security_features():
    """测试安全功能"""
    app = create_app()

    with app.app_context():
        print("🔒 Testing Feishu Security Features...")

        # 测试state生成和验证
        print("🔑 Testing state generation and validation...")
        state = FeishuSecurityEnhancer.generate_secure_state()
        print(f"  Generated state: {state[:20]}...")

        # 验证有效state
        is_valid = FeishuSecurityEnhancer.validate_state(state)
        print(f"  ✅ State validation (valid): {is_valid}")

        # 验证无效state
        invalid_state = "invalid:state:format"
        is_invalid = FeishuSecurityEnhancer.validate_state(invalid_state)
        print(f"  ❌ State validation (invalid): {is_invalid}")

        # 测试速率限制
        print("⏱️ Testing rate limiting...")
        identifier = "test_user"

        # 多次调用检查限流
        for i in range(12):
            allowed = FeishuSecurityEnhancer.check_rate_limit(identifier, max_attempts=10)
            if i < 10:
                print(f"  ✅ Attempt {i+1}: {allowed}")
            else:
                print(f"  🚫 Attempt {i+1}: {allowed} (should be False)")

        # 测试邮箱域名验证
        print("📧 Testing email domain validation...")
        FeishuSecurityEnhancer.ALLOWED_DOMAINS = ['company.com', 'example.org']

        test_emails = [
            'user@company.com',
            'test@example.org',
            'hacker@evil.com',
            'invalid-email'
        ]

        for email in test_emails:
            is_valid = FeishuSecurityEnhancer.validate_email_domain(email)
            status = "✅" if is_valid else "❌"
            print(f"  {status} {email}: {is_valid}")

        # 测试用户数据清理
        print("🧹 Testing user data sanitization...")
        raw_data = {
            'user_id': 'ou_123456',
            'name': 'Test User',
            'email': 'test@company.com',
            'dangerous_field': '<script>alert("xss")</script>',
            'long_field': 'x' * 1000
        }

        sanitized = FeishuSecurityEnhancer.sanitize_user_data(raw_data)
        print(f"  Original fields: {list(raw_data.keys())}")
        print(f"  Sanitized fields: {list(sanitized.keys())}")
        print(f"  Long field truncated: {len(sanitized.get('long_field', '')) if 'long_field' in sanitized else 'Removed'}")

        print("✅ Security features test completed!")

if __name__ == "__main__":
    test_security_features()
```

## 🎯 阶段交付物

### 代码输出
- [ ] 监控告警系统（1个核心服务 + 2个数据模型）
- [ ] 性能优化组件（缓存优化器 + 装饰器集合）
- [ ] 安全加固模块（安全增强器 + 防护装饰器）
- [ ] 完整的测试脚本和验证工具

### 功能验证
- [ ] 监控指标正确收集和存储
- [ ] 告警规则触发和通知正常
- [ ] 缓存策略有效提升性能
- [ ] 安全措施正确阻止威胁
- [ ] 限流机制工作正常
- [ ] 审计日志完整记录

### 性能指标
- [ ] API响应时间优化30%以上
- [ ] 缓存命中率达到80%以上
- [ ] 监控数据延迟 < 5秒
- [ ] 安全检查性能影响 < 10ms

## 📈 成功标准

1. **监控完整性**：关键指标100%覆盖，告警及时准确
2. **性能提升**：响应时间和资源使用显著优化
3. **安全防护**：常见威胁有效防御，审计完整
4. **系统稳定性**：异常处理完善，降级机制可用
5. **运维友好**：监控面板清晰，故障排查便捷

---

**预计完成时间**：2-3天
**关键依赖**：第1、2、3阶段完成
**下一阶段**：第5阶段 - 生产部署和运维管理