# é£ä¹¦ç™»å½•é›†æˆå¼€å‘è®¡åˆ’ - ç¬¬4é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½å’Œç³»ç»Ÿä¼˜åŒ–

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

**ç›®æ ‡**ï¼šå®ç°ç›‘æ§å‘Šè­¦ç³»ç»Ÿã€æ€§èƒ½ä¼˜åŒ–ã€å®‰å…¨åŠ å›ºç­‰é«˜çº§åŠŸèƒ½
**é¢„ä¼°æ—¶é—´**ï¼š2-3å¤©
**ä¼˜å…ˆçº§**ï¼šä¸­
**ä¾èµ–**ï¼šç¬¬1ã€2ã€3é˜¶æ®µå®Œæˆ

## ğŸ¯ é˜¶æ®µç›®æ ‡

- [ ] å®ç°ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
- [ ] æ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥
- [ ] å®‰å…¨åŠ å›ºå’Œå®¡è®¡æ—¥å¿—
- [ ] å¼‚å¸¸å¤„ç†å’Œé™çº§æœºåˆ¶
- [ ] APIé™æµå’Œé˜²æŠ¤
- [ ] å¥åº·æ£€æŸ¥å’Œè¯Šæ–­å·¥å…·

## ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

### ä»»åŠ¡1ï¼šç›‘æ§å‘Šè­¦ç³»ç»Ÿ (1å¤©)

#### 1.1 åˆ›å»ºé£ä¹¦è®¤è¯ç›‘æ§æœåŠ¡
```python
# app/services/feishu/monitor/feishu_monitor.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import logging
import time
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
from flask import current_app

from app.extensions import db, cache
from app.models.feishu.metrics import FeishuMetrics
from app.services.notification.service.notification import NotificationService

logger = logging.getLogger(__name__)

class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

@dataclass
class MetricData:
    name: str
    value: float
    timestamp: datetime
    tags: Dict[str, str] = None

@dataclass
class AlertRule:
    name: str
    metric: str
    threshold: float
    comparison: str  # gt, lt, gte, lte, eq
    level: AlertLevel
    description: str
    enabled: bool = True

class FeishuMonitorService:
    """é£ä¹¦è®¤è¯ç›‘æ§æœåŠ¡"""

    # ç¼“å­˜é”®
    METRICS_CACHE_PREFIX = "feishu_metrics"
    ALERT_CACHE_PREFIX = "feishu_alerts"

    # ç›‘æ§æŒ‡æ ‡
    METRICS_TTL = 300  # 5åˆ†é’Ÿ
    ALERT_COOLDOWN = 1800  # 30åˆ†é’Ÿå‘Šè­¦å†·å´

    def __init__(self):
        self.notification_service = NotificationService()
        self.alert_rules = self._load_alert_rules()

    def _load_alert_rules(self) -> List[AlertRule]:
        """åŠ è½½å‘Šè­¦è§„åˆ™é…ç½®"""
        return [
            AlertRule(
                name="feishu_login_failure_rate",
                metric="login_failure_rate",
                threshold=0.1,  # å¤±è´¥ç‡è¶…è¿‡10%
                comparison="gt",
                level=AlertLevel.WARNING,
                description="Feishu login failure rate is too high"
            ),
            AlertRule(
                name="feishu_api_response_time",
                metric="api_response_time_avg",
                threshold=5000,  # å“åº”æ—¶é—´è¶…è¿‡5ç§’
                comparison="gt",
                level=AlertLevel.ERROR,
                description="Feishu API response time is too slow"
            ),
            AlertRule(
                name="feishu_token_refresh_failure",
                metric="token_refresh_failure_rate",
                threshold=0.05,  # ä»¤ç‰Œåˆ·æ–°å¤±è´¥ç‡è¶…è¿‡5%
                comparison="gt",
                level=AlertLevel.WARNING,
                description="Feishu token refresh failure rate is high"
            ),
            AlertRule(
                name="feishu_user_sync_failure",
                metric="user_sync_failure_rate",
                threshold=0.02,  # ç”¨æˆ·åŒæ­¥å¤±è´¥ç‡è¶…è¿‡2%
                comparison="gt",
                level=AlertLevel.ERROR,
                description="Feishu user sync failure rate is high"
            ),
            AlertRule(
                name="feishu_api_quota_usage",
                metric="api_quota_usage_rate",
                threshold=0.8,  # APIé…é¢ä½¿ç”¨ç‡è¶…è¿‡80%
                comparison="gt",
                level=AlertLevel.WARNING,
                description="Feishu API quota usage is approaching limit"
            )
        ]

    def record_metric(self, metric: MetricData) -> None:
        """è®°å½•ç›‘æ§æŒ‡æ ‡"""
        try:
            # å­˜å‚¨åˆ°æ•°æ®åº“
            feishu_metric = FeishuMetrics(
                metric_name=metric.name,
                metric_value=metric.value,
                timestamp=metric.timestamp,
                tags=metric.tags or {}
            )
            db.session.add(feishu_metric)
            db.session.commit()

            # å­˜å‚¨åˆ°ç¼“å­˜ï¼ˆç”¨äºå®æ—¶æŸ¥è¯¢ï¼‰
            cache_key = f"{self.METRICS_CACHE_PREFIX}:{metric.name}"
            cache.zadd(cache_key, {
                str(metric.timestamp.timestamp()): metric.value
            })
            cache.expire(cache_key, self.METRICS_TTL)

            # æ£€æŸ¥å‘Šè­¦è§„åˆ™
            self._check_alert_rules(metric)

            logger.debug(f"Recorded metric: {metric.name}={metric.value}")

        except Exception as e:
            logger.error(f"Failed to record metric {metric.name}: {e}")

    def _check_alert_rules(self, metric: MetricData) -> None:
        """æ£€æŸ¥å‘Šè­¦è§„åˆ™"""
        for rule in self.alert_rules:
            if not rule.enabled or rule.metric != metric.name:
                continue

            try:
                # æ£€æŸ¥æ˜¯å¦æ»¡è¶³å‘Šè­¦æ¡ä»¶
                if self._evaluate_rule(rule, metric.value):
                    self._trigger_alert(rule, metric)

            except Exception as e:
                logger.error(f"Failed to check alert rule {rule.name}: {e}")

    def _evaluate_rule(self, rule: AlertRule, value: float) -> bool:
        """è¯„ä¼°å‘Šè­¦è§„åˆ™"""
        if rule.comparison == "gt":
            return value > rule.threshold
        elif rule.comparison == "lt":
            return value < rule.threshold
        elif rule.comparison == "gte":
            return value >= rule.threshold
        elif rule.comparison == "lte":
            return value <= rule.threshold
        elif rule.comparison == "eq":
            return value == rule.threshold
        else:
            return False

    def _trigger_alert(self, rule: AlertRule, metric: MetricData) -> None:
        """è§¦å‘å‘Šè­¦"""
        # æ£€æŸ¥å‘Šè­¦å†·å´æœŸ
        cooldown_key = f"{self.ALERT_CACHE_PREFIX}:cooldown:{rule.name}"
        if cache.get(cooldown_key):
            return

        # å‘é€å‘Šè­¦é€šçŸ¥
        alert_message = {
            "title": f"Feishu Auth Alert: {rule.name}",
            "level": rule.level.value,
            "description": rule.description,
            "metric_name": metric.name,
            "metric_value": metric.value,
            "threshold": rule.threshold,
            "timestamp": metric.timestamp.isoformat(),
            "tags": metric.tags
        }

        self.notification_service.send_alert(alert_message)

        # è®¾ç½®å†·å´æœŸ
        cache.setex(cooldown_key, self.ALERT_COOLDOWN, "1")

        logger.warning(f"Alert triggered: {rule.name}, value={metric.value}")

    def get_metrics_summary(self, hours: int = 24) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡æ‘˜è¦"""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=hours)

        try:
            # ä»æ•°æ®åº“æŸ¥è¯¢æŒ‡æ ‡æ•°æ®
            metrics = db.session.query(FeishuMetrics).filter(
                FeishuMetrics.timestamp >= start_time,
                FeishuMetrics.timestamp <= end_time
            ).all()

            # èšåˆç»Ÿè®¡
            summary = {}
            for metric in metrics:
                metric_name = metric.metric_name
                if metric_name not in summary:
                    summary[metric_name] = {
                        "count": 0,
                        "sum": 0,
                        "min": float('inf'),
                        "max": float('-inf'),
                        "avg": 0,
                        "latest": None
                    }

                value = metric.metric_value
                summary[metric_name]["count"] += 1
                summary[metric_name]["sum"] += value
                summary[metric_name]["min"] = min(summary[metric_name]["min"], value)
                summary[metric_name]["max"] = max(summary[metric_name]["max"], value)
                summary[metric_name]["latest"] = metric.timestamp

            # è®¡ç®—å¹³å‡å€¼
            for metric_name in summary:
                if summary[metric_name]["count"] > 0:
                    summary[metric_name]["avg"] = summary[metric_name]["sum"] / summary[metric_name]["count"]

            return summary

        except Exception as e:
            logger.error(f"Failed to get metrics summary: {e}")
            return {}

    def get_health_status(self) -> Dict[str, Any]:
        """è·å–å¥åº·çŠ¶æ€"""
        try:
            status = {
                "status": "healthy",
                "timestamp": datetime.utcnow().isoformat(),
                "checks": {}
            }

            # æ£€æŸ¥æ•°æ®åº“è¿æ¥
            try:
                db.session.execute("SELECT 1")
                status["checks"]["database"] = {"status": "healthy"}
            except Exception as e:
                status["checks"]["database"] = {"status": "unhealthy", "error": str(e)}
                status["status"] = "unhealthy"

            # æ£€æŸ¥ç¼“å­˜è¿æ¥
            try:
                cache.ping()
                status["checks"]["cache"] = {"status": "healthy"}
            except Exception as e:
                status["checks"]["cache"] = {"status": "unhealthy", "error": str(e)}
                status["status"] = "unhealthy"

            # æ£€æŸ¥æœ€è¿‘çš„æŒ‡æ ‡æ•°æ®
            recent_metrics = self.get_metrics_summary(hours=1)
            if recent_metrics:
                status["checks"]["metrics"] = {"status": "healthy", "count": len(recent_metrics)}
            else:
                status["checks"]["metrics"] = {"status": "warning", "message": "No recent metrics"}

            return status

        except Exception as e:
            logger.error(f"Failed to get health status: {e}")
            return {
                "status": "error",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }

# ç›‘æ§è£…é¥°å™¨
def monitor_feishu_operation(operation_name: str):
    """é£ä¹¦æ“ä½œç›‘æ§è£…é¥°å™¨"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            monitor = FeishuMonitorService()

            try:
                result = func(*args, **kwargs)

                # è®°å½•æˆåŠŸæŒ‡æ ‡
                duration = (time.time() - start_time) * 1000  # æ¯«ç§’
                monitor.record_metric(MetricData(
                    name=f"{operation_name}_duration",
                    value=duration,
                    timestamp=datetime.utcnow(),
                    tags={"status": "success", "operation": operation_name}
                ))

                monitor.record_metric(MetricData(
                    name=f"{operation_name}_count",
                    value=1,
                    timestamp=datetime.utcnow(),
                    tags={"status": "success", "operation": operation_name}
                ))

                return result

            except Exception as e:
                # è®°å½•å¤±è´¥æŒ‡æ ‡
                monitor.record_metric(MetricData(
                    name=f"{operation_name}_count",
                    value=1,
                    timestamp=datetime.utcnow(),
                    tags={"status": "error", "operation": operation_name, "error": str(e)}
                ))

                raise

        return wrapper
    return decorator
```

#### 1.2 åˆ›å»ºæŒ‡æ ‡æ•°æ®æ¨¡å‹
```python
# app/models/feishu/metrics.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

from sqlalchemy import Column, String, Float, DateTime, JSON, Index
from app.extensions import db
from app.models.base import TimestampMixin

class FeishuMetrics(db.Model, TimestampMixin):
    """é£ä¹¦è®¤è¯æŒ‡æ ‡æ¨¡å‹"""

    __tablename__ = 'feishu_metrics'

    id = Column(db.Integer, primary_key=True)
    metric_name = Column(String(100), nullable=False, comment='æŒ‡æ ‡åç§°')
    metric_value = Column(Float, nullable=False, comment='æŒ‡æ ‡å€¼')
    timestamp = Column(DateTime, nullable=False, comment='æ—¶é—´æˆ³')
    tags = Column(JSON, default={}, comment='æ ‡ç­¾æ•°æ®')

    # ç´¢å¼•
    __table_args__ = (
        Index('idx_feishu_metrics_name_time', 'metric_name', 'timestamp'),
        Index('idx_feishu_metrics_timestamp', 'timestamp'),
        {'comment': 'é£ä¹¦è®¤è¯æŒ‡æ ‡è¡¨'}
    )

    def __repr__(self):
        return f'<FeishuMetrics {self.metric_name}={self.metric_value}>'

class FeishuOperationLog(db.Model, TimestampMixin):
    """é£ä¹¦æ“ä½œæ—¥å¿—æ¨¡å‹"""

    __tablename__ = 'feishu_operation_logs'

    id = Column(db.Integer, primary_key=True)
    operation_type = Column(String(50), nullable=False, comment='æ“ä½œç±»å‹')
    user_id = Column(String(50), comment='ç”¨æˆ·ID')
    feishu_user_id = Column(String(100), comment='é£ä¹¦ç”¨æˆ·ID')
    operation_data = Column(JSON, default={}, comment='æ“ä½œæ•°æ®')
    result_status = Column(String(20), nullable=False, comment='ç»“æœçŠ¶æ€')
    error_message = Column(String(500), comment='é”™è¯¯ä¿¡æ¯')
    ip_address = Column(String(45), comment='IPåœ°å€')
    user_agent = Column(String(500), comment='ç”¨æˆ·ä»£ç†')

    # ç´¢å¼•
    __table_args__ = (
        Index('idx_feishu_logs_type_time', 'operation_type', 'created_at'),
        Index('idx_feishu_logs_user', 'user_id'),
        Index('idx_feishu_logs_feishu_user', 'feishu_user_id'),
        {'comment': 'é£ä¹¦æ“ä½œæ—¥å¿—è¡¨'}
    )

    def __repr__(self):
        return f'<FeishuOperationLog {self.operation_type}:{self.result_status}>'
```

**âœ… é˜¶æ®µæµ‹è¯•1ï¼šç›‘æ§ç³»ç»ŸéªŒè¯**
```python
# scripts/test_feishu_monitoring.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import sys
import os
import time
from datetime import datetime

# æ·»åŠ é¡¹ç›®è·¯å¾„
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from app import create_app
from app.services.feishu.monitor.feishu_monitor import FeishuMonitorService, MetricData

def test_monitoring_system():
    """æµ‹è¯•ç›‘æ§ç³»ç»Ÿ"""
    app = create_app()

    with app.app_context():
        monitor = FeishuMonitorService()

        print("ğŸ” Testing Feishu Monitoring System...")

        # æµ‹è¯•æŒ‡æ ‡è®°å½•
        print("ğŸ“Š Testing metric recording...")
        test_metrics = [
            MetricData("login_success_count", 10, datetime.utcnow()),
            MetricData("login_failure_count", 2, datetime.utcnow()),
            MetricData("api_response_time_avg", 1500, datetime.utcnow()),
            MetricData("token_refresh_count", 5, datetime.utcnow()),
        ]

        for metric in test_metrics:
            monitor.record_metric(metric)
            print(f"  âœ… Recorded: {metric.name} = {metric.value}")

        # ç­‰å¾…ä¸€ç§’é’Ÿè®©æ•°æ®ç”Ÿæ•ˆ
        time.sleep(1)

        # æµ‹è¯•æŒ‡æ ‡æ‘˜è¦
        print("ğŸ“ˆ Testing metrics summary...")
        summary = monitor.get_metrics_summary(hours=1)
        print(f"  ğŸ“Š Metrics summary: {len(summary)} metrics")
        for name, data in summary.items():
            print(f"    - {name}: avg={data['avg']:.2f}, count={data['count']}")

        # æµ‹è¯•å¥åº·æ£€æŸ¥
        print("ğŸ¥ Testing health check...")
        health = monitor.get_health_status()
        print(f"  ğŸ¥ Health status: {health['status']}")
        for check, result in health['checks'].items():
            print(f"    - {check}: {result['status']}")

        # æµ‹è¯•å‘Šè­¦è§„åˆ™
        print("ğŸš¨ Testing alert rules...")
        # è§¦å‘ä¸€ä¸ªå‘Šè­¦ï¼ˆé«˜å¤±è´¥ç‡ï¼‰
        alert_metric = MetricData("login_failure_rate", 0.15, datetime.utcnow())
        monitor.record_metric(alert_metric)
        print(f"  ğŸš¨ Triggered alert with failure rate: {alert_metric.value}")

        print("âœ… Monitoring system test completed!")

if __name__ == "__main__":
    test_monitoring_system()
```

### ä»»åŠ¡2ï¼šæ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥ (0.5å¤©)

#### 2.1 ä¼˜åŒ–é£ä¹¦APIè°ƒç”¨æ€§èƒ½
```python
# app/services/feishu/performance/cache_optimizer.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import asyncio
import json
import hashlib
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, Callable
from functools import wraps

from app.extensions import cache
from app.services.feishu.monitor.feishu_monitor import monitor_feishu_operation

class FeishuCacheOptimizer:
    """é£ä¹¦APIç¼“å­˜ä¼˜åŒ–å™¨"""

    # ç¼“å­˜é…ç½®
    USER_INFO_TTL = 3600  # ç”¨æˆ·ä¿¡æ¯ç¼“å­˜1å°æ—¶
    APP_TOKEN_TTL = 7200  # åº”ç”¨ä»¤ç‰Œç¼“å­˜2å°æ—¶
    DEPT_INFO_TTL = 1800  # éƒ¨é—¨ä¿¡æ¯ç¼“å­˜30åˆ†é’Ÿ
    RATE_LIMIT_TTL = 60   # é™æµä¿¡æ¯ç¼“å­˜1åˆ†é’Ÿ

    @classmethod
    def cache_key(cls, prefix: str, *args, **kwargs) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        key_data = f"{prefix}:{':'.join(map(str, args))}"
        if kwargs:
            key_data += f":{hashlib.md5(json.dumps(kwargs, sort_keys=True).encode()).hexdigest()[:8]}"
        return key_data

    @classmethod
    def cached_user_info(cls, ttl: int = USER_INFO_TTL):
        """ç”¨æˆ·ä¿¡æ¯ç¼“å­˜è£…é¥°å™¨"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            @monitor_feishu_operation("cached_user_info")
            def wrapper(self, user_id: str, *args, **kwargs):
                cache_key = cls.cache_key("feishu_user_info", user_id)

                # å°è¯•ä»ç¼“å­˜è·å–
                cached_result = cache.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)

                # è°ƒç”¨åŸå‡½æ•°
                result = func(self, user_id, *args, **kwargs)

                # å­˜å‚¨åˆ°ç¼“å­˜
                if result:
                    cache.setex(cache_key, ttl, json.dumps(result, default=str))

                return result
            return wrapper
        return decorator

    @classmethod
    def cached_app_token(cls, ttl: int = APP_TOKEN_TTL):
        """åº”ç”¨ä»¤ç‰Œç¼“å­˜è£…é¥°å™¨"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            @monitor_feishu_operation("cached_app_token")
            def wrapper(self, app_id: str, app_secret: str, *args, **kwargs):
                cache_key = cls.cache_key("feishu_app_token", app_id)

                # å°è¯•ä»ç¼“å­˜è·å–
                cached_result = cache.get(cache_key)
                if cached_result:
                    return cached_result

                # è°ƒç”¨åŸå‡½æ•°
                result = func(self, app_id, app_secret, *args, **kwargs)

                # å­˜å‚¨åˆ°ç¼“å­˜ï¼ˆæå‰10åˆ†é’Ÿè¿‡æœŸï¼‰
                if result:
                    cache.setex(cache_key, ttl - 600, result)

                return result
            return wrapper
        return decorator

    @classmethod
    def rate_limited(cls, max_calls: int = 100, window: int = 60):
        """APIé™æµè£…é¥°å™¨"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            def wrapper(*args, **kwargs):
                # ç”Ÿæˆé™æµé”®ï¼ˆåŸºäºå‡½æ•°åå’Œå‚æ•°ï¼‰
                rate_key = cls.cache_key("rate_limit", func.__name__)

                # æ£€æŸ¥å½“å‰è°ƒç”¨æ¬¡æ•°
                current_calls = cache.get(rate_key) or 0
                if int(current_calls) >= max_calls:
                    raise Exception(f"Rate limit exceeded: {max_calls} calls per {window} seconds")

                # å¢åŠ è°ƒç”¨è®¡æ•°
                pipe = cache.pipeline()
                pipe.incr(rate_key)
                pipe.expire(rate_key, window)
                pipe.execute()

                return func(*args, **kwargs)
            return wrapper
        return decorator

    @classmethod
    def batch_cache_invalidation(cls, patterns: list):
        """æ‰¹é‡ç¼“å­˜å¤±æ•ˆ"""
        try:
            for pattern in patterns:
                # ä½¿ç”¨Redis SCANå‘½ä»¤æŸ¥æ‰¾åŒ¹é…çš„é”®
                cursor = 0
                while True:
                    cursor, keys = cache.scan(cursor, match=pattern, count=100)
                    if keys:
                        cache.delete(*keys)
                    if cursor == 0:
                        break
        except Exception as e:
            print(f"Cache invalidation error: {e}")

    @classmethod
    def warmup_cache(cls, user_ids: list):
        """é¢„çƒ­ç¼“å­˜"""
        # è¿™é‡Œå¯ä»¥æ‰¹é‡é¢„åŠ è½½å¸¸ç”¨çš„ç”¨æˆ·ä¿¡æ¯
        pass

# åº”ç”¨ç¼“å­˜è£…é¥°å™¨åˆ°é£ä¹¦æœåŠ¡
def apply_cache_optimizations():
    """åº”ç”¨ç¼“å­˜ä¼˜åŒ–åˆ°é£ä¹¦æœåŠ¡"""
    from app.services.feishu.service.feishu_auth import FeishuAuthService

    # ä¸ºå…³é”®æ–¹æ³•æ·»åŠ ç¼“å­˜
    FeishuAuthService.get_app_access_token = FeishuCacheOptimizer.cached_app_token()(
        FeishuAuthService.get_app_access_token
    )

    FeishuAuthService.get_user_info = FeishuCacheOptimizer.cached_user_info()(
        FeishuAuthService.get_user_info
    )

    # æ·»åŠ é™æµä¿æŠ¤
    FeishuAuthService.get_user_access_token = FeishuCacheOptimizer.rate_limited(
        max_calls=50, window=60
    )(FeishuAuthService.get_user_access_token)
```

### ä»»åŠ¡3ï¼šå®‰å…¨åŠ å›ºå’Œå®¡è®¡æ—¥å¿— (1å¤©)

#### 3.1 å®‰å…¨åŠ å›ºæªæ–½
```python
# app/services/feishu/security/security_enhancer.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import hmac
import hashlib
import secrets
import ipaddress
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from flask import request, current_app

from app.extensions import cache, db
from app.models.feishu.metrics import FeishuOperationLog

class FeishuSecurityEnhancer:
    """é£ä¹¦å®‰å…¨å¢å¼ºå™¨"""

    # å®‰å…¨é…ç½®
    MAX_LOGIN_ATTEMPTS = 5
    LOCKOUT_DURATION = 3600  # 1å°æ—¶
    ALLOWED_DOMAINS = []  # ä»é…ç½®åŠ è½½
    IP_WHITELIST = []     # ä»é…ç½®åŠ è½½

    @classmethod
    def verify_webhook_signature(cls, body: bytes, signature: str, secret: str) -> bool:
        """éªŒè¯webhookç­¾å"""
        try:
            expected_signature = hmac.new(
                secret.encode('utf-8'),
                body,
                hashlib.sha256
            ).hexdigest()

            return hmac.compare_digest(signature, expected_signature)
        except Exception:
            return False

    @classmethod
    def generate_secure_state(cls) -> str:
        """ç”Ÿæˆå®‰å…¨çš„stateå‚æ•°"""
        timestamp = str(int(datetime.utcnow().timestamp()))
        random_part = secrets.token_urlsafe(32)
        return f"{timestamp}:{random_part}"

    @classmethod
    def validate_state(cls, state: str, max_age: int = 600) -> bool:
        """éªŒè¯stateå‚æ•°"""
        try:
            if ':' not in state:
                return False

            timestamp_str, _ = state.split(':', 1)
            timestamp = int(timestamp_str)

            # æ£€æŸ¥æ—¶é—´æœ‰æ•ˆæ€§
            current_time = int(datetime.utcnow().timestamp())
            return (current_time - timestamp) <= max_age
        except (ValueError, TypeError):
            return False

    @classmethod
    def check_rate_limit(cls, identifier: str, max_attempts: int = 10, window: int = 300) -> bool:
        """æ£€æŸ¥é€Ÿç‡é™åˆ¶"""
        key = f"rate_limit:feishu:{identifier}"

        try:
            current_count = cache.get(key) or 0
            if int(current_count) >= max_attempts:
                return False

            # å¢åŠ è®¡æ•°
            pipe = cache.pipeline()
            pipe.incr(key)
            pipe.expire(key, window)
            pipe.execute()

            return True
        except Exception:
            return True  # ç¼“å­˜æ•…éšœæ—¶å…è®¸é€šè¿‡

    @classmethod
    def log_security_event(cls, event_type: str, details: Dict[str, Any], level: str = 'info'):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        try:
            log_entry = FeishuOperationLog(
                operation_type=f"security_{event_type}",
                operation_data={
                    'event_type': event_type,
                    'details': details,
                    'level': level,
                    'timestamp': datetime.utcnow().isoformat()
                },
                result_status=level,
                ip_address=cls._get_client_ip(),
                user_agent=request.headers.get('User-Agent', '')[:500]
            )

            db.session.add(log_entry)
            db.session.commit()

        except Exception as e:
            current_app.logger.error(f"Failed to log security event: {e}")

    @classmethod
    def check_ip_whitelist(cls, ip: str) -> bool:
        """æ£€æŸ¥IPç™½åå•"""
        if not cls.IP_WHITELIST:
            return True  # æœªé…ç½®ç™½åå•æ—¶å…è®¸æ‰€æœ‰IP

        try:
            client_ip = ipaddress.ip_address(ip)
            for allowed_ip in cls.IP_WHITELIST:
                if client_ip in ipaddress.ip_network(allowed_ip, strict=False):
                    return True
            return False
        except ValueError:
            return False

    @classmethod
    def validate_email_domain(cls, email: str) -> bool:
        """éªŒè¯é‚®ç®±åŸŸå"""
        if not cls.ALLOWED_DOMAINS:
            return True  # æœªé…ç½®åŸŸåé™åˆ¶æ—¶å…è®¸æ‰€æœ‰åŸŸå

        try:
            domain = email.split('@')[1].lower()
            return domain in [d.lower() for d in cls.ALLOWED_DOMAINS]
        except (IndexError, AttributeError):
            return False

    @classmethod
    def check_login_attempts(cls, identifier: str) -> bool:
        """æ£€æŸ¥ç™»å½•å°è¯•æ¬¡æ•°"""
        key = f"login_attempts:feishu:{identifier}"

        try:
            attempts = cache.get(key) or 0
            return int(attempts) < cls.MAX_LOGIN_ATTEMPTS
        except Exception:
            return True

    @classmethod
    def record_login_attempt(cls, identifier: str, success: bool):
        """è®°å½•ç™»å½•å°è¯•"""
        key = f"login_attempts:feishu:{identifier}"

        try:
            if success:
                # æˆåŠŸç™»å½•æ¸…é™¤è®¡æ•°
                cache.delete(key)
            else:
                # å¤±è´¥ç™»å½•å¢åŠ è®¡æ•°
                pipe = cache.pipeline()
                pipe.incr(key)
                pipe.expire(key, cls.LOCKOUT_DURATION)
                pipe.execute()
        except Exception:
            pass

    @classmethod
    def sanitize_user_data(cls, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """æ¸…ç†ç”¨æˆ·æ•°æ®"""
        # åªä¿ç•™å®‰å…¨çš„å­—æ®µ
        safe_fields = [
            'user_id', 'name', 'en_name', 'email', 'avatar_url',
            'mobile', 'department_ids', 'union_id', 'open_id'
        ]

        sanitized = {}
        for field in safe_fields:
            if field in user_data:
                value = user_data[field]
                # åŸºæœ¬æ¸…ç†
                if isinstance(value, str):
                    value = value.strip()[:500]  # é™åˆ¶é•¿åº¦
                sanitized[field] = value

        return sanitized

    @classmethod
    def _get_client_ip(cls) -> str:
        """è·å–å®¢æˆ·ç«¯IPåœ°å€"""
        # æ£€æŸ¥ä»£ç†å¤´
        if request.headers.get('X-Forwarded-For'):
            return request.headers.get('X-Forwarded-For').split(',')[0].strip()
        elif request.headers.get('X-Real-IP'):
            return request.headers.get('X-Real-IP')
        else:
            return request.remote_addr or 'unknown'

# å®‰å…¨è£…é¥°å™¨
def require_valid_ip(func):
    """IPç™½åå•éªŒè¯è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        client_ip = FeishuSecurityEnhancer._get_client_ip()

        if not FeishuSecurityEnhancer.check_ip_whitelist(client_ip):
            FeishuSecurityEnhancer.log_security_event(
                'ip_blocked',
                {'ip': client_ip, 'endpoint': request.endpoint},
                'warning'
            )
            abort(403, 'Access denied from this IP address')

        return func(*args, **kwargs)
    return wrapper

def require_rate_limit(identifier_func: Callable = None):
    """é€Ÿç‡é™åˆ¶è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # è·å–é™æµæ ‡è¯†ç¬¦
            if identifier_func:
                identifier = identifier_func()
            else:
                identifier = FeishuSecurityEnhancer._get_client_ip()

            if not FeishuSecurityEnhancer.check_rate_limit(identifier):
                FeishuSecurityEnhancer.log_security_event(
                    'rate_limit_exceeded',
                    {'identifier': identifier, 'endpoint': request.endpoint},
                    'warning'
                )
                abort(429, 'Rate limit exceeded')

            return func(*args, **kwargs)
        return wrapper
    return decorator
```

**âœ… é˜¶æ®µæµ‹è¯•2ï¼šå®‰å…¨åŠŸèƒ½éªŒè¯**
```python
# scripts/test_feishu_security.py

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

import sys
import os
import time
from datetime import datetime

# æ·»åŠ é¡¹ç›®è·¯å¾„
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from app import create_app
from app.services.feishu.security.security_enhancer import FeishuSecurityEnhancer

def test_security_features():
    """æµ‹è¯•å®‰å…¨åŠŸèƒ½"""
    app = create_app()

    with app.app_context():
        print("ğŸ”’ Testing Feishu Security Features...")

        # æµ‹è¯•stateç”Ÿæˆå’ŒéªŒè¯
        print("ğŸ”‘ Testing state generation and validation...")
        state = FeishuSecurityEnhancer.generate_secure_state()
        print(f"  Generated state: {state[:20]}...")

        # éªŒè¯æœ‰æ•ˆstate
        is_valid = FeishuSecurityEnhancer.validate_state(state)
        print(f"  âœ… State validation (valid): {is_valid}")

        # éªŒè¯æ— æ•ˆstate
        invalid_state = "invalid:state:format"
        is_invalid = FeishuSecurityEnhancer.validate_state(invalid_state)
        print(f"  âŒ State validation (invalid): {is_invalid}")

        # æµ‹è¯•é€Ÿç‡é™åˆ¶
        print("â±ï¸ Testing rate limiting...")
        identifier = "test_user"

        # å¤šæ¬¡è°ƒç”¨æ£€æŸ¥é™æµ
        for i in range(12):
            allowed = FeishuSecurityEnhancer.check_rate_limit(identifier, max_attempts=10)
            if i < 10:
                print(f"  âœ… Attempt {i+1}: {allowed}")
            else:
                print(f"  ğŸš« Attempt {i+1}: {allowed} (should be False)")

        # æµ‹è¯•é‚®ç®±åŸŸåéªŒè¯
        print("ğŸ“§ Testing email domain validation...")
        FeishuSecurityEnhancer.ALLOWED_DOMAINS = ['company.com', 'example.org']

        test_emails = [
            'user@company.com',
            'test@example.org',
            'hacker@evil.com',
            'invalid-email'
        ]

        for email in test_emails:
            is_valid = FeishuSecurityEnhancer.validate_email_domain(email)
            status = "âœ…" if is_valid else "âŒ"
            print(f"  {status} {email}: {is_valid}")

        # æµ‹è¯•ç”¨æˆ·æ•°æ®æ¸…ç†
        print("ğŸ§¹ Testing user data sanitization...")
        raw_data = {
            'user_id': 'ou_123456',
            'name': 'Test User',
            'email': 'test@company.com',
            'dangerous_field': '<script>alert("xss")</script>',
            'long_field': 'x' * 1000
        }

        sanitized = FeishuSecurityEnhancer.sanitize_user_data(raw_data)
        print(f"  Original fields: {list(raw_data.keys())}")
        print(f"  Sanitized fields: {list(sanitized.keys())}")
        print(f"  Long field truncated: {len(sanitized.get('long_field', '')) if 'long_field' in sanitized else 'Removed'}")

        print("âœ… Security features test completed!")

if __name__ == "__main__":
    test_security_features()
```

## ğŸ¯ é˜¶æ®µäº¤ä»˜ç‰©

### ä»£ç è¾“å‡º
- [ ] ç›‘æ§å‘Šè­¦ç³»ç»Ÿï¼ˆ1ä¸ªæ ¸å¿ƒæœåŠ¡ + 2ä¸ªæ•°æ®æ¨¡å‹ï¼‰
- [ ] æ€§èƒ½ä¼˜åŒ–ç»„ä»¶ï¼ˆç¼“å­˜ä¼˜åŒ–å™¨ + è£…é¥°å™¨é›†åˆï¼‰
- [ ] å®‰å…¨åŠ å›ºæ¨¡å—ï¼ˆå®‰å…¨å¢å¼ºå™¨ + é˜²æŠ¤è£…é¥°å™¨ï¼‰
- [ ] å®Œæ•´çš„æµ‹è¯•è„šæœ¬å’ŒéªŒè¯å·¥å…·

### åŠŸèƒ½éªŒè¯
- [ ] ç›‘æ§æŒ‡æ ‡æ­£ç¡®æ”¶é›†å’Œå­˜å‚¨
- [ ] å‘Šè­¦è§„åˆ™è§¦å‘å’Œé€šçŸ¥æ­£å¸¸
- [ ] ç¼“å­˜ç­–ç•¥æœ‰æ•ˆæå‡æ€§èƒ½
- [ ] å®‰å…¨æªæ–½æ­£ç¡®é˜»æ­¢å¨èƒ
- [ ] é™æµæœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] å®¡è®¡æ—¥å¿—å®Œæ•´è®°å½•

### æ€§èƒ½æŒ‡æ ‡
- [ ] APIå“åº”æ—¶é—´ä¼˜åŒ–30%ä»¥ä¸Š
- [ ] ç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ°80%ä»¥ä¸Š
- [ ] ç›‘æ§æ•°æ®å»¶è¿Ÿ < 5ç§’
- [ ] å®‰å…¨æ£€æŸ¥æ€§èƒ½å½±å“ < 10ms

## ğŸ“ˆ æˆåŠŸæ ‡å‡†

1. **ç›‘æ§å®Œæ•´æ€§**ï¼šå…³é”®æŒ‡æ ‡100%è¦†ç›–ï¼Œå‘Šè­¦åŠæ—¶å‡†ç¡®
2. **æ€§èƒ½æå‡**ï¼šå“åº”æ—¶é—´å’Œèµ„æºä½¿ç”¨æ˜¾è‘—ä¼˜åŒ–
3. **å®‰å…¨é˜²æŠ¤**ï¼šå¸¸è§å¨èƒæœ‰æ•ˆé˜²å¾¡ï¼Œå®¡è®¡å®Œæ•´
4. **ç³»ç»Ÿç¨³å®šæ€§**ï¼šå¼‚å¸¸å¤„ç†å®Œå–„ï¼Œé™çº§æœºåˆ¶å¯ç”¨
5. **è¿ç»´å‹å¥½**ï¼šç›‘æ§é¢æ¿æ¸…æ™°ï¼Œæ•…éšœæ’æŸ¥ä¾¿æ·

---

**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š2-3å¤©
**å…³é”®ä¾èµ–**ï¼šç¬¬1ã€2ã€3é˜¶æ®µå®Œæˆ
**ä¸‹ä¸€é˜¶æ®µ**ï¼šç¬¬5é˜¶æ®µ - ç”Ÿäº§éƒ¨ç½²å’Œè¿ç»´ç®¡ç†