# 飞书登录集成开发计划 - 第3阶段：前端集成和用户体验

## 📋 阶段概述

**目标**：实现完整的前端飞书登录集成，包括登录组件、回调处理、用户体验优化
**预估时间**：3-4天
**优先级**：高
**依赖**：第1、2阶段完成

## 🎯 阶段目标

- [ ] 开发React飞书登录组件
- [ ] 实现飞书回调页面处理
- [ ] 扩展用户信息显示和管理
- [ ] 集成前端状态管理和路由
- [ ] 优化用户体验和错误处理
- [ ] 编写完整的前端测试

## 📝 详细任务清单

### 任务1：React登录组件开发 (1.5天)

#### 1.1 创建飞书登录按钮组件
```typescript
// frontend/src/components/auth/FeishuLoginButton.tsx

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React, { useState } from 'react';
import { Button, message } from 'antd';
import { FeishuOutlined } from '@ant-design/icons';
import { useFeishuAuth } from '../../hooks/useFeishuAuth';
import { LoadingOutlined } from '@ant-design/icons';

interface FeishuLoginButtonProps {
  onLoginStart?: () => void;
  onLoginSuccess?: (userInfo: any) => void;
  onLoginError?: (error: string) => void;
  className?: string;
  size?: 'small' | 'middle' | 'large';
  block?: boolean;
  disabled?: boolean;
}

export const FeishuLoginButton: React.FC<FeishuLoginButtonProps> = ({
  onLoginStart,
  onLoginSuccess,
  onLoginError,
  className,
  size = 'middle',
  block = false,
  disabled = false
}) => {
  const [loading, setLoading] = useState(false);
  const { getAuthorizationUrl } = useFeishuAuth();

  const handleLogin = async () => {
    try {
      setLoading(true);
      onLoginStart?.();

      // Generate CSRF state token
      const state = generateStateToken();

      // Store state in sessionStorage for validation
      sessionStorage.setItem('feishu_oauth_state', state);

      // Get authorization URL
      const authUrl = await getAuthorizationUrl(state);

      // Redirect to Feishu authorization page
      window.location.href = authUrl;

    } catch (error: any) {
      setLoading(false);
      const errorMessage = error?.message || 'Failed to initiate Feishu login';
      message.error(errorMessage);
      onLoginError?.(errorMessage);
    }
  };

  const generateStateToken = (): string => {
    const timestamp = Date.now().toString();
    const random = Math.random().toString(36).substring(2);
    return btoa(`${timestamp}-${random}`);
  };

  return (
    <Button
      type="default"
      size={size}
      block={block}
      disabled={disabled || loading}
      className={`feishu-login-button ${className || ''}`}
      onClick={handleLogin}
      icon={loading ? <LoadingOutlined /> : <FeishuOutlined />}
      style={{
        borderColor: '#00d4aa',
        color: '#00d4aa'
      }}
    >
      {loading ? 'Connecting to Feishu...' : 'Login with Feishu'}
    </Button>
  );
};

export default FeishuLoginButton;
```

#### 1.2 创建飞书认证Hook
```typescript
// frontend/src/hooks/useFeishuAuth.ts

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { useState, useCallback } from 'react';
import { useDispatch } from 'react-redux';
import { feishuApi } from '../api/feishuApi';
import { authSlice } from '../store/slices/authSlice';
import { message } from 'antd';

interface FeishuAuthState {
  isLoading: boolean;
  error: string | null;
  isAuthenticated: boolean;
}

export const useFeishuAuth = () => {
  const dispatch = useDispatch();
  const [state, setState] = useState<FeishuAuthState>({
    isLoading: false,
    error: null,
    isAuthenticated: false
  });

  const getAuthorizationUrl = useCallback(async (state?: string): Promise<string> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await feishuApi.getAuthorizationUrl({ state });
      setState(prev => ({ ...prev, isLoading: false }));
      return response.authorization_url;
    } catch (error: any) {
      const errorMessage = error?.message || 'Failed to get authorization URL';
      setState(prev => ({ ...prev, isLoading: false, error: errorMessage }));
      throw error;
    }
  }, []);

  const handleCallback = useCallback(async (code: string, state?: string): Promise<void> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Validate state parameter
      const storedState = sessionStorage.getItem('feishu_oauth_state');
      if (state && state !== storedState) {
        throw new Error('Invalid state parameter - possible CSRF attack');
      }

      // Process callback
      const response = await feishuApi.handleCallback({ code, state });

      // Update auth state
      dispatch(authSlice.actions.setUser(response.user));
      dispatch(authSlice.actions.setTokens({
        access_token: response.access_token,
        refresh_token: response.refresh_token
      }));

      setState(prev => ({
        ...prev,
        isLoading: false,
        isAuthenticated: true
      }));

      // Clear stored state
      sessionStorage.removeItem('feishu_oauth_state');

      message.success('Login successful!');
    } catch (error: any) {
      const errorMessage = error?.message || 'Login failed';
      setState(prev => ({ ...prev, isLoading: false, error: errorMessage }));
      message.error(errorMessage);
      throw error;
    }
  }, [dispatch]);

  const refreshTokens = useCallback(async (): Promise<void> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await feishuApi.refreshTokens();

      dispatch(authSlice.actions.setTokens({
        access_token: response.access_token,
        refresh_token: response.refresh_token
      }));

      setState(prev => ({ ...prev, isLoading: false }));
    } catch (error: any) {
      const errorMessage = error?.message || 'Failed to refresh tokens';
      setState(prev => ({ ...prev, isLoading: false, error: errorMessage }));
      throw error;
    }
  }, [dispatch]);

  const validateAccess = useCallback(async (): Promise<boolean> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await feishuApi.validateAccess();
      setState(prev => ({
        ...prev,
        isLoading: false,
        isAuthenticated: response.valid
      }));
      return response.valid;
    } catch (error: any) {
      setState(prev => ({ ...prev, isLoading: false, error: error?.message }));
      return false;
    }
  }, []);

  return {
    ...state,
    getAuthorizationUrl,
    handleCallback,
    refreshTokens,
    validateAccess
  };
};
```

#### 1.3 集成到现有登录页面
```typescript
// frontend/src/pages/auth/LoginPage.tsx - 扩展现有登录页面

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React from 'react';
import { Card, Space, Divider, Typography } from 'antd';
import LoginForm from '../../components/auth/LoginForm'; // 现有登录表单
import FeishuLoginButton from '../../components/auth/FeishuLoginButton';
import { useNavigate } from 'react-router-dom';

const { Title, Text } = Typography;

const LoginPage: React.FC = () => {
  const navigate = useNavigate();

  const handleFeishuLoginSuccess = (userInfo: any) => {
    // Navigate to dashboard after successful login
    navigate('/dashboard');
  };

  const handleFeishuLoginError = (error: string) => {
    console.error('Feishu login error:', error);
  };

  return (
    <div className="login-page">
      <Card className="login-card" style={{ width: 400, margin: '0 auto', marginTop: '10vh' }}>
        <Title level={3} style={{ textAlign: 'center', marginBottom: 24 }}>
          Pigeon Web Login
        </Title>

        {/* 现有的用户名密码登录表单 */}
        <LoginForm />

        <Divider>
          <Text type="secondary">OR</Text>
        </Divider>

        {/* 飞书登录选项 */}
        <Space direction="vertical" style={{ width: '100%' }}>
          <FeishuLoginButton
            block
            size="large"
            onLoginSuccess={handleFeishuLoginSuccess}
            onLoginError={handleFeishuLoginError}
          />

          <Text type="secondary" style={{ fontSize: '12px', textAlign: 'center', display: 'block' }}>
            Use your Feishu account to login securely
          </Text>
        </Space>
      </Card>
    </div>
  );
};

export default LoginPage;
```

**✅ 阶段测试1：登录组件功能验证**
```typescript
// frontend/src/tests/components/FeishuLoginButton.test.tsx

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import FeishuLoginButton from '../../components/auth/FeishuLoginButton';
import { authSlice } from '../../store/slices/authSlice';

// Mock the feishu API
jest.mock('../../api/feishuApi', () => ({
  feishuApi: {
    getAuthorizationUrl: jest.fn().mockResolvedValue({
      authorization_url: 'https://open.feishu.cn/open-apis/authen/v1/index?app_id=test&redirect_uri=test'
    })
  }
}));

const mockStore = configureStore({
  reducer: {
    auth: authSlice.reducer
  }
});

const renderWithProviders = (component: React.ReactElement) => {
  return render(
    <Provider store={mockStore}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </Provider>
  );
};

describe('FeishuLoginButton', () => {
  beforeEach(() => {
    // Mock sessionStorage
    Object.defineProperty(window, 'sessionStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
      },
    });

    // Mock window.location
    delete (window as any).location;
    window.location = { href: '' } as any;
  });

  test('renders login button correctly', () => {
    renderWithProviders(<FeishuLoginButton />);

    const button = screen.getByRole('button', { name: /login with feishu/i });
    expect(button).toBeInTheDocument();
    expect(button).toHaveClass('feishu-login-button');
  });

  test('handles login click correctly', async () => {
    const onLoginStart = jest.fn();

    renderWithProviders(
      <FeishuLoginButton onLoginStart={onLoginStart} />
    );

    const button = screen.getByRole('button', { name: /login with feishu/i });
    fireEvent.click(button);

    await waitFor(() => {
      expect(onLoginStart).toHaveBeenCalled();
      expect(window.sessionStorage.setItem).toHaveBeenCalledWith(
        'feishu_oauth_state',
        expect.any(String)
      );
    });
  });

  test('shows loading state during login process', async () => {
    renderWithProviders(<FeishuLoginButton />);

    const button = screen.getByRole('button', { name: /login with feishu/i });
    fireEvent.click(button);

    // Should show loading state
    expect(screen.getByText(/connecting to feishu/i)).toBeInTheDocument();
  });

  test('handles disabled state correctly', () => {
    renderWithProviders(<FeishuLoginButton disabled />);

    const button = screen.getByRole('button', { name: /login with feishu/i });
    expect(button).toBeDisabled();
  });
});
```

### 任务2：飞书回调页面实现 (1天)

#### 2.1 创建回调处理页面
```typescript
// frontend/src/pages/auth/FeishuCallbackPage.tsx

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React, { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Card, Spin, Result, Button } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';
import { useFeishuAuth } from '../../hooks/useFeishuAuth';

type CallbackState = 'loading' | 'success' | 'error';

const FeishuCallbackPage: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { handleCallback } = useFeishuAuth();

  const [state, setState] = useState<CallbackState>('loading');
  const [errorMessage, setErrorMessage] = useState<string>('');
  const [userInfo, setUserInfo] = useState<any>(null);

  useEffect(() => {
    const processCallback = async () => {
      try {
        // Extract parameters from URL
        const code = searchParams.get('code');
        const state = searchParams.get('state');
        const error = searchParams.get('error');
        const errorDescription = searchParams.get('error_description');

        // Handle OAuth error response
        if (error) {
          throw new Error(errorDescription || `OAuth error: ${error}`);
        }

        // Validate required parameters
        if (!code) {
          throw new Error('Authorization code not received');
        }

        // Process the callback
        await handleCallback(code, state || undefined);

        setState('success');

        // Redirect to dashboard after 2 seconds
        setTimeout(() => {
          navigate('/dashboard', { replace: true });
        }, 2000);

      } catch (error: any) {
        console.error('Feishu callback error:', error);
        setErrorMessage(error?.message || 'Login failed');
        setState('error');
      }
    };

    processCallback();
  }, [searchParams, handleCallback, navigate]);

  const handleRetry = () => {
    navigate('/auth/login', { replace: true });
  };

  const renderContent = () => {
    switch (state) {
      case 'loading':
        return (
          <Card style={{ textAlign: 'center', padding: '40px' }}>
            <Spin size="large" />
            <div style={{ marginTop: 16, fontSize: '16px' }}>
              Processing Feishu login...
            </div>
            <div style={{ marginTop: 8, color: '#666', fontSize: '14px' }}>
              Please wait while we verify your account
            </div>
          </Card>
        );

      case 'success':
        return (
          <Result
            icon={<CheckCircleOutlined style={{ color: '#52c41a' }} />}
            title="Login Successful!"
            subTitle="You have successfully logged in with Feishu. Redirecting to dashboard..."
            extra={
              <Button type="primary" onClick={() => navigate('/dashboard')}>
                Go to Dashboard
              </Button>
            }
          />
        );

      case 'error':
        return (
          <Result
            icon={<CloseCircleOutlined style={{ color: '#ff4d4f' }} />}
            title="Login Failed"
            subTitle={errorMessage}
            extra={[
              <Button type="primary" onClick={handleRetry} key="retry">
                Try Again
              </Button>,
              <Button onClick={() => navigate('/')} key="home">
                Go Home
              </Button>
            ]}
          />
        );

      default:
        return null;
    }
  };

  return (
    <div style={{
      minHeight: '100vh',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#f5f5f5'
    }}>
      {renderContent()}
    </div>
  );
};

export default FeishuCallbackPage;
```

#### 2.2 添加路由配置
```typescript
// frontend/src/routes/authRoutes.tsx - 扩展现有路由配置

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React from 'react';
import { RouteObject } from 'react-router-dom';
import LoginPage from '../pages/auth/LoginPage';
import FeishuCallbackPage from '../pages/auth/FeishuCallbackPage';

export const authRoutes: RouteObject[] = [
  {
    path: '/auth/login',
    element: <LoginPage />
  },
  {
    path: '/auth/feishu/callback',
    element: <FeishuCallbackPage />
  },
  // ... 其他认证相关路由
];
```

#### 2.3 创建错误边界组件
```typescript
// frontend/src/components/auth/FeishuAuthErrorBoundary.tsx

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React, { Component, ReactNode } from 'react';
import { Result, Button } from 'antd';
import { ExceptionOutlined } from '@ant-design/icons';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class FeishuAuthErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Feishu Auth Error Boundary caught an error:', error, errorInfo);

    // You can also log the error to an error reporting service here
    // logErrorToService(error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: undefined });
    window.location.href = '/auth/login';
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <Result
            icon={<ExceptionOutlined />}
            title="Authentication Error"
            subTitle={`Something went wrong during the login process: ${this.state.error?.message}`}
            extra={
              <Button type="primary" onClick={this.handleReset}>
                Return to Login
              </Button>
            }
          />
        </div>
      );
    }

    return this.props.children;
  }
}

export default FeishuAuthErrorBoundary;
```

**✅ 阶段测试2：回调处理验证**
```typescript
// frontend/src/tests/pages/FeishuCallbackPage.test.tsx

import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import FeishuCallbackPage from '../../pages/auth/FeishuCallbackPage';
import { mockStore } from '../testUtils';

// Mock the useFeishuAuth hook
jest.mock('../../hooks/useFeishuAuth', () => ({
  useFeishuAuth: jest.fn()
}));

// Mock react-router-dom
const mockNavigate = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate,
  useSearchParams: () => [new URLSearchParams('code=test_code&state=test_state')]
}));

describe('FeishuCallbackPage', () => {
  const mockHandleCallback = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();

    (require('../../hooks/useFeishuAuth').useFeishuAuth as jest.Mock).mockReturnValue({
      handleCallback: mockHandleCallback
    });
  });

  const renderWithProviders = (component: React.ReactElement) => {
    return render(
      <Provider store={mockStore}>
        <BrowserRouter>
          {component}
        </BrowserRouter>
      </Provider>
    );
  };

  test('shows loading state initially', () => {
    renderWithProviders(<FeishuCallbackPage />);

    expect(screen.getByText(/processing feishu login/i)).toBeInTheDocument();
    expect(screen.getByText(/please wait while we verify/i)).toBeInTheDocument();
  });

  test('handles successful callback', async () => {
    mockHandleCallback.mockResolvedValue({});

    renderWithProviders(<FeishuCallbackPage />);

    await waitFor(() => {
      expect(screen.getByText(/login successful/i)).toBeInTheDocument();
    });

    expect(mockHandleCallback).toHaveBeenCalledWith('test_code', 'test_state');
  });

  test('handles callback error', async () => {
    const errorMessage = 'Invalid authorization code';
    mockHandleCallback.mockRejectedValue(new Error(errorMessage));

    renderWithProviders(<FeishuCallbackPage />);

    await waitFor(() => {
      expect(screen.getByText(/login failed/i)).toBeInTheDocument();
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });

  test('handles OAuth error in URL', async () => {
    // Mock URL with error parameter
    jest.mocked(require('react-router-dom').useSearchParams).mockReturnValue([
      new URLSearchParams('error=access_denied&error_description=User cancelled')
    ]);

    renderWithProviders(<FeishuCallbackPage />);

    await waitFor(() => {
      expect(screen.getByText(/login failed/i)).toBeInTheDocument();
      expect(screen.getByText(/user cancelled/i)).toBeInTheDocument();
    });
  });
});
```

### 任务3：用户信息扩展和状态管理 (0.5天)

#### 3.1 扩展用户状态管理
```typescript
// frontend/src/store/slices/authSlice.ts - 扩展现有认证状态管理

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface FeishuInfo {
  user_id: string;
  name: string;
  en_name?: string;
  email?: string;
  avatar_url?: string;
  mobile?: string;
  department_ids?: string[];
  union_id?: string;
  open_id?: string;
}

interface User {
  id: string;
  username: string;
  email: string;
  full_name: string;
  avatar_url?: string;
  roles: string[];
  permissions: string[];
  // 扩展飞书相关字段
  auth_provider?: 'local' | 'feishu';
  feishu_info?: FeishuInfo;
  last_feishu_sync?: string;
  is_feishu_user?: boolean;
}

interface AuthState {
  user: User | null;
  access_token: string | null;
  refresh_token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  // 飞书相关状态
  feishu_access_token?: string;
  feishu_refresh_token?: string;
  feishu_expires_at?: number;
}

const initialState: AuthState = {
  user: null,
  access_token: null,
  refresh_token: null,
  isAuthenticated: false,
  isLoading: false,
  error: null
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // 现有的actions...

    // 飞书登录相关actions
    setFeishuTokens: (state, action: PayloadAction<{
      feishu_access_token: string;
      feishu_refresh_token: string;
      feishu_expires_at: number;
    }>) => {
      state.feishu_access_token = action.payload.feishu_access_token;
      state.feishu_refresh_token = action.payload.feishu_refresh_token;
      state.feishu_expires_at = action.payload.feishu_expires_at;
    },

    updateFeishuInfo: (state, action: PayloadAction<FeishuInfo>) => {
      if (state.user) {
        state.user.feishu_info = action.payload;
        state.user.last_feishu_sync = new Date().toISOString();
        state.user.is_feishu_user = true;
        if (state.user.auth_provider !== 'feishu') {
          state.user.auth_provider = 'feishu';
        }
      }
    },

    clearFeishuTokens: (state) => {
      state.feishu_access_token = undefined;
      state.feishu_refresh_token = undefined;
      state.feishu_expires_at = undefined;
    },

    setAuthProvider: (state, action: PayloadAction<'local' | 'feishu'>) => {
      if (state.user) {
        state.user.auth_provider = action.payload;
      }
    },

    // 扩展现有的 setUser action 以支持飞书用户
    setUser: (state, action: PayloadAction<User>) => {
      state.user = action.payload;
      state.isAuthenticated = true;
      state.error = null;
    },

    // ... 其他现有actions
  }
});

export const {
  setUser,
  setTokens,
  setFeishuTokens,
  updateFeishuInfo,
  clearFeishuTokens,
  setAuthProvider,
  // ... 其他现有actions
} = authSlice.actions;

export default authSlice.reducer;

// Selectors
export const selectCurrentUser = (state: { auth: AuthState }) => state.auth.user;
export const selectIsFeishuUser = (state: { auth: AuthState }) =>
  state.auth.user?.auth_provider === 'feishu';
export const selectFeishuInfo = (state: { auth: AuthState }) =>
  state.auth.user?.feishu_info;
export const selectFeishuTokens = (state: { auth: AuthState }) => ({
  access_token: state.auth.feishu_access_token,
  refresh_token: state.auth.feishu_refresh_token,
  expires_at: state.auth.feishu_expires_at
});
```

#### 3.2 创建用户信息显示组件
```typescript
// frontend/src/components/user/UserProfileCard.tsx - 扩展现有用户信息组件

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import React from 'react';
import { Card, Avatar, Tag, Space, Typography, Tooltip, Badge } from 'antd';
import { UserOutlined, MailOutlined, PhoneOutlined, TeamOutlined } from '@ant-design/icons';
import { useSelector } from 'react-redux';
import { selectCurrentUser, selectIsFeishuUser, selectFeishuInfo } from '../../store/slices/authSlice';

const { Text, Title } = Typography;

interface UserProfileCardProps {
  showFeishuInfo?: boolean;
  compact?: boolean;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({
  showFeishuInfo = true,
  compact = false
}) => {
  const user = useSelector(selectCurrentUser);
  const isFeishuUser = useSelector(selectIsFeishuUser);
  const feishuInfo = useSelector(selectFeishuInfo);

  if (!user) return null;

  const renderAuthProviderBadge = () => {
    if (user.auth_provider === 'feishu') {
      return (
        <Tooltip title="Logged in via Feishu">
          <Tag color="green" style={{ marginLeft: 8 }}>
            Feishu
          </Tag>
        </Tooltip>
      );
    }
    return (
      <Tooltip title="Local account">
        <Tag color="blue" style={{ marginLeft: 8 }}>
          Local
        </Tag>
      </Tooltip>
    );
  };

  const renderFeishuInfo = () => {
    if (!showFeishuInfo || !isFeishuUser || !feishuInfo) return null;

    return (
      <Card
        size="small"
        title="Feishu Information"
        style={{ marginTop: 16 }}
        extra={
          <Tag color="processing" size="small">
            Synced
          </Tag>
        }
      >
        <Space direction="vertical" style={{ width: '100%' }}>
          {feishuInfo.en_name && (
            <div>
              <Text type="secondary">English Name: </Text>
              <Text>{feishuInfo.en_name}</Text>
            </div>
          )}

          {feishuInfo.mobile && (
            <div>
              <PhoneOutlined style={{ marginRight: 8, color: '#1890ff' }} />
              <Text>{feishuInfo.mobile}</Text>
            </div>
          )}

          {feishuInfo.department_ids && feishuInfo.department_ids.length > 0 && (
            <div>
              <TeamOutlined style={{ marginRight: 8, color: '#1890ff' }} />
              <Text>Departments: {feishuInfo.department_ids.length}</Text>
            </div>
          )}

          {user.last_feishu_sync && (
            <div>
              <Text type="secondary" style={{ fontSize: '12px' }}>
                Last sync: {new Date(user.last_feishu_sync).toLocaleString()}
              </Text>
            </div>
          )}
        </Space>
      </Card>
    );
  };

  if (compact) {
    return (
      <Space>
        <Avatar
          src={user.avatar_url || feishuInfo?.avatar_url}
          icon={<UserOutlined />}
          size="small"
        />
        <Text>{user.full_name}</Text>
        {renderAuthProviderBadge()}
      </Space>
    );
  }

  return (
    <Card>
      <Space direction="vertical" style={{ width: '100%' }}>
        <div style={{ textAlign: 'center' }}>
          <Badge
            dot={isFeishuUser}
            color="green"
            offset={[-10, 10]}
          >
            <Avatar
              src={user.avatar_url || feishuInfo?.avatar_url}
              icon={<UserOutlined />}
              size={64}
            />
          </Badge>

          <Title level={4} style={{ margin: '16px 0 8px 0' }}>
            {user.full_name}
            {renderAuthProviderBadge()}
          </Title>

          <Text type="secondary">@{user.username}</Text>
        </div>

        <Space direction="vertical" style={{ width: '100%' }}>
          <div>
            <MailOutlined style={{ marginRight: 8, color: '#1890ff' }} />
            <Text>{user.email}</Text>
          </div>

          <div>
            <Text type="secondary">Roles: </Text>
            <Space wrap>
              {user.roles.map(role => (
                <Tag key={role} color="blue">{role}</Tag>
              ))}
            </Space>
          </div>
        </Space>

        {renderFeishuInfo()}
      </Space>
    </Card>
  );
};

export default UserProfileCard;
```

**✅ 阶段测试3：状态管理验证**
```typescript
// frontend/src/tests/store/authSlice.test.ts

import { configureStore } from '@reduxjs/toolkit';
import authSlice, {
  setUser,
  setFeishuTokens,
  updateFeishuInfo,
  clearFeishuTokens,
  selectIsFeishuUser,
  selectFeishuInfo
} from '../../store/slices/authSlice';

describe('authSlice - Feishu integration', () => {
  let store: ReturnType<typeof configureStore>;

  beforeEach(() => {
    store = configureStore({
      reducer: {
        auth: authSlice
      }
    });
  });

  test('should handle setFeishuTokens', () => {
    const tokens = {
      feishu_access_token: 'test_token',
      feishu_refresh_token: 'refresh_token',
      feishu_expires_at: 1234567890
    };

    store.dispatch(setFeishuTokens(tokens));

    const state = store.getState().auth;
    expect(state.feishu_access_token).toBe(tokens.feishu_access_token);
    expect(state.feishu_refresh_token).toBe(tokens.feishu_refresh_token);
    expect(state.feishu_expires_at).toBe(tokens.feishu_expires_at);
  });

  test('should handle updateFeishuInfo', () => {
    const user = {
      id: '1',
      username: 'testuser',
      email: 'test@example.com',
      full_name: 'Test User',
      roles: ['user'],
      permissions: []
    };

    const feishuInfo = {
      user_id: 'feishu_123',
      name: 'Test User',
      en_name: 'Test User EN',
      email: 'test@company.com',
      avatar_url: 'https://example.com/avatar.jpg'
    };

    store.dispatch(setUser(user));
    store.dispatch(updateFeishuInfo(feishuInfo));

    const state = store.getState().auth;
    expect(state.user?.feishu_info).toEqual(feishuInfo);
    expect(state.user?.is_feishu_user).toBe(true);
    expect(state.user?.auth_provider).toBe('feishu');
    expect(state.user?.last_feishu_sync).toBeDefined();
  });

  test('should handle clearFeishuTokens', () => {
    const tokens = {
      feishu_access_token: 'test_token',
      feishu_refresh_token: 'refresh_token',
      feishu_expires_at: 1234567890
    };

    store.dispatch(setFeishuTokens(tokens));
    store.dispatch(clearFeishuTokens());

    const state = store.getState().auth;
    expect(state.feishu_access_token).toBeUndefined();
    expect(state.feishu_refresh_token).toBeUndefined();
    expect(state.feishu_expires_at).toBeUndefined();
  });

  test('selectors should work correctly', () => {
    const user = {
      id: '1',
      username: 'testuser',
      email: 'test@example.com',
      full_name: 'Test User',
      roles: ['user'],
      permissions: [],
      auth_provider: 'feishu' as const,
      feishu_info: {
        user_id: 'feishu_123',
        name: 'Test User',
        email: 'test@company.com'
      }
    };

    store.dispatch(setUser(user));

    const state = store.getState();
    expect(selectIsFeishuUser(state)).toBe(true);
    expect(selectFeishuInfo(state)).toEqual(user.feishu_info);
  });
});
```

### 任务4：前端完整集成和测试 (1天)

#### 4.1 创建飞书API客户端
```typescript
// frontend/src/api/feishuApi.ts

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { RootState } from '../store';

interface GetAuthorizationUrlRequest {
  state?: string;
}

interface GetAuthorizationUrlResponse {
  authorization_url: string;
  state: string;
}

interface HandleCallbackRequest {
  code: string;
  state?: string;
}

interface HandleCallbackResponse {
  access_token: string;
  refresh_token: string;
  user: {
    id: string;
    username: string;
    email: string;
    full_name: string;
    avatar_url?: string;
    roles: string[];
    permissions: string[];
    auth_provider: 'feishu';
    feishu_info: {
      user_id: string;
      name: string;
      en_name?: string;
      email?: string;
      avatar_url?: string;
      mobile?: string;
      department_ids?: string[];
      union_id?: string;
      open_id?: string;
    };
  };
}

interface RefreshTokensResponse {
  access_token: string;
  refresh_token: string;
}

interface ValidateAccessResponse {
  valid: boolean;
  user?: any;
}

export const feishuApi = createApi({
  reducerPath: 'feishuApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/v1/feishu-auth',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.access_token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['FeishuAuth'],
  endpoints: (builder) => ({
    getAuthorizationUrl: builder.mutation<GetAuthorizationUrlResponse, GetAuthorizationUrlRequest>({
      query: (params) => ({
        url: '/authorize',
        method: 'GET',
        params,
      }),
    }),

    handleCallback: builder.mutation<HandleCallbackResponse, HandleCallbackRequest>({
      query: (data) => ({
        url: '/callback',
        method: 'POST',
        body: data,
      }),
    }),

    refreshTokens: builder.mutation<RefreshTokensResponse, void>({
      query: () => ({
        url: '/refresh-tokens',
        method: 'POST',
      }),
    }),

    validateAccess: builder.query<ValidateAccessResponse, void>({
      query: () => '/validate-access',
      providesTags: ['FeishuAuth'],
    }),

    // 用户信息同步
    syncUserInfo: builder.mutation<{ success: boolean; message: string }, void>({
      query: () => ({
        url: '/sync-user-info',
        method: 'POST',
      }),
      invalidatesTags: ['FeishuAuth'],
    }),

    // 获取飞书用户详细信息
    getFeishuUserInfo: builder.query<any, void>({
      query: () => '/user-info',
      providesTags: ['FeishuAuth'],
    }),
  }),
});

export const {
  useGetAuthorizationUrlMutation,
  useHandleCallbackMutation,
  useRefreshTokensMutation,
  useValidateAccessQuery,
  useSyncUserInfoMutation,
  useGetFeishuUserInfoQuery,
} = feishuApi;

// 导出非Hook版本的API，供useFeishuAuth Hook使用
export const feishuApiEndpoints = {
  getAuthorizationUrl: async (params: GetAuthorizationUrlRequest): Promise<GetAuthorizationUrlResponse> => {
    const response = await fetch(`/api/v1/feishu-auth/authorize?${new URLSearchParams(params as any)}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to get authorization URL');
    }

    return response.json();
  },

  handleCallback: async (data: HandleCallbackRequest): Promise<HandleCallbackResponse> => {
    const response = await fetch('/api/v1/feishu-auth/callback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to handle callback');
    }

    return response.json();
  },

  refreshTokens: async (): Promise<RefreshTokensResponse> => {
    const token = localStorage.getItem('refresh_token');
    const response = await fetch('/api/v1/feishu-auth/refresh-tokens', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to refresh tokens');
    }

    return response.json();
  },

  validateAccess: async (): Promise<ValidateAccessResponse> => {
    const token = localStorage.getItem('access_token');
    const response = await fetch('/api/v1/feishu-auth/validate-access', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to validate access');
    }

    return response.json();
  },
};
```

#### 4.2 集成到主应用
```typescript
// frontend/src/store/index.ts - 扩展现有store配置

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authSlice from './slices/authSlice';
import { feishuApi } from '../api/feishuApi';
// ... 其他现有API和slice导入

export const store = configureStore({
  reducer: {
    auth: authSlice,
    // ... 其他现有reducer

    // 添加feishuApi reducer
    [feishuApi.reducerPath]: feishuApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [
          // RTK Query的内部actions
          feishuApi.util.getRunningQueriesThunk.fulfilled.type,
          feishuApi.util.getRunningQueriesThunk.pending.type,
          feishuApi.util.getRunningQueriesThunk.rejected.type,
        ],
      },
    })
      // 添加现有的middleware
      .concat(feishuApi.middleware),
});

// 启用RTK Query的自动重新获取和缓存行为
setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

#### 4.3 创建端到端测试
```typescript
// frontend/src/tests/e2e/feishuLogin.test.ts

/*
 * Copyright(c) 2025
 * All rights reserved.
 *
 * Author: yukun.xing <xingyukun@gmail.com>
 * Date:   2025/09/19
 */

import { test, expect, Page } from '@playwright/test';

// 模拟飞书OAuth流程的端到端测试
test.describe('Feishu Login Integration', () => {
  let page: Page;

  test.beforeEach(async ({ browser }) => {
    page = await browser.newPage();

    // 监听网络请求以验证API调用
    await page.route('/api/v1/feishu-auth/**', async route => {
      // 模拟后端响应
      const url = route.request().url();

      if (url.includes('/authorize')) {
        await route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify({
            authorization_url: 'https://open.feishu.cn/open-apis/authen/v1/index?app_id=test&redirect_uri=http://localhost:3000/auth/feishu/callback&response_type=code&scope=user:read&state=test_state',
            state: 'test_state'
          })
        });
      } else if (url.includes('/callback')) {
        await route.fulfill({
          status: 200,
          contentType: 'application/json',
          body: JSON.stringify({
            access_token: 'test_access_token',
            refresh_token: 'test_refresh_token',
            user: {
              id: '1',
              username: 'testuser',
              email: 'test@company.com',
              full_name: 'Test User',
              avatar_url: 'https://example.com/avatar.jpg',
              roles: ['user'],
              permissions: ['read:dashboard'],
              auth_provider: 'feishu',
              feishu_info: {
                user_id: 'ou_123456',
                name: 'Test User',
                en_name: 'Test User',
                email: 'test@company.com',
                avatar_url: 'https://example.com/avatar.jpg'
              }
            }
          })
        });
      }
    });
  });

  test('should display Feishu login button on login page', async () => {
    await page.goto('/auth/login');

    // 验证飞书登录按钮存在
    const feishuButton = page.locator('button:has-text("Login with Feishu")');
    await expect(feishuButton).toBeVisible();

    // 验证按钮样式
    await expect(feishuButton).toHaveCSS('border-color', 'rgb(0, 212, 170)');
  });

  test('should handle Feishu login flow', async () => {
    await page.goto('/auth/login');

    // 点击飞书登录按钮
    const feishuButton = page.locator('button:has-text("Login with Feishu")');
    await feishuButton.click();

    // 验证按钮显示加载状态
    await expect(page.locator('button:has-text("Connecting to Feishu")')).toBeVisible();

    // 由于我们mock了API响应，页面应该重定向到飞书授权页面
    // 在真实环境中，这里会跳转到飞书的授权页面
    // 但在测试中，我们需要模拟这个流程

    // 验证sessionStorage中存储了state
    const storedState = await page.evaluate(() => sessionStorage.getItem('feishu_oauth_state'));
    expect(storedState).toBeTruthy();
  });

  test('should handle callback page correctly', async () => {
    // 模拟从飞书回调的URL
    await page.goto('/auth/feishu/callback?code=test_code&state=test_state');

    // 初始应该显示加载状态
    await expect(page.locator('text=Processing Feishu login')).toBeVisible();

    // 等待处理完成，应该显示成功状态
    await expect(page.locator('text=Login Successful!')).toBeVisible();

    // 应该有重定向按钮
    const dashboardButton = page.locator('button:has-text("Go to Dashboard")');
    await expect(dashboardButton).toBeVisible();
  });

  test('should handle callback error correctly', async () => {
    // 模拟飞书回调错误
    await page.goto('/auth/feishu/callback?error=access_denied&error_description=User%20cancelled');

    // 应该显示错误状态
    await expect(page.locator('text=Login Failed')).toBeVisible();
    await expect(page.locator('text=User cancelled')).toBeVisible();

    // 应该有重试按钮
    const retryButton = page.locator('button:has-text("Try Again")');
    await expect(retryButton).toBeVisible();
  });

  test('should display user info correctly after login', async () => {
    // 先模拟已登录状态
    await page.evaluate(() => {
      localStorage.setItem('access_token', 'test_token');
      localStorage.setItem('user', JSON.stringify({
        id: '1',
        username: 'testuser',
        email: 'test@company.com',
        full_name: 'Test User',
        avatar_url: 'https://example.com/avatar.jpg',
        roles: ['user'],
        permissions: ['read:dashboard'],
        auth_provider: 'feishu',
        feishu_info: {
          user_id: 'ou_123456',
          name: 'Test User',
          en_name: 'Test User',
          email: 'test@company.com',
          avatar_url: 'https://example.com/avatar.jpg'
        }
      }));
    });

    await page.goto('/dashboard');

    // 验证用户信息显示
    await expect(page.locator('text=Test User')).toBeVisible();

    // 验证飞书标签显示
    await expect(page.locator('.ant-tag:has-text("Feishu")')).toBeVisible();
  });
});
```

**✅ 阶段测试4：完整集成验证**
```bash
# 前端测试脚本
# frontend/scripts/test-feishu-integration.sh

#!/bin/bash

# Copyright(c) 2025
# All rights reserved.
#
# Author: yukun.xing <xingyukun@gmail.com>
# Date:   2025/09/19

echo "🚀 Running Feishu Frontend Integration Tests..."

# 确保在正确的目录
cd "$(dirname "$0")/.."

# 安装依赖
echo "📦 Installing dependencies..."
npm install

# 运行单元测试
echo "🧪 Running unit tests..."
npm run test -- --testPathPattern="feishu|Feishu" --coverage

# 运行类型检查
echo "🔍 Running TypeScript checks..."
npm run type-check

# 运行linting
echo "✨ Running ESLint..."
npm run lint

# 构建检查
echo "🏗️ Running build check..."
npm run build

# 如果安装了playwright，运行E2E测试
if command -v npx playwright &> /dev/null; then
    echo "🎭 Running E2E tests..."
    npx playwright test --grep="Feishu"
else
    echo "⚠️  Playwright not found, skipping E2E tests"
fi

echo "✅ Feishu Frontend Integration Tests Completed!"

# 运行示例命令
echo ""
echo "📋 Manual Testing Checklist:"
echo "1. Start the development server: npm run dev"
echo "2. Navigate to /auth/login"
echo "3. Verify Feishu login button is displayed"
echo "4. Click the button and verify redirect behavior"
echo "5. Test callback page with mock parameters"
echo "6. Verify user profile displays Feishu information"
echo "7. Test error handling scenarios"
```

## 🎯 阶段交付物

### 文档输出
- [ ] React组件开发文档
- [ ] 前端集成测试报告
- [ ] 用户体验设计说明
- [ ] 问题排查指南

### 代码输出
- [ ] 5个核心React组件
- [ ] 2个自定义Hook
- [ ] 1个Redux Slice扩展
- [ ] 1个API客户端
- [ ] 完整的测试套件（单元测试 + E2E测试）

### 功能验证
- [ ] 飞书登录按钮正常显示和交互
- [ ] OAuth回调处理完整流程
- [ ] 用户信息正确显示和同步
- [ ] 错误处理和用户反馈
- [ ] 状态管理和路由集成
- [ ] 跨浏览器兼容性验证

## 📈 成功标准

1. **功能完整性**：所有飞书登录相关功能正常工作
2. **用户体验**：登录流程顺畅，错误处理友好
3. **代码质量**：通过所有测试，符合项目编码规范
4. **性能表现**：登录响应时间 < 3秒
5. **安全性**：CSRF防护、状态验证、令牌管理安全
6. **兼容性**：支持主流浏览器，响应式设计

---

**预计完成时间**：3-4天
**关键依赖**：第1、2阶段完成，后端API可用
**风险控制**：充分的测试覆盖，详细的错误处理
**下一阶段**：第4阶段 - 高级功能和生产部署